{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { OptimismPortal } from \"./OptimismPortal.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @notice Address of the OptimismPortal.\n     */\n    OptimismPortal public immutable PORTAL;\n\n    /**\n     * @custom:semver 1.4.0\n     *\n     * @param _portal Address of the OptimismPortal contract on this network.\n     */\n    constructor(OptimismPortal _portal)\n        Semver(1, 4, 0)\n        CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER)\n    {\n        PORTAL = _portal;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        PORTAL.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(PORTAL);\n    }\n}\n"
    },
    "contracts/L1/L1ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title L1ERC721Bridge\n * @notice The L1 ERC721 bridge is a contract which works together with the L2 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Optimism. This contract\n *         acts as an escrow for ERC721 tokens deposited into L2.\n */\ncontract L1ERC721Bridge is ERC721Bridge, Semver {\n    /**\n     * @notice Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token\n     *         by ID was deposited for a given L2 token.\n     */\n    mapping(address => mapping(address => mapping(uint256 => bool))) public deposits;\n\n    /**\n     * @custom:semver 1.1.1\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge)\n        Semver(1, 1, 1)\n        ERC721Bridge(_messenger, _otherBridge)\n    {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L1ERC721Bridge: local token cannot be self\");\n\n        // Checks that the L1/L2 NFT pair has a token ID that is escrowed in the L1 Bridge.\n        require(\n            deposits[_localToken][_remoteToken][_tokenId] == true,\n            \"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\"\n        );\n\n        // Mark that the token ID for this L1/L2 token pair is no longer escrowed in the L1\n        // Bridge.\n        deposits[_localToken][_remoteToken][_tokenId] = false;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the NFT to the\n        // withdrawer.\n        IERC721(_localToken).safeTransferFrom(address(this), _to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L1ERC721Bridge: remote token cannot be address(0)\");\n\n        // Construct calldata for _l2Token.finalizeBridgeERC721(_to, _tokenId)\n        bytes memory message = abi.encodeWithSelector(\n            L2ERC721Bridge.finalizeBridgeERC721.selector,\n            _remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Lock token into bridge\n        deposits[_localToken][_remoteToken][_tokenId] = true;\n        IERC721(_localToken).transferFrom(_from, address(this), _tokenId);\n\n        // Send calldata into L2\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n        emit ERC721BridgeInitiated(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title L1StandardBridge\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\n *         contract. If the ERC20 token is native to L2, it will be burnt. Before Bedrock, ETH was\n *         stored within this contract. After Bedrock, ETH is instead stored inside the\n *         OptimismPortal contract.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L1StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a deposit of ETH from L1 into L2 is initiated.\n     *\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of ETH deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event ETHDepositInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal of ETH from L2 to L1 is finalized.\n     *\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of ETH withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event ETHWithdrawalFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is initiated.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of the ERC20 deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event ERC20DepositInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 withdrawal is finalized.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of the ERC20 withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event ERC20WithdrawalFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    constructor(address payable _messenger)\n        Semver(1, 1, 0)\n        StandardBridge(_messenger, payable(Predeploys.L2_STANDARD_BRIDGE))\n    {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ETH into the sender's account on L2.\n     *\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ETH into a target account on L2.\n     *         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\n     *         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *\n     * @param _to          Address of the recipient on L2.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ERC20 tokens into a target account on L2.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _to          Address of the recipient on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external virtual {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a withdrawal of ETH from L2.\n     *\n     * @param _from      Address of the withdrawer on L2.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of ETH to withdraw.\n     * @param _extraData Optional data forwarded from L2.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable {\n        finalizeBridgeETH(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a withdrawal of ERC20 tokens from L2.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the withdrawer on L2.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of the ERC20 to withdraw.\n     * @param _extraData Optional data forwarded from L2.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external {\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the access of the corresponding L2 bridge contract.\n     *\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external view returns (address) {\n        return address(OTHER_BRIDGE);\n    }\n\n    /**\n     * @notice Internal function for initiating an ETH deposit.\n     *\n     * @param _from        Address of the sender on L1.\n     * @param _to          Address of the recipient on L2.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Internal function for initiating an ERC20 deposit.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _from        Address of the sender on L1.\n     * @param _to          Address of the recipient on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy ETHDepositInitiated event followed by the ETHBridgeInitiated event.\n     *         This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitETHBridgeInitiated(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit ETHDepositInitiated(_from, _to, _amount, _extraData);\n        super._emitETHBridgeInitiated(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy ETHWithdrawalFinalized event followed by the ETHBridgeFinalized\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitETHBridgeFinalized(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _extraData);\n        super._emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy ERC20DepositInitiated event followed by the ERC20BridgeInitiated\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitERC20BridgeInitiated(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit ERC20DepositInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n        super._emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy ERC20WithdrawalFinalized event followed by the ERC20BridgeFinalized\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitERC20BridgeFinalized(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit ERC20WithdrawalFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n        super._emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\n *         commitment to the state of the L2 chain. Other contracts like the OptimismPortal use\n *         these outputs to verify information about the state of L2.\n */\ncontract L2OutputOracle is Initializable, Semver {\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is\n     *         immutable, it can safely be modified by upgrading the implementation contract.\n     */\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\n     */\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice The address of the challenger. Can be updated via upgrade.\n     */\n    address public immutable CHALLENGER;\n\n    /**\n     * @notice The address of the proposer. Can be updated via upgrade.\n     */\n    address public immutable PROPOSER;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    uint256 public startingBlockNumber;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    uint256 public startingTimestamp;\n\n    /**\n     * @notice Array of L2 output proposals.\n     */\n    Types.OutputProposal[] internal l2Outputs;\n\n    /**\n     * @notice Emitted when an output is proposed.\n     *\n     * @param outputRoot    The output root.\n     * @param l2OutputIndex The index of the output in the l2Outputs array.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param l1Timestamp   The L1 timestamp when proposed.\n     */\n    event OutputProposed(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    /**\n     * @notice Emitted when outputs are deleted.\n     *\n     * @param prevNextOutputIndex Next L2 output index before the deletion.\n     * @param newNextOutputIndex  Next L2 output index after the deletion.\n     */\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\n\n    /**\n     * @custom:semver 1.3.0\n     *\n     * @param _submissionInterval  Interval in blocks at which checkpoints must be submitted.\n     * @param _l2BlockTime         The time per L2 block, in seconds.\n     * @param _startingBlockNumber The number of the first L2 block.\n     * @param _startingTimestamp   The timestamp of the first L2 block.\n     * @param _proposer            The address of the proposer.\n     * @param _challenger          The address of the challenger.\n     */\n    constructor(\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        address _proposer,\n        address _challenger,\n        uint256 _finalizationPeriodSeconds\n    ) Semver(1, 3, 0) {\n        require(_l2BlockTime > 0, \"L2OutputOracle: L2 block time must be greater than 0\");\n        require(\n            _submissionInterval > 0,\n            \"L2OutputOracle: submission interval must be greater than 0\"\n        );\n\n        SUBMISSION_INTERVAL = _submissionInterval;\n        L2_BLOCK_TIME = _l2BlockTime;\n        PROPOSER = _proposer;\n        CHALLENGER = _challenger;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n\n        initialize(_startingBlockNumber, _startingTimestamp);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _startingBlockNumber Block number for the first recoded L2 block.\n     * @param _startingTimestamp   Timestamp for the first recoded L2 block.\n     */\n    function initialize(uint256 _startingBlockNumber, uint256 _startingTimestamp)\n        public\n        initializer\n    {\n        require(\n            _startingTimestamp <= block.timestamp,\n            \"L2OutputOracle: starting L2 timestamp must be less than current time\"\n        );\n\n        startingTimestamp = _startingTimestamp;\n        startingBlockNumber = _startingBlockNumber;\n    }\n\n    /**\n     * @notice Deletes all output proposals after and including the proposal that corresponds to\n     *         the given output index. Only the challenger address can delete outputs.\n     *\n     * @param _l2OutputIndex Index of the first L2 output to be deleted. All outputs after this\n     *                       output will also be deleted.\n     */\n    // solhint-disable-next-line ordering\n    function deleteL2Outputs(uint256 _l2OutputIndex) external {\n        require(\n            msg.sender == CHALLENGER,\n            \"L2OutputOracle: only the challenger address can delete outputs\"\n        );\n\n        // Make sure we're not *increasing* the length of the array.\n        require(\n            _l2OutputIndex < l2Outputs.length,\n            \"L2OutputOracle: cannot delete outputs after the latest output index\"\n        );\n\n        // Do not allow deleting any outputs that have already been finalized.\n        require(\n            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < FINALIZATION_PERIOD_SECONDS,\n            \"L2OutputOracle: cannot delete outputs that have already been finalized\"\n        );\n\n        uint256 prevNextL2OutputIndex = nextOutputIndex();\n\n        // Use assembly to delete the array elements because Solidity doesn't allow it.\n        assembly {\n            sstore(l2Outputs.slot, _l2OutputIndex)\n        }\n\n        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\n    }\n\n    /**\n     * @notice Accepts an outputRoot and the timestamp of the corresponding L2 block. The timestamp\n     *         must be equal to the current value returned by `nextTimestamp()` in order to be\n     *         accepted. This function may only be called by the Proposer.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n     * @param _l1BlockHash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function proposeL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external payable {\n        require(\n            msg.sender == PROPOSER,\n            \"L2OutputOracle: only the proposer address can propose new outputs\"\n        );\n\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot propose L2 output in the future\"\n        );\n\n        require(\n            _outputRoot != bytes32(0),\n            \"L2OutputOracle: L2 output proposal cannot be the zero hash\"\n        );\n\n        if (_l1BlockHash != bytes32(0)) {\n            // This check allows the proposer to propose an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the proposer's submission is censored until the block is no longer\n            // retrievable, if the proposer is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"L2OutputOracle: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\n\n        l2Outputs.push(\n            Types.OutputProposal({\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    /**\n     * @notice Returns an output by index. Exists because Solidity's array access will return a\n     *         tuple instead of a struct.\n     *\n     * @param _l2OutputIndex Index of the output to return.\n     *\n     * @return The output at the given index.\n     */\n    function getL2Output(uint256 _l2OutputIndex)\n        external\n        view\n        returns (Types.OutputProposal memory)\n    {\n        return l2Outputs[_l2OutputIndex];\n    }\n\n    /**\n     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return Index of the first checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\n        // Make sure an output for this block number has actually been proposed.\n        require(\n            _l2BlockNumber <= latestBlockNumber(),\n            \"L2OutputOracle: cannot get output for a block that has not been proposed\"\n        );\n\n        // Make sure there's at least one output proposed.\n        require(\n            l2Outputs.length > 0,\n            \"L2OutputOracle: cannot get output as no outputs have been proposed yet\"\n        );\n\n        // Find the output via binary search, guaranteed to exist.\n        uint256 lo = 0;\n        uint256 hi = l2Outputs.length;\n        while (lo < hi) {\n            uint256 mid = (lo + hi) / 2;\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    /**\n     * @notice Returns the L2 output proposal that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return First checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputAfter(uint256 _l2BlockNumber)\n        external\n        view\n        returns (Types.OutputProposal memory)\n    {\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\n    }\n\n    /**\n     * @notice Returns the number of outputs that have been proposed. Will revert if no outputs\n     *         have been proposed yet.\n     *\n     * @return The number of outputs that have been proposed.\n     */\n    function latestOutputIndex() external view returns (uint256) {\n        return l2Outputs.length - 1;\n    }\n\n    /**\n     * @notice Returns the index of the next output to be proposed.\n     *\n     * @return The index of the next output to be proposed.\n     */\n    function nextOutputIndex() public view returns (uint256) {\n        return l2Outputs.length;\n    }\n\n    /**\n     * @notice Returns the block number of the latest submitted L2 output proposal. If no proposals\n     *         been submitted yet then this function will return the starting block number.\n     *\n     * @return Latest submitted L2 block number.\n     */\n    function latestBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0\n                ? startingBlockNumber\n                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed.\n     *\n     * @return Next L2 block number.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return latestBlockNumber() + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     *\n     * @return L2 timestamp of the given block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\n    }\n}\n"
    },
    "contracts/L1/OptimismPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice Address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         withdrawals are paused. This may be removed in the future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"OptimismPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.6.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _guardian                  Address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config\n    ) Semver(1, 6, 0) {\n        L2_ORACLE = _l2Oracle;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Computes the minimum gas limit for a deposit. The minimum gas limit\n     *         linearly increases based on the size of the calldata. This is to prevent\n     *         users from creating L2 resource usage without paying for it. This function\n     *         can be used when interacting with the portal to ensure forwards compatibility.\n     *\n     */\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\n        return _byteCount * 16 + 21000;\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\n     */\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"OptimismPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is proposal submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been proposed yet.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-proposed.\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the output proposal has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\n        // more for more resource usage.\n        require(\n            _gasLimit >= minimumGasLimit(uint64(_data.length)),\n            \"OptimismPortal: gas limit too small\"\n        );\n\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\n        // transactions are not gossipped over the p2p network.\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if a given output is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}\n"
    },
    "contracts/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\n\n/**\n * @custom:upgradeable\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\nabstract contract ResourceMetering is Initializable {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     *\n     * @custom:field prevBaseFee   Base fee from the previous block(s).\n     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n     * @custom:field prevBlockNum  Last block number that the base fee was updated.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\n     *         market. These values should be set with care as it is possible to set them in\n     *         a way that breaks the deposit gas market. The target resource limit is defined as\n     *         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\n     *         single word. There is additional space for additions in the future.\n     *\n     * @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\n     *                                            can be purchased per block.\n     * @custom:field elasticityMultiplier         Determines the target resource limit along with\n     *                                            the resource limit.\n     * @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\n     * @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\n     *                                            value.\n     * @custom:field systemTxMaxGas               The amount of gas supplied to the system\n     *                                            transaction. This should be set to the same number\n     *                                            that the op-node sets as the gas limit for the\n     *                                            system transaction.\n     * @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\n     *                                            value.\n     */\n    struct ResourceConfig {\n        uint32 maxResourceLimit;\n        uint8 elasticityMultiplier;\n        uint8 baseFeeMaxChangeDenominator;\n        uint32 minimumBaseFee;\n        uint32 systemTxMaxGas;\n        uint128 maximumBaseFee;\n    }\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Run the metering function.\n        _metered(_amount, initialGas);\n    }\n\n    /**\n     * @notice An internal function that holds all of the logic for metering a resource.\n     *\n     * @param _amount     Amount of the resource requested.\n     * @param _initialGas The amount of gas before any modifier execution.\n     */\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n\n        ResourceConfig memory config = _resourceConfig();\n        int256 targetResourceLimit = int256(uint256(config.maxResourceLimit)) /\n            int256(uint256(config.elasticityMultiplier));\n\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = Arithmetic.clamp({\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                _min: int256(uint256(config.minimumBaseFee)),\n                _max: int256(uint256(config.maximumBaseFee))\n            });\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = Arithmetic.clamp({\n                    _value: Arithmetic.cdexp({\n                        _coefficient: newBaseFee,\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\n                        _exponent: int256(blockDiff - 1)\n                    }),\n                    _min: int256(uint256(config.minimumBaseFee)),\n                    _max: int256(uint256(config.maximumBaseFee))\n                });\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),\n            \"ResourceMetering: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = _initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /**\n     * @notice Virtual function that returns the resource config. Contracts that inherit this\n     *         contract must implement this function.\n     *\n     * @return ResourceConfig\n     */\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({\n            prevBaseFee: 1 gwei,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n}\n"
    },
    "contracts/L1/SystemConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\n\n/**\n * @title SystemConfig\n * @notice The SystemConfig contract is used to manage configuration of an Optimism network. All\n *         configuration is stored on L1 and picked up by L2 as part of the derviation of the L2\n *         chain.\n */\ncontract SystemConfig is OwnableUpgradeable, Semver {\n    /**\n     * @notice Enum representing different types of updates.\n     *\n     * @custom:value BATCHER              Represents an update to the batcher hash.\n     * @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.\n     * @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\n     * @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\n     *                                    block distrubution.\n     */\n    enum UpdateType {\n        BATCHER,\n        GAS_CONFIG,\n        GAS_LIMIT,\n        UNSAFE_BLOCK_SIGNER\n    }\n\n    /**\n     * @notice Version identifier, used for upgrades.\n     */\n    uint256 public constant VERSION = 0;\n\n    /**\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\n     *         deterministic storage slot allows for decoupling the storage layout from the way\n     *         that `solc` lays out storage. The `op-node` uses a storage proof to fetch this value.\n     */\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\"systemconfig.unsafeblocksigner\");\n\n    /**\n     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\n     *         as an address left-padded with zeros to 32 bytes.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice L2 block gas limit.\n     */\n    uint64 public gasLimit;\n\n    /**\n     * @notice The configuration for the deposit fee market. Used by the OptimismPortal\n     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter\n     *         so that the struct is returned instead of a tuple.\n     */\n    ResourceMetering.ResourceConfig internal _resourceConfig;\n\n    /**\n     * @notice Emitted when configuration is updated\n     *\n     * @param version    SystemConfig version.\n     * @param updateType Type of update.\n     * @param data       Encoded update data.\n     */\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\n\n    /**\n     * @custom:semver 1.3.0\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     * @param _config            Initial resource config.\n     */\n    constructor(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) Semver(1, 3, 0) {\n        initialize({\n            _owner: _owner,\n            _overhead: _overhead,\n            _scalar: _scalar,\n            _batcherHash: _batcherHash,\n            _gasLimit: _gasLimit,\n            _unsafeBlockSigner: _unsafeBlockSigner,\n            _config: _config\n        });\n    }\n\n    /**\n     * @notice Initializer. The resource config must be set before the\n     *         require check.\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     * @param _config            Initial ResourceConfig.\n     */\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n        _setResourceConfig(_config);\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n    }\n\n    /**\n     * @notice Returns the minimum L2 gas limit that can be safely set for the system to\n     *         operate. The L2 gas limit must be larger than or equal to the amount of\n     *         gas that is allocated for deposits per block plus the amount of gas that\n     *         is allocated for the system transaction.\n     *         This function is used to determine if changes to parameters are safe.\n     *\n     * @return uint64\n     */\n    function minimumGasLimit() public view returns (uint64) {\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\n    }\n\n    /**\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\n     *         propagated across the p2p network if they are signed by the key corresponding to\n     *         this address.\n     *\n     * @return Address of the unsafe block signer.\n     */\n    // solhint-disable-next-line ordering\n    function unsafeBlockSigner() external view returns (address) {\n        address addr;\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            addr := sload(slot)\n        }\n        return addr;\n    }\n\n    /**\n     * @notice Updates the unsafe block signer address.\n     *\n     * @param _unsafeBlockSigner New unsafe block signer address.\n     */\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n\n        bytes memory data = abi.encode(_unsafeBlockSigner);\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\n    }\n\n    /**\n     * @notice Updates the batcher hash.\n     *\n     * @param _batcherHash New batcher hash.\n     */\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\n        batcherHash = _batcherHash;\n\n        bytes memory data = abi.encode(_batcherHash);\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\n    }\n\n    /**\n     * @notice Updates gas config.\n     *\n     * @param _overhead New overhead value.\n     * @param _scalar   New scalar value.\n     */\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\n        overhead = _overhead;\n        scalar = _scalar;\n\n        bytes memory data = abi.encode(_overhead, _scalar);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\n    }\n\n    /**\n     * @notice Updates the L2 gas limit.\n     *\n     * @param _gasLimit New gas limit.\n     */\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n\n    /**\n     * @notice Low level setter for the unsafe block signer address. This function exists to\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\n     *\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\n     */\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            sstore(slot, _unsafeBlockSigner)\n        }\n    }\n\n    /**\n     * @notice A getter for the resource config. Ensures that the struct is\n     *         returned instead of a tuple.\n     *\n     * @return ResourceConfig\n     */\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig;\n    }\n\n    /**\n     * @notice An external setter for the resource config. In the future, this\n     *         method may emit an event that the `op-node` picks up for when the\n     *         resource config is changed.\n     *\n     * @param _config The new resource config values.\n     */\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\n        _setResourceConfig(_config);\n    }\n\n    /**\n     * @notice An internal setter for the resource config. Ensures that the\n     *         config is sane before storing it by checking for invariants.\n     *\n     * @param _config The new resource config.\n     */\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\n        // Min base fee must be less than or equal to max base fee.\n        require(\n            _config.minimumBaseFee <= _config.maximumBaseFee,\n            \"SystemConfig: min base fee must be less than max base\"\n        );\n        // Base fee change denominator must be greater than 1.\n        require(\n            _config.baseFeeMaxChangeDenominator > 1,\n            \"SystemConfig: denominator must be larger than 1\"\n        );\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\n        // The gas limit must be increased before these values can be increased.\n        require(\n            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,\n            \"SystemConfig: gas limit too low\"\n        );\n        // Elasticity multiplier must be greater than 0.\n        require(\n            _config.elasticityMultiplier > 0,\n            \"SystemConfig: elasticity multiplier cannot be 0\"\n        );\n        // No precision loss when computing target resource limit.\n        require(\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) *\n                _config.elasticityMultiplier) == _config.maxResourceLimit,\n            \"SystemConfig: precision loss with target resource limit\"\n        );\n\n        _resourceConfig = _config;\n    }\n}\n"
    },
    "contracts/L2/BaseFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { FeeVault } from \"../universal/FeeVault.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000019\n * @title BaseFeeVault\n * @notice The BaseFeeVault accumulates the base fee that is paid by transactions.\n */\ncontract BaseFeeVault is FeeVault, Semver {\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(1, 1, 0) {}\n}\n"
    },
    "contracts/L2/CrossDomainOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\n/**\n * @title CrossDomainOwnable\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is only safe to be used if the\n *         CrossDomainMessenger system is bypassed and the caller on L1 is calling the\n *         OptimismPortal directly.\n */\nabstract contract CrossDomainOwnable is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `msg.sender` is the owner of the contract.\n     */\n    function _checkOwner() internal view override {\n        require(\n            owner() == AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n            \"CrossDomainOwnable: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title CrossDomainOwnable2\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is meant to be used with systems that use\n *         the CrossDomainMessenger system. It will not work if the OptimismPortal is used\n *         directly.\n */\nabstract contract CrossDomainOwnable2 is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER\n        );\n\n        require(\n            msg.sender == address(messenger),\n            \"CrossDomainOwnable2: caller is not the messenger\"\n        );\n\n        require(\n            owner() == messenger.xDomainMessageSender(),\n            \"CrossDomainOwnable2: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title CrossDomainOwnable3\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on either L1 or L2. Note that this contract is meant to be used with systems\n *         that use the CrossDomainMessenger system. It will not work if the OptimismPortal is\n *         used directly.\n */\nabstract contract CrossDomainOwnable3 is Ownable {\n    /**\n     * @notice If true, the contract uses the cross domain _checkOwner function override. If false\n     *         it uses the standard Ownable _checkOwner function.\n     */\n    bool public isLocal = true;\n\n    /**\n     * @notice Emits when ownership of the contract is transferred. Includes the\n     *         isLocal field in addition to the standard `Ownable` OwnershipTransferred event.\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    /**\n     * @notice Allows for ownership to be transferred with specifying the locality.\n     * @param _owner   The new owner of the contract.\n     * @param _isLocal Configures the locality of the ownership.\n     */\n    function transferOwnership(address _owner, bool _isLocal) external onlyOwner {\n        require(_owner != address(0), \"CrossDomainOwnable3: new owner is the zero address\");\n\n        address oldOwner = owner();\n        _transferOwnership(_owner);\n        isLocal = _isLocal;\n\n        emit OwnershipTransferred(oldOwner, _owner, _isLocal);\n    }\n\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        if (isLocal) {\n            require(owner() == msg.sender, \"CrossDomainOwnable3: caller is not the owner\");\n        } else {\n            L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER\n            );\n\n            require(\n                msg.sender == address(messenger),\n                \"CrossDomainOwnable3: caller is not the messenger\"\n            );\n\n            require(\n                owner() == messenger.xDomainMessageSender(),\n                \"CrossDomainOwnable3: caller is not the owner\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x420000000000000000000000000000000000000F\n * @title GasPriceOracle\n * @notice This contract maintains the variables responsible for computing the L1 portion of the\n *         total fee charged on L2. Before Bedrock, this contract held variables in state that were\n *         read during the state transition function to compute the L1 portion of the transaction\n *         fee. After Bedrock, this contract now simply proxies the L1Block contract, which has\n *         the values used to compute the L1 portion of the fee in its state.\n *\n *         The contract exposes an API that is useful for knowing how large the L1 portion of the\n *         transaction fee will be. The following events were deprecated with Bedrock:\n *         - event OverheadUpdated(uint256 overhead);\n *         - event ScalarUpdated(uint256 scalar);\n *         - event DecimalsUpdated(uint256 decimals);\n */\ncontract GasPriceOracle is Semver {\n    /**\n     * @notice Number of decimals used in the scalar.\n     */\n    uint256 public constant DECIMALS = 6;\n\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**\n     * @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n     *         transaction, the current L1 base fee, and the various dynamic parameters.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n     *\n     * @return L1 fee that should be paid for the tx\n     */\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**DECIMALS;\n        uint256 unscaled = l1Fee * scalar();\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    /**\n     * @notice Retrieves the current gas price (base fee).\n     *\n     * @return Current L2 gas price (base fee).\n     */\n    function gasPrice() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current base fee.\n     *\n     * @return Current L2 base fee.\n     */\n    function baseFee() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current fee overhead.\n     *\n     * @return Current fee overhead.\n     */\n    function overhead() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n    }\n\n    /**\n     * @notice Retrieves the current fee scalar.\n     *\n     * @return Current fee scalar.\n     */\n    function scalar() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n    }\n\n    /**\n     * @notice Retrieves the latest known L1 base fee.\n     *\n     * @return Latest known L1 base fee.\n     */\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the number of decimals used in the scalar.\n     *\n     * @return Number of decimals used in the scalar.\n     */\n    function decimals() public pure returns (uint256) {\n        return DECIMALS;\n    }\n\n    /**\n     * @notice Computes the amount of L1 gas used for a transaction. Adds the overhead which\n     *         represents the per-transaction gas overhead of posting the transaction and state\n     *         roots to L1. Adds 68 bytes of padding to account for the fact that the input does\n     *         not have a signature.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n     *\n     * @return Amount of L1 gas used to publish the transaction.\n     */\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        uint256 unsigned = total + overhead();\n        return unsigned + (68 * 16);\n    }\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000015\n * @title L1Block\n * @notice The L1Block predeploy gives users access to information about the last known L1 block.\n *         Values within this contract are updated once per epoch (every L1 block) and can only be\n *         set by the \"depositor\" account, a special system address. Depositor account transactions\n *         are created by the protocol whenever we move to a new epoch.\n */\ncontract L1Block is Semver {\n    /**\n     * @notice Address of the special depositor account.\n     */\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /**\n     * @notice The latest L1 block number known by the L2 system.\n     */\n    uint64 public number;\n\n    /**\n     * @notice The latest L1 timestamp known by the L2 system.\n     */\n    uint64 public timestamp;\n\n    /**\n     * @notice The latest L1 basefee.\n     */\n    uint256 public basefee;\n\n    /**\n     * @notice The latest L1 blockhash.\n     */\n    bytes32 public hash;\n\n    /**\n     * @notice The number of L2 blocks in the same epoch.\n     */\n    uint64 public sequenceNumber;\n\n    /**\n     * @notice The versioned hash to authenticate the batcher by.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice The overhead value applied to the L1 portion of the transaction\n     *         fee.\n     */\n    uint256 public l1FeeOverhead;\n\n    /**\n     * @notice The scalar value applied to the L1 portion of the transaction fee.\n     */\n    uint256 public l1FeeScalar;\n\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**\n     * @notice Updates the L1 block values.\n     *\n     * @param _number         L1 blocknumber.\n     * @param _timestamp      L1 timestamp.\n     * @param _basefee        L1 basefee.\n     * @param _hash           L1 blockhash.\n     * @param _sequenceNumber Number of L2 blocks since epoch start.\n     * @param _batcherHash    Versioned hash to authenticate batcher by.\n     * @param _l1FeeOverhead  L1 fee overhead.\n     * @param _l1FeeScalar    L1 fee scalar.\n     */\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber,\n        bytes32 _batcherHash,\n        uint256 _l1FeeOverhead,\n        uint256 _l1FeeScalar\n    ) external {\n        require(\n            msg.sender == DEPOSITOR_ACCOUNT,\n            \"L1Block: only the depositor account can set L1 block values\"\n        );\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n        batcherHash = _batcherHash;\n        l1FeeOverhead = _l1FeeOverhead;\n        l1FeeScalar = _l1FeeScalar;\n    }\n}\n"
    },
    "contracts/L2/L1FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { FeeVault } from \"../universal/FeeVault.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x420000000000000000000000000000000000001A\n * @title L1FeeVault\n * @notice The L1FeeVault accumulates the L1 portion of the transaction fees.\n */\ncontract L1FeeVault is FeeVault, Semver {\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(1, 1, 0) {}\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @custom:semver 1.4.0\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger)\n        Semver(1, 4, 0)\n        CrossDomainMessenger(_l1CrossDomainMessenger)\n    {\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote messenger. Use otherMessenger going forward.\n     *\n     * @return Address of the L1CrossDomainMessenger contract.\n     */\n    function l1CrossDomainMessenger() public view returns (address) {\n        return OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\n            value: _value\n        }(_to, _gasLimit, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(Predeploys.L2_TO_L1_MESSAGE_PASSER);\n    }\n}\n"
    },
    "contracts/L2/L2ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { IOptimismMintableERC721 } from \"../universal/IOptimismMintableERC721.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title L2ERC721Bridge\n * @notice The L2 ERC721 bridge is a contract which works together with the L1 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Optimism. This contract\n *         acts as a minter for new tokens when it hears about deposits into the L1 ERC721 bridge.\n *         This contract also acts as a burner for tokens being withdrawn.\n *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This\n *         bridge ONLY supports ERC721s originally deployed on Ethereum. Users will need to\n *         wait for the one-week challenge period to elapse before their Optimism-native NFT\n *         can be refunded on L2.\n */\ncontract L2ERC721Bridge is ERC721Bridge, Semver {\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge)\n        Semver(1, 1, 0)\n        ERC721Bridge(_messenger, _otherBridge)\n    {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L1. Data supplied here will not be used to\n     *                     execute any code on L1 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L2ERC721Bridge: local token cannot be self\");\n\n        // Note that supportsInterface makes a callback to the _localToken address which is user\n        // provided.\n        require(\n            ERC165Checker.supportsInterface(_localToken, type(IOptimismMintableERC721).interfaceId),\n            \"L2ERC721Bridge: local token interface is not compliant\"\n        );\n\n        require(\n            _remoteToken == IOptimismMintableERC721(_localToken).remoteToken(),\n            \"L2ERC721Bridge: wrong remote token for Optimism Mintable ERC721 local token\"\n        );\n\n        // When a deposit is finalized, we give the NFT with the same tokenId to the account\n        // on L2. Note that safeMint makes a callback to the _to address which is user provided.\n        IOptimismMintableERC721(_localToken).safeMint(_to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L2ERC721Bridge: remote token cannot be address(0)\");\n\n        // Check that the withdrawal is being initiated by the NFT owner\n        require(\n            _from == IOptimismMintableERC721(_localToken).ownerOf(_tokenId),\n            \"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\"\n        );\n\n        // Construct calldata for l1ERC721Bridge.finalizeBridgeERC721(_to, _tokenId)\n        // slither-disable-next-line reentrancy-events\n        address remoteToken = IOptimismMintableERC721(_localToken).remoteToken();\n        require(\n            remoteToken == _remoteToken,\n            \"L2ERC721Bridge: remote token does not match given value\"\n        );\n\n        // When a withdrawal is initiated, we burn the withdrawer's NFT to prevent subsequent L2\n        // usage\n        // slither-disable-next-line reentrancy-events\n        IOptimismMintableERC721(_localToken).burn(_from, _tokenId);\n\n        bytes memory message = abi.encodeWithSelector(\n            L1ERC721Bridge.finalizeBridgeERC721.selector,\n            remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Send message to L1 bridge\n        // slither-disable-next-line reentrancy-events\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeInitiated(_localToken, remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000010\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L2, it will be escrowed within this\n *         contract. If the ERC20 token is native to L1, it will be burnt.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L2StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal from L2 to L1 is initiated.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of the ERC20 withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event WithdrawalInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is finalized.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of the ERC20 deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    constructor(address payable _otherBridge)\n        Semver(1, 1, 0)\n        StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge)\n    {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateWithdrawal(\n            Predeploys.LEGACY_ERC20_ETH,\n            msg.sender,\n            msg.sender,\n            msg.value,\n            RECEIVE_DEFAULT_GAS_LIMIT,\n            bytes(\"\")\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1.\n     *         This function only works with OptimismMintableERC20 tokens or ether. Use the\n     *         `bridgeERC20` function to bridge native L2 tokens to L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable virtual onlyEOA {\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1 to a target account on L1.\n     *         Note that if ETH is sent to a contract on L1 and the call fails, then that ETH will\n     *         be locked in the L1StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *         This function only works with OptimismMintableERC20 tokens or ether. Use the\n     *         `bridgeERC20To` function to bridge native L2 tokens to L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a deposit from L1 to L2. To finalize a deposit of ether, use address(0)\n     *         and the l1Token and the Legacy ERC20 ether predeploy address as the l2Token.\n     *\n     * @param _l1Token   Address of the L1 token to deposit.\n     * @param _l2Token   Address of the corresponding L2 token.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient.\n     * @param _amount    Amount of the tokens being deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable virtual {\n        if (_l1Token == address(0) && _l2Token == Predeploys.LEGACY_ERC20_ETH) {\n            finalizeBridgeETH(_from, _to, _amount, _extraData);\n        } else {\n            finalizeBridgeERC20(_l2Token, _l1Token, _from, _to, _amount, _extraData);\n        }\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the access of the corresponding L1 bridge contract.\n     *\n     * @return Address of the corresponding L1 bridge contract.\n     */\n    function l1TokenBridge() external view returns (address) {\n        return address(OTHER_BRIDGE);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Internal function to a withdrawal from L2 to L1 to a target account on L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _from        Address of the withdrawer.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        if (_l2Token == Predeploys.LEGACY_ERC20_ETH) {\n            _initiateBridgeETH(_from, _to, _amount, _minGasLimit, _extraData);\n        } else {\n            address l1Token = OptimismMintableERC20(_l2Token).l1Token();\n            _initiateBridgeERC20(_l2Token, l1Token, _from, _to, _amount, _minGasLimit, _extraData);\n        }\n    }\n\n    /**\n     * @notice Emits the legacy WithdrawalInitiated event followed by the ETHBridgeInitiated event.\n     *         This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitETHBridgeInitiated(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit WithdrawalInitiated(\n            address(0),\n            Predeploys.LEGACY_ERC20_ETH,\n            _from,\n            _to,\n            _amount,\n            _extraData\n        );\n        super._emitETHBridgeInitiated(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy DepositFinalized event followed by the ETHBridgeFinalized event.\n     *         This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitETHBridgeFinalized(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit DepositFinalized(\n            address(0),\n            Predeploys.LEGACY_ERC20_ETH,\n            _from,\n            _to,\n            _amount,\n            _extraData\n        );\n        super._emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy WithdrawalInitiated event followed by the ERC20BridgeInitiated\n     *         event. This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitERC20BridgeInitiated(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit WithdrawalInitiated(_remoteToken, _localToken, _from, _to, _amount, _extraData);\n        super._emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the legacy DepositFinalized event followed by the ERC20BridgeFinalized event.\n     *         This is necessary for backwards compatibility with the legacy bridge.\n     *\n     * @inheritdoc StandardBridge\n     */\n    function _emitERC20BridgeFinalized(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal override {\n        emit DepositFinalized(_remoteToken, _localToken, _from, _to, _amount, _extraData);\n        super._emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000016\n * @title L2ToL1MessagePasser\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\n */\ncontract L2ToL1MessagePasser is Semver {\n    /**\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\n     */\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     *\n     * @param nonce          Unique value corresponding to each withdrawal.\n     * @param sender         The L2 account address which initiated the withdrawal.\n     * @param target         The L1 account address the call will be send to.\n     * @param value          The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit       The minimum amount of gas that must be provided when withdrawing.\n     * @param data           The data to be forwarded to the target on L1.\n     * @param withdrawalHash The hash of the withdrawal.\n     */\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     *\n     * @param amount Amount of ETh that was burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**\n     * @notice Allows users to withdraw ETH by sending directly to this contract.\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Removes all ETH held by this contract from the state. Used to prevent the amount of\n     *         ETH on L2 inflating when ETH is withdrawn. Currently only way to do this is to\n     *         create a contract and self-destruct it to itself. Anyone can call this function. Not\n     *         incentivized since this function is very cheap.\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        Burn.eth(balance);\n        emit WithdrawerBalanceBurnt(balance);\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _target   Address to call on L1 execution.\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\n     * @param _data     Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: messageNonce(),\n                sender: msg.sender,\n                target: _target,\n                value: msg.value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit MessagePassed(\n            messageNonce(),\n            msg.sender,\n            _target,\n            msg.value,\n            _gasLimit,\n            _data,\n            withdrawalHash\n        );\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n}\n"
    },
    "contracts/L2/SequencerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { FeeVault } from \"../universal/FeeVault.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000011\n * @title SequencerFeeVault\n * @notice The SequencerFeeVault is the contract that holds any fees paid to the Sequencer during\n *         transaction processing and block production.\n */\ncontract SequencerFeeVault is FeeVault, Semver {\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(1, 1, 0) {}\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the recipient address.\n     *\n     * @return The recipient address.\n     */\n    function l1FeeWallet() public view returns (address) {\n        return RECIPIENT;\n    }\n}\n"
    },
    "contracts/deployment/PortalSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\n\n/**\n * @title PortalSender\n * @notice The PortalSender is a simple intermediate contract that will transfer the balance of the\n *         L1StandardBridge to the OptimismPortal during the Bedrock migration.\n */\ncontract PortalSender {\n    /**\n     * @notice Address of the OptimismPortal contract.\n     */\n    OptimismPortal public immutable PORTAL;\n\n    /**\n     * @param _portal Address of the OptimismPortal contract.\n     */\n    constructor(OptimismPortal _portal) {\n        PORTAL = _portal;\n    }\n\n    /**\n     * @notice Sends balance of this contract to the OptimismPortal.\n     */\n    function donate() public {\n        PORTAL.donateETH{ value: address(this).balance }();\n    }\n}\n"
    },
    "contracts/deployment/SystemDictator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { OptimismMintableERC20Factory } from \"../universal/OptimismMintableERC20Factory.sol\";\nimport { PortalSender } from \"./PortalSender.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @title SystemDictator\n * @notice The SystemDictator is responsible for coordinating the deployment of a full Bedrock\n *         system. The SystemDictator is designed to support both fresh network deployments and\n *         upgrades to existing pre-Bedrock systems.\n */\ncontract SystemDictator is OwnableUpgradeable {\n    /**\n     * @notice Basic system configuration.\n     */\n    struct GlobalConfig {\n        AddressManager addressManager;\n        ProxyAdmin proxyAdmin;\n        address controller;\n        address finalOwner;\n    }\n\n    /**\n     * @notice Set of proxy addresses.\n     */\n    struct ProxyAddressConfig {\n        address l2OutputOracleProxy;\n        address optimismPortalProxy;\n        address l1CrossDomainMessengerProxy;\n        address l1StandardBridgeProxy;\n        address optimismMintableERC20FactoryProxy;\n        address l1ERC721BridgeProxy;\n        address systemConfigProxy;\n    }\n\n    /**\n     * @notice Set of implementation addresses.\n     */\n    struct ImplementationAddressConfig {\n        L2OutputOracle l2OutputOracleImpl;\n        OptimismPortal optimismPortalImpl;\n        L1CrossDomainMessenger l1CrossDomainMessengerImpl;\n        L1StandardBridge l1StandardBridgeImpl;\n        OptimismMintableERC20Factory optimismMintableERC20FactoryImpl;\n        L1ERC721Bridge l1ERC721BridgeImpl;\n        PortalSender portalSenderImpl;\n        SystemConfig systemConfigImpl;\n    }\n\n    /**\n     * @notice Dynamic L2OutputOracle config.\n     */\n    struct L2OutputOracleDynamicConfig {\n        uint256 l2OutputOracleStartingBlockNumber;\n        uint256 l2OutputOracleStartingTimestamp;\n    }\n\n    /**\n     * @notice Values for the system config contract.\n     */\n    struct SystemConfigConfig {\n        address owner;\n        uint256 overhead;\n        uint256 scalar;\n        bytes32 batcherHash;\n        uint64 gasLimit;\n        address unsafeBlockSigner;\n        ResourceMetering.ResourceConfig resourceConfig;\n    }\n\n    /**\n     * @notice Combined system configuration.\n     */\n    struct DeployConfig {\n        GlobalConfig globalConfig;\n        ProxyAddressConfig proxyAddressConfig;\n        ImplementationAddressConfig implementationAddressConfig;\n        SystemConfigConfig systemConfigConfig;\n    }\n\n    /**\n     * @notice Step after which exit 1 can no longer be used.\n     */\n    uint8 public constant EXIT_1_NO_RETURN_STEP = 3;\n\n    /**\n     * @notice Step where proxy ownership is transferred.\n     */\n    uint8 public constant PROXY_TRANSFER_STEP = 4;\n\n    /**\n     * @notice System configuration.\n     */\n    DeployConfig public config;\n\n    /**\n     * @notice Dynamic configuration for the L2OutputOracle.\n     */\n    L2OutputOracleDynamicConfig public l2OutputOracleDynamicConfig;\n\n    /**\n     * @notice Dynamic configuration for the OptimismPortal. Determines\n     *         if the system should be paused when initialized.\n     */\n    bool public optimismPortalDynamicConfig;\n\n    /**\n     * @notice Current step;\n     */\n    uint8 public currentStep;\n\n    /**\n     * @notice Whether or not dynamic config has been set.\n     */\n    bool public dynamicConfigSet;\n\n    /**\n     * @notice Whether or not the deployment is finalized.\n     */\n    bool public finalized;\n\n    /**\n     * @notice Whether or not the deployment has been exited.\n     */\n    bool public exited;\n\n    /**\n     * @notice Address of the old L1CrossDomainMessenger implementation.\n     */\n    address public oldL1CrossDomainMessenger;\n\n    /**\n     * @notice Checks that the current step is the expected step, then bumps the current step.\n     *\n     * @param _step Current step.\n     */\n    modifier step(uint8 _step) {\n        require(!finalized, \"SystemDictator: already finalized\");\n        require(!exited, \"SystemDictator: already exited\");\n        require(currentStep == _step, \"SystemDictator: incorrect step\");\n        _;\n        currentStep++;\n    }\n\n    /**\n     * @notice Constructor required to ensure that the implementation of the SystemDictator is\n     *         initialized upon deployment.\n     */\n    constructor() {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        // Using this shorter variable as an alias for address(0) just prevents us from having to\n        // to use a new line for every single parameter.\n        address zero = address(0);\n        initialize(\n            DeployConfig(\n                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero),\n                ProxyAddressConfig(zero, zero, zero, zero, zero, zero, zero),\n                ImplementationAddressConfig(\n                    L2OutputOracle(zero),\n                    OptimismPortal(payable(zero)),\n                    L1CrossDomainMessenger(zero),\n                    L1StandardBridge(payable(zero)),\n                    OptimismMintableERC20Factory(zero),\n                    L1ERC721Bridge(zero),\n                    PortalSender(zero),\n                    SystemConfig(zero)\n                ),\n                SystemConfigConfig(zero, 0, 0, bytes32(0), 0, zero, rcfg)\n            )\n        );\n    }\n\n    /**\n     * @param _config System configuration.\n     */\n    function initialize(DeployConfig memory _config) public initializer {\n        config = _config;\n        currentStep = 1;\n        __Ownable_init();\n        _transferOwnership(config.globalConfig.controller);\n    }\n\n    /**\n     * @notice Allows the owner to update dynamic config.\n     *\n     * @param _l2OutputOracleDynamicConfig Dynamic L2OutputOracle config.\n     * @param _optimismPortalDynamicConfig Dynamic OptimismPortal config.\n     */\n    function updateDynamicConfig(\n        L2OutputOracleDynamicConfig memory _l2OutputOracleDynamicConfig,\n        bool _optimismPortalDynamicConfig\n    ) external onlyOwner {\n        l2OutputOracleDynamicConfig = _l2OutputOracleDynamicConfig;\n        optimismPortalDynamicConfig = _optimismPortalDynamicConfig;\n        dynamicConfigSet = true;\n    }\n\n    /**\n     * @notice Configures the ProxyAdmin contract.\n     */\n    function step1() public onlyOwner step(1) {\n        // Set the AddressManager in the ProxyAdmin.\n        config.globalConfig.proxyAdmin.setAddressManager(config.globalConfig.addressManager);\n\n        // Set the L1CrossDomainMessenger to the RESOLVED proxy type.\n        config.globalConfig.proxyAdmin.setProxyType(\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\n            ProxyAdmin.ProxyType.RESOLVED\n        );\n\n        // Set the implementation name for the L1CrossDomainMessenger.\n        config.globalConfig.proxyAdmin.setImplementationName(\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\n            \"OVM_L1CrossDomainMessenger\"\n        );\n\n        // Set the L1StandardBridge to the CHUGSPLASH proxy type.\n        config.globalConfig.proxyAdmin.setProxyType(\n            config.proxyAddressConfig.l1StandardBridgeProxy,\n            ProxyAdmin.ProxyType.CHUGSPLASH\n        );\n\n        // Upgrade and initialize the SystemConfig so the Sequencer can start up.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.systemConfigProxy),\n            address(config.implementationAddressConfig.systemConfigImpl),\n            abi.encodeCall(\n                SystemConfig.initialize,\n                (\n                    config.systemConfigConfig.owner,\n                    config.systemConfigConfig.overhead,\n                    config.systemConfigConfig.scalar,\n                    config.systemConfigConfig.batcherHash,\n                    config.systemConfigConfig.gasLimit,\n                    config.systemConfigConfig.unsafeBlockSigner,\n                    config.systemConfigConfig.resourceConfig\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Pauses the system by shutting down the L1CrossDomainMessenger and setting the\n     *         deposit halt flag to tell the Sequencer's DTL to stop accepting deposits.\n     */\n    function step2() public onlyOwner step(2) {\n        // Store the address of the old L1CrossDomainMessenger implementation. We will need this\n        // address in the case that we have to exit early.\n        oldL1CrossDomainMessenger = config.globalConfig.addressManager.getAddress(\n            \"OVM_L1CrossDomainMessenger\"\n        );\n\n        // Temporarily brick the L1CrossDomainMessenger by setting its implementation address to\n        // address(0) which will cause the ResolvedDelegateProxy to revert. Better than pausing\n        // the L1CrossDomainMessenger via pause() because it can be easily reverted.\n        config.globalConfig.addressManager.setAddress(\"OVM_L1CrossDomainMessenger\", address(0));\n\n        // Set the DTL shutoff block, which will tell the DTL to stop syncing new deposits from the\n        // CanonicalTransactionChain. We do this by setting an address in the AddressManager\n        // because the DTL already has a reference to the AddressManager and this way we don't also\n        // need to give it a reference to the SystemDictator.\n        config.globalConfig.addressManager.setAddress(\n            \"DTL_SHUTOFF_BLOCK\",\n            address(uint160(block.number))\n        );\n    }\n\n    /**\n     * @notice Removes deprecated addresses from the AddressManager.\n     */\n    function step3() public onlyOwner step(EXIT_1_NO_RETURN_STEP) {\n        // Remove all deprecated addresses from the AddressManager\n        string[17] memory deprecated = [\n            \"OVM_CanonicalTransactionChain\",\n            \"OVM_L2CrossDomainMessenger\",\n            \"OVM_DecompressionPrecompileAddress\",\n            \"OVM_Sequencer\",\n            \"OVM_Proposer\",\n            \"OVM_ChainStorageContainer-CTC-batches\",\n            \"OVM_ChainStorageContainer-CTC-queue\",\n            \"OVM_CanonicalTransactionChain\",\n            \"OVM_StateCommitmentChain\",\n            \"OVM_BondManager\",\n            \"OVM_ExecutionManager\",\n            \"OVM_FraudVerifier\",\n            \"OVM_StateManagerFactory\",\n            \"OVM_StateTransitionerFactory\",\n            \"OVM_SafetyChecker\",\n            \"OVM_L1MultiMessageRelayer\",\n            \"BondManager\"\n        ];\n\n        for (uint256 i = 0; i < deprecated.length; i++) {\n            config.globalConfig.addressManager.setAddress(deprecated[i], address(0));\n        }\n    }\n\n    /**\n     * @notice Transfers system ownership to the ProxyAdmin.\n     */\n    function step4() public onlyOwner step(PROXY_TRANSFER_STEP) {\n        // Transfer ownership of the AddressManager to the ProxyAdmin.\n        config.globalConfig.addressManager.transferOwnership(\n            address(config.globalConfig.proxyAdmin)\n        );\n\n        // Transfer ownership of the L1StandardBridge to the ProxyAdmin.\n        L1ChugSplashProxy(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).setOwner(\n            address(config.globalConfig.proxyAdmin)\n        );\n\n        // Transfer ownership of the L1ERC721Bridge to the ProxyAdmin.\n        Proxy(payable(config.proxyAddressConfig.l1ERC721BridgeProxy)).changeAdmin(\n            address(config.globalConfig.proxyAdmin)\n        );\n    }\n\n    /**\n     * @notice Upgrades and initializes proxy contracts.\n     */\n    function step5() public onlyOwner step(5) {\n        // Dynamic config must be set before we can initialize the L2OutputOracle.\n        require(dynamicConfigSet, \"SystemDictator: dynamic oracle config is not yet initialized\");\n\n        // Upgrade and initialize the L2OutputOracle.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.l2OutputOracleProxy),\n            address(config.implementationAddressConfig.l2OutputOracleImpl),\n            abi.encodeCall(\n                L2OutputOracle.initialize,\n                (\n                    l2OutputOracleDynamicConfig.l2OutputOracleStartingBlockNumber,\n                    l2OutputOracleDynamicConfig.l2OutputOracleStartingTimestamp\n                )\n            )\n        );\n\n        // Upgrade and initialize the OptimismPortal.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.optimismPortalProxy),\n            address(config.implementationAddressConfig.optimismPortalImpl),\n            abi.encodeCall(OptimismPortal.initialize, (optimismPortalDynamicConfig))\n        );\n\n        // Upgrade the L1CrossDomainMessenger.\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.l1CrossDomainMessengerProxy),\n            address(config.implementationAddressConfig.l1CrossDomainMessengerImpl)\n        );\n\n        // Try to initialize the L1CrossDomainMessenger, only fail if it's already been initialized.\n        try\n            L1CrossDomainMessenger(config.proxyAddressConfig.l1CrossDomainMessengerProxy)\n                .initialize()\n        {\n            // L1CrossDomainMessenger is the one annoying edge case difference between existing\n            // networks and fresh networks because in existing networks it'll already be\n            // initialized but in fresh networks it won't be. Try/catch is the easiest and most\n            // consistent way to handle this because initialized() is not exposed publicly.\n        } catch Error(string memory reason) {\n            require(\n                keccak256(abi.encodePacked(reason)) ==\n                    keccak256(\"Initializable: contract is already initialized\"),\n                string.concat(\"SystemDictator: unexpected error initializing L1XDM: \", reason)\n            );\n        } catch {\n            revert(\"SystemDictator: unexpected error initializing L1XDM (no reason)\");\n        }\n\n        // Transfer ETH from the L1StandardBridge to the OptimismPortal.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.l1StandardBridgeProxy),\n            address(config.implementationAddressConfig.portalSenderImpl),\n            abi.encodeCall(PortalSender.donate, ())\n        );\n\n        // Upgrade the L1StandardBridge (no initializer).\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.l1StandardBridgeProxy),\n            address(config.implementationAddressConfig.l1StandardBridgeImpl)\n        );\n\n        // Upgrade the OptimismMintableERC20Factory (no initializer).\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.optimismMintableERC20FactoryProxy),\n            address(config.implementationAddressConfig.optimismMintableERC20FactoryImpl)\n        );\n\n        // Upgrade the L1ERC721Bridge (no initializer).\n        config.globalConfig.proxyAdmin.upgrade(\n            payable(config.proxyAddressConfig.l1ERC721BridgeProxy),\n            address(config.implementationAddressConfig.l1ERC721BridgeImpl)\n        );\n    }\n\n    /**\n     * @notice Calls the first 2 steps of the migration process.\n     */\n    function phase1() external onlyOwner {\n        step1();\n        step2();\n    }\n\n    /**\n     * @notice Calls the remaining steps of the migration process, and finalizes.\n     */\n    function phase2() external onlyOwner {\n        step3();\n        step4();\n        step5();\n        finalize();\n    }\n\n    /**\n     * @notice Tranfers admin ownership to the final owner.\n     */\n    function finalize() public onlyOwner {\n        // Transfer ownership of the ProxyAdmin to the final owner.\n        config.globalConfig.proxyAdmin.transferOwnership(config.globalConfig.finalOwner);\n\n        // Optionally also transfer AddressManager and L1StandardBridge if we still own it. Might\n        // happen if we're exiting early.\n        if (currentStep <= PROXY_TRANSFER_STEP) {\n            // Transfer ownership of the AddressManager to the final owner.\n            config.globalConfig.addressManager.transferOwnership(\n                address(config.globalConfig.finalOwner)\n            );\n\n            // Transfer ownership of the L1StandardBridge to the final owner.\n            L1ChugSplashProxy(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).setOwner(\n                address(config.globalConfig.finalOwner)\n            );\n\n            // Transfer ownership of the L1ERC721Bridge to the final owner.\n            Proxy(payable(config.proxyAddressConfig.l1ERC721BridgeProxy)).changeAdmin(\n                address(config.globalConfig.finalOwner)\n            );\n        }\n\n        // Mark the deployment as finalized.\n        finalized = true;\n    }\n\n    /**\n     * @notice First exit point, can only be called before step 3 is executed.\n     */\n    function exit1() external onlyOwner {\n        require(\n            currentStep == EXIT_1_NO_RETURN_STEP,\n            \"SystemDictator: can only exit1 before step 3 is executed\"\n        );\n\n        // Reset the L1CrossDomainMessenger to the old implementation.\n        config.globalConfig.addressManager.setAddress(\n            \"OVM_L1CrossDomainMessenger\",\n            oldL1CrossDomainMessenger\n        );\n\n        // Unset the DTL shutoff block which will allow the DTL to sync again.\n        config.globalConfig.addressManager.setAddress(\"DTL_SHUTOFF_BLOCK\", address(0));\n\n        // Mark the deployment as exited.\n        exited = true;\n    }\n}\n"
    },
    "contracts/dispute/BondManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { GameType } from \"../libraries/DisputeTypes.sol\";\nimport { GameStatus } from \"../libraries/DisputeTypes.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\nimport { IDisputeGame } from \"./IDisputeGame.sol\";\nimport { IDisputeGameFactory } from \"./IDisputeGameFactory.sol\";\n\n/**\n * @title BondManager\n * @notice The Bond Manager serves as an escrow for permissionless output proposal bonds.\n */\ncontract BondManager {\n    /**\n     * @notice The Bond Type\n     */\n    struct Bond {\n        address owner;\n        uint256 expiration;\n        bytes32 id;\n        uint256 amount;\n    }\n\n    /**\n     * @notice Mapping from bondId to bond.\n     */\n    mapping(bytes32 => Bond) public bonds;\n\n    /**\n     * @notice BondPosted is emitted when a bond is posted.\n     * @param bondId is the id of the bond.\n     * @param owner is the address that owns the bond.\n     * @param expiration is the time at which the bond expires.\n     * @param amount is the amount of the bond.\n     */\n    event BondPosted(bytes32 bondId, address owner, uint256 expiration, uint256 amount);\n\n    /**\n     * @notice BondSeized is emitted when a bond is seized.\n     * @param bondId is the id of the bond.\n     * @param owner is the address that owns the bond.\n     * @param seizer is the address that seized the bond.\n     * @param amount is the amount of the bond.\n     */\n    event BondSeized(bytes32 bondId, address owner, address seizer, uint256 amount);\n\n    /**\n     * @notice BondReclaimed is emitted when a bond is reclaimed by the owner.\n     * @param bondId is the id of the bond.\n     * @param claiment is the address that reclaimed the bond.\n     * @param amount is the amount of the bond.\n     */\n    event BondReclaimed(bytes32 bondId, address claiment, uint256 amount);\n\n    /**\n     * @notice The permissioned dispute game factory.\n     * @dev Used to verify the status of bonds.\n     */\n    IDisputeGameFactory public immutable DISPUTE_GAME_FACTORY;\n\n    /**\n     * @notice Amount of gas used to transfer ether when splitting the bond.\n     *         This is a reasonable amount of gas for a transfer, even to a smart contract.\n     *         The number of participants is bound of by the block gas limit.\n     */\n    uint256 private constant TRANSFER_GAS = 30_000;\n\n    /**\n     * @notice Instantiates the bond maanger with the registered dispute game factory.\n     * @param _disputeGameFactory is the dispute game factory.\n     */\n    constructor(IDisputeGameFactory _disputeGameFactory) {\n        DISPUTE_GAME_FACTORY = _disputeGameFactory;\n    }\n\n    /**\n     * @notice Post a bond with a given id and owner.\n     * @dev This function will revert if the provided bondId is already in use.\n     * @param _bondId is the id of the bond.\n     * @param _bondOwner is the address that owns the bond.\n     * @param _minClaimHold is the minimum amount of time the owner\n     *        must wait before reclaiming their bond.\n     */\n    function post(\n        bytes32 _bondId,\n        address _bondOwner,\n        uint256 _minClaimHold\n    ) external payable {\n        require(bonds[_bondId].owner == address(0), \"BondManager: BondId already posted.\");\n        require(_bondOwner != address(0), \"BondManager: Owner cannot be the zero address.\");\n        require(msg.value > 0, \"BondManager: Value must be non-zero.\");\n\n        uint256 expiration = _minClaimHold + block.timestamp;\n        bonds[_bondId] = Bond({\n            owner: _bondOwner,\n            expiration: expiration,\n            id: _bondId,\n            amount: msg.value\n        });\n\n        emit BondPosted(_bondId, _bondOwner, expiration, msg.value);\n    }\n\n    /**\n     * @notice Seizes the bond with the given id.\n     * @dev This function will revert if there is no bond at the given id.\n     * @param _bondId is the id of the bond.\n     */\n    function seize(bytes32 _bondId) external {\n        Bond memory b = bonds[_bondId];\n        require(b.owner != address(0), \"BondManager: The bond does not exist.\");\n        require(b.expiration >= block.timestamp, \"BondManager: Bond expired.\");\n\n        IDisputeGame caller = IDisputeGame(msg.sender);\n        IDisputeGame game = DISPUTE_GAME_FACTORY.games(\n            GameType.ATTESTATION,\n            caller.rootClaim(),\n            caller.extraData()\n        );\n        require(msg.sender == address(game), \"BondManager: Unauthorized seizure.\");\n        require(game.status() == GameStatus.CHALLENGER_WINS, \"BondManager: Game incomplete.\");\n\n        delete bonds[_bondId];\n\n        emit BondSeized(_bondId, b.owner, msg.sender, b.amount);\n\n        bool success = SafeCall.send(payable(msg.sender), gasleft(), b.amount);\n        require(success, \"BondManager: Failed to send Ether.\");\n    }\n\n    /**\n     * @notice Seizes the bond with the given id and distributes it to recipients.\n     * @dev This function will revert if there is no bond at the given id.\n     * @param _bondId is the id of the bond.\n     * @param _claimRecipients is a set of addresses to split the bond amongst.\n     */\n    function seizeAndSplit(bytes32 _bondId, address[] calldata _claimRecipients) external {\n        Bond memory b = bonds[_bondId];\n        require(b.owner != address(0), \"BondManager: The bond does not exist.\");\n        require(b.expiration >= block.timestamp, \"BondManager: Bond expired.\");\n\n        IDisputeGame caller = IDisputeGame(msg.sender);\n        IDisputeGame game = DISPUTE_GAME_FACTORY.games(\n            GameType.ATTESTATION,\n            caller.rootClaim(),\n            caller.extraData()\n        );\n        require(msg.sender == address(game), \"BondManager: Unauthorized seizure.\");\n        require(game.status() == GameStatus.CHALLENGER_WINS, \"BondManager: Game incomplete.\");\n\n        delete bonds[_bondId];\n\n        emit BondSeized(_bondId, b.owner, msg.sender, b.amount);\n\n        uint256 len = _claimRecipients.length;\n        uint256 proportionalAmount = b.amount / len;\n        // Send the proportional amount to each recipient. Do not revert if a send fails as that\n        // will prevent other recipients from receiving their share.\n        for (uint256 i; i < len; i++) {\n            SafeCall.send({\n                _target: payable(_claimRecipients[i]),\n                _gas: TRANSFER_GAS,\n                _value: proportionalAmount\n            });\n        }\n    }\n\n    /**\n     * @notice Reclaims the bond of the bond owner.\n     * @dev This function will revert if there is no bond at the given id.\n     * @param _bondId is the id of the bond.\n     */\n    function reclaim(bytes32 _bondId) external {\n        Bond memory b = bonds[_bondId];\n        require(b.owner == msg.sender, \"BondManager: Unauthorized claimant.\");\n        require(b.expiration <= block.timestamp, \"BondManager: Bond isn't claimable yet.\");\n\n        delete bonds[_bondId];\n\n        emit BondReclaimed(_bondId, msg.sender, b.amount);\n\n        bool success = SafeCall.send(payable(msg.sender), gasleft(), b.amount);\n        require(success, \"BondManager: Failed to send Ether.\");\n    }\n}\n"
    },
    "contracts/dispute/DisputeGameFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ClonesWithImmutableArgs } from \"@cwia/ClonesWithImmutableArgs.sol\";\n\nimport { Claim } from \"../libraries/DisputeTypes.sol\";\nimport { Hash } from \"../libraries/DisputeTypes.sol\";\nimport { GameType } from \"../libraries/DisputeTypes.sol\";\n\nimport { NoImplementation } from \"../libraries/DisputeErrors.sol\";\nimport { GameAlreadyExists } from \"../libraries/DisputeErrors.sol\";\n\nimport { IDisputeGame } from \"./IDisputeGame.sol\";\nimport { IDisputeGameFactory } from \"./IDisputeGameFactory.sol\";\n\n/**\n * @title DisputeGameFactory\n * @notice A factory contract for creating `IDisputeGame` contracts.\n */\ncontract DisputeGameFactory is Ownable, IDisputeGameFactory {\n    /**\n     * @dev Allows for the creation of clone proxies with immutable arguments.\n     */\n    using ClonesWithImmutableArgs for address;\n\n    /**\n     * @notice Mapping of `GameType`s to their respective `IDisputeGame` implementations.\n     */\n    mapping(GameType => IDisputeGame) public gameImpls;\n\n    /**\n     * @notice Mapping of a hash of `gameType . rootClaim . extraData` to\n     *         the deployed `IDisputeGame` clone.\n     * @dev Note: `.` denotes concatenation.\n     */\n    mapping(Hash => IDisputeGame) internal disputeGames;\n\n    /**\n     * @notice Constructs a new DisputeGameFactory contract.\n     * @param _owner The owner of the contract.\n     */\n    constructor(address _owner) Ownable() {\n        transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Retrieves the hash of `gameType . rootClaim . extraData`\n     *         to the deployed `DisputeGame` clone.\n     * @dev Note: `.` denotes concatenation.\n     * @param gameType The type of the DisputeGame.\n     *        Used to decide the implementation to clone.\n     * @param rootClaim The root claim of the DisputeGame.\n     * @param extraData Any extra data that should be provided to the\n     *        created dispute game.\n     * @return _proxy The clone of the `DisputeGame` created with the\n     *         given parameters. `address(0)` if nonexistent.\n     */\n    function games(\n        GameType gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) external view returns (IDisputeGame _proxy) {\n        return disputeGames[getGameUUID(gameType, rootClaim, extraData)];\n    }\n\n    /**\n     * @notice Creates a new DisputeGame proxy contract.\n     * @notice If a dispute game with the given parameters already exists,\n     *         it will be returned.\n     * @param gameType The type of the DisputeGame.\n     *        Used to decide the proxy implementation.\n     * @param rootClaim The root claim of the DisputeGame.\n     * @param extraData Any extra data that should be provided\n     *        to the created dispute game.\n     * @return proxy The clone of the `DisputeGame`.\n     */\n    function create(\n        GameType gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) external returns (IDisputeGame proxy) {\n        // Grab the implementation contract for the given `GameType`.\n        IDisputeGame impl = gameImpls[gameType];\n\n        // If there is no implementation to clone for the given `GameType`, revert.\n        if (address(impl) == address(0)) {\n            revert NoImplementation(gameType);\n        }\n\n        // Clone the implementation contract and initialize it with the given parameters.\n        bytes memory data = abi.encodePacked(rootClaim, extraData);\n        proxy = IDisputeGame(address(impl).clone(data));\n        proxy.initialize();\n\n        // Compute the unique identifier for the dispute game.\n        Hash uuid = getGameUUID(gameType, rootClaim, extraData);\n\n        // If a dispute game with the same UUID already exists, revert.\n        if (address(disputeGames[uuid]) != address(0)) {\n            revert GameAlreadyExists(uuid);\n        }\n\n        // Store the dispute game in the mapping & emit the `DisputeGameCreated` event.\n        disputeGames[uuid] = proxy;\n        emit DisputeGameCreated(address(proxy), gameType, rootClaim);\n    }\n\n    /**\n     * @notice Sets the implementation contract for a specific `GameType`.\n     * @param gameType The type of the DisputeGame.\n     * @param impl The implementation contract for the given `GameType`.\n     */\n    function setImplementation(GameType gameType, IDisputeGame impl) external onlyOwner {\n        gameImpls[gameType] = impl;\n        emit ImplementationSet(address(impl), gameType);\n    }\n\n    /**\n     * @notice Returns a unique identifier for the given dispute game parameters.\n     * @dev Hashes the concatenation of `gameType . rootClaim . extraData`\n     *      without expanding memory.\n     * @param gameType The type of the DisputeGame.\n     * @param rootClaim The root claim of the DisputeGame.\n     * @param extraData Any extra data that should be provided to the created dispute game.\n     * @return _uuid The unique identifier for the given dispute game parameters.\n     */\n    function getGameUUID(\n        GameType gameType,\n        Claim rootClaim,\n        bytes memory extraData\n    ) public pure returns (Hash _uuid) {\n        assembly {\n            // Grab the offsets of the other memory locations we will need to temporarily overwrite.\n            let gameTypeOffset := sub(extraData, 0x60)\n            let rootClaimOffset := add(gameTypeOffset, 0x20)\n            let pointerOffset := add(rootClaimOffset, 0x20)\n\n            // Copy the memory that we will temporarily overwrite onto the stack\n            // so we can restore it later\n            let tempA := mload(gameTypeOffset)\n            let tempB := mload(rootClaimOffset)\n            let tempC := mload(pointerOffset)\n\n            // Overwrite the memory with the data we want to hash\n            mstore(gameTypeOffset, gameType)\n            mstore(rootClaimOffset, rootClaim)\n            mstore(pointerOffset, 0x60)\n\n            // Compute the length of the memory to hash\n            // `0x60 + 0x20 + extraData.length` rounded to the *next* multiple of 32.\n            let hashLen := and(add(mload(extraData), 0x9F), not(0x1F))\n\n            // Hash the memory to produce the UUID digest\n            _uuid := keccak256(gameTypeOffset, hashLen)\n\n            // Restore the memory prior to `extraData`\n            mstore(gameTypeOffset, tempA)\n            mstore(rootClaimOffset, tempB)\n            mstore(pointerOffset, tempC)\n        }\n    }\n}\n"
    },
    "contracts/dispute/IAttestationDisputeGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { IDisputeGame } from \"./IDisputeGame.sol\";\n\n/**\n * @title IAttestationDisputeGame\n * @notice The interface for an attestation-based DisputeGame meant to contest output\n *         proposals in Optimism's `L2OutputOracle` contract.\n */\ninterface IAttestationDisputeGame is IDisputeGame {\n    /**\n     * @notice A mapping of addresses from the `signerSet` to booleans signifying whether\n     *         or not they have authorized the `rootClaim` to be invalidated.\n     * @param challenger The address to check for authorization.\n     * @return _challenged Whether or not the `challenger` has challenged the `rootClaim`.\n     */\n    function challenges(address challenger) external view returns (bool _challenged);\n\n    /**\n     * @notice The signer set consists of authorized public keys that may challenge\n     *         the `rootClaim`.\n     * @param addr The address to check for authorization.\n     * @return _isAuthorized Whether or not the `addr` is part of the signer set.\n     */\n    function signerSet(address addr) external view returns (bool _isAuthorized);\n\n    /**\n     * @notice The amount of signatures required to successfully challenge the `rootClaim`\n     *         output proposal. Once this threshold is met by members of the `signerSet`\n     *         calling `challenge`, the game will be resolved to `CHALLENGER_WINS`.\n     * @custom:invariant The `signatureThreshold` may never be greater than the length\n     *                   of the `signerSet`.\n     * @return _signatureThreshold The amount of signatures required to successfully\n     *         challenge the `rootClaim` output proposal.\n     */\n    function frozenSignatureThreshold() external view returns (uint256 _signatureThreshold);\n\n    /**\n     * @notice Returns the L2 Block Number that the `rootClaim` commits to.\n     *         Exists within the `extraData`.\n     * @return _l2BlockNumber The L2 Block Number that the `rootClaim` commits to.\n     */\n    function l2BlockNumber() external view returns (uint256 _l2BlockNumber);\n\n    /**\n     * @notice Challenge the `rootClaim`.\n     * @dev - If the `ecrecover`ed address that created the signature is not a part of\n     *        the signer set returned by `signerSet`, this function should revert.\n     *      - If the `ecrecover`ed address that created the signature is not the\n     *        msg.sender, this function should revert.\n     *      - If the signature provided is the signature that breaches the signature\n     *        threshold, the function should call the `resolve` function to resolve\n     *        the game as `CHALLENGER_WINS`.\n     *      - When the game resolves, the bond attached to the root claim should be\n     *        distributed among the signers who participated in challenging the\n     *        invalid claim.\n     * @param signature An EIP-712 signature committing to the `rootClaim` and\n     *        `l2BlockNumber` (within the `extraData`) from a key that exists\n     *         within the `signerSet`.\n     */\n    function challenge(bytes calldata signature) external;\n}\n"
    },
    "contracts/dispute/IBondManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n * @title IBondManager\n * @notice The Bond Manager holds ether posted as a bond for a bond id.\n */\ninterface IBondManager {\n    /**\n     * @notice Post a bond with a given id and owner.\n     * @dev This function will revert if the provided bondId is already in use.\n     * @param _bondId is the id of the bond.\n     * @param _bondOwner is the address that owns the bond.\n     * @param _minClaimHold is the minimum amount of time the owner\n     *        must wait before reclaiming their bond.\n     */\n    function post(\n        bytes32 _bondId,\n        address _bondOwner,\n        uint256 _minClaimHold\n    ) external payable;\n\n    /**\n     * @notice Seizes the bond with the given id.\n     * @dev This function will revert if there is no bond at the given id.\n     * @param _bondId is the id of the bond.\n     */\n    function seize(bytes32 _bondId) external;\n\n    /**\n     * @notice Seizes the bond with the given id and distributes it to recipients.\n     * @dev This function will revert if there is no bond at the given id.\n     * @param _bondId is the id of the bond.\n     * @param _claimRecipients is a set of addresses to split the bond amongst.\n     */\n    function seizeAndSplit(bytes32 _bondId, address[] calldata _claimRecipients) external;\n\n    /**\n     * @notice Reclaims the bond of the bond owner.\n     * @dev This function will revert if there is no bond at the given id.\n     * @param _bondId is the id of the bond.\n     */\n    function reclaim(bytes32 _bondId) external;\n}\n"
    },
    "contracts/dispute/IDisputeGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Claim } from \"../libraries/DisputeTypes.sol\";\nimport { GameType } from \"../libraries/DisputeTypes.sol\";\nimport { GameStatus } from \"../libraries/DisputeTypes.sol\";\nimport { Timestamp } from \"../libraries/DisputeTypes.sol\";\n\nimport { IVersioned } from \"./IVersioned.sol\";\nimport { IBondManager } from \"./IBondManager.sol\";\nimport { IInitializable } from \"./IInitializable.sol\";\n\n/**\n * @title IDisputeGame\n * @notice The generic interface for a DisputeGame contract.\n */\ninterface IDisputeGame is IInitializable, IVersioned {\n    /**\n     * @notice Emitted when the game is resolved.\n     * @param status The status of the game after resolution.\n     */\n    event Resolved(GameStatus indexed status);\n\n    /// @notice Returns the timestamp that the DisputeGame contract was created at.\n\n    /**\n     * @notice Returns the timestamp that the DisputeGame contract was created at.\n     * @return _createdAt The timestamp that the DisputeGame contract was created at.\n     */\n    function createdAt() external view returns (Timestamp _createdAt);\n\n    /**\n     * @notice Returns the current status of the game.\n     * @return _status The current status of the game.\n     */\n    function status() external view returns (GameStatus _status);\n\n    /**\n     * @notice Getter for the game type.\n     * @dev `clones-with-immutable-args` argument #1\n     * @dev The reference impl should be entirely different depending on the type (fault, validity)\n     *      i.e. The game type should indicate the security model.\n     * @return _gameType The type of proof system being used.\n     */\n    function gameType() external view returns (GameType _gameType);\n\n    /**\n     * @notice Getter for the root claim.\n     * @dev `clones-with-immutable-args` argument #2\n     * @return _rootClaim The root claim of the DisputeGame.\n     */\n    function rootClaim() external view returns (Claim _rootClaim);\n\n    /**\n     * @notice Getter for the extra data.\n     * @dev `clones-with-immutable-args` argument #3\n     * @return _extraData Any extra data supplied to the dispute game contract by the creator.\n     */\n    function extraData() external view returns (bytes memory _extraData);\n\n    /**\n     * @notice Returns the address of the `BondManager` used.\n     * @return _bondManager The address of the `BondManager` used.\n     */\n    function bondManager() external view returns (IBondManager _bondManager);\n\n    /**\n     * @notice If all necessary information has been gathered, this function should mark the game\n     *         status as either `CHALLENGER_WINS` or `DEFENDER_WINS` and return the status of\n     *         the resolved game. It is at this stage that the bonds should be awarded to the\n     *         necessary parties.\n     * @dev May only be called if the `status` is `IN_PROGRESS`.\n     * @return _status The status of the game after resolution.\n     */\n    function resolve() external returns (GameStatus _status);\n}\n"
    },
    "contracts/dispute/IDisputeGameFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Claim } from \"../libraries/DisputeTypes.sol\";\nimport { GameType } from \"../libraries/DisputeTypes.sol\";\n\nimport { IDisputeGame } from \"./IDisputeGame.sol\";\n\n/**\n * @title IDisputeGameFactory\n * @notice The interface for a DisputeGameFactory contract.\n */\ninterface IDisputeGameFactory {\n    /**\n     * @notice Emitted when a new dispute game is created\n     * @param disputeProxy The address of the dispute game proxy\n     * @param gameType The type of the dispute game proxy's implementation\n     * @param rootClaim The root claim of the dispute game\n     */\n    event DisputeGameCreated(\n        address indexed disputeProxy,\n        GameType indexed gameType,\n        Claim indexed rootClaim\n    );\n\n    /**\n     * @notice Emitted when a new game implementation added to the factory\n     * @param impl The implementation contract for the given `GameType`.\n     * @param gameType The type of the DisputeGame.\n     */\n    event ImplementationSet(address indexed impl, GameType indexed gameType);\n\n    /**\n     * @notice `games` queries an internal a mapping that maps the hash of\n     *         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.\n     * @dev `++` equates to concatenation.\n     * @param gameType The type of the DisputeGame - used to decide the proxy implementation\n     * @param rootClaim The root claim of the DisputeGame.\n     * @param extraData Any extra data that should be provided to the created dispute game.\n     * @return _proxy The clone of the `DisputeGame` created with the given parameters.\n     *         Returns `address(0)` if nonexistent.\n     */\n    function games(\n        GameType gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) external view returns (IDisputeGame _proxy);\n\n    /**\n     * @notice `gameImpls` is a mapping that maps `GameType`s to their respective\n     *         `IDisputeGame` implementations.\n     * @param gameType The type of the dispute game.\n     * @return _impl The address of the implementation of the game type.\n     *         Will be cloned on creation of a new dispute game with the given `gameType`.\n     */\n    function gameImpls(GameType gameType) external view returns (IDisputeGame _impl);\n\n    /**\n     * @notice Creates a new DisputeGame proxy contract.\n     * @param gameType The type of the DisputeGame - used to decide the proxy implementation\n     * @param rootClaim The root claim of the DisputeGame.\n     * @param extraData Any extra data that should be provided to the created dispute game.\n     * @return proxy The address of the created DisputeGame proxy.\n     */\n    function create(\n        GameType gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) external returns (IDisputeGame proxy);\n\n    /**\n     * @notice Sets the implementation contract for a specific `GameType`.\n     * @dev May only be called by the `owner`.\n     * @param gameType The type of the DisputeGame.\n     * @param impl The implementation contract for the given `GameType`.\n     */\n    function setImplementation(GameType gameType, IDisputeGame impl) external;\n}\n"
    },
    "contracts/dispute/IFaultDisputeGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Clock } from \"../libraries/DisputeTypes.sol\";\nimport { Claim } from \"../libraries/DisputeTypes.sol\";\nimport { Position } from \"../libraries/DisputeTypes.sol\";\nimport { Timestamp } from \"../libraries/DisputeTypes.sol\";\nimport { ClaimHash } from \"../libraries/DisputeTypes.sol\";\nimport { BondAmount } from \"../libraries/DisputeTypes.sol\";\n\nimport { IDisputeGame } from \"./IDisputeGame.sol\";\n\n/**\n * @title IFaultDisputeGame\n * @notice The interface for a fault proof backed dispute game.\n */\ninterface IFaultDisputeGame is IDisputeGame {\n    /**\n     * @notice Emitted when a subclaim is disagreed upon by `claimant`\n     * @dev Disagreeing with a subclaim is akin to attacking it.\n     * @param claimHash The unique ClaimHash that is being disagreed upon\n     * @param pivot The claim for the following pivot (disagreement = go left)\n     * @param claimant The address of the claimant\n     */\n    event Attack(ClaimHash indexed claimHash, Claim indexed pivot, address indexed claimant);\n\n    /**\n     * @notice Emitted when a subclaim is agreed upon by `claimant`\n     * @dev Agreeing with a subclaim is akin to defending it.\n     * @param claimHash The unique ClaimHash that is being agreed upon\n     * @param pivot The claim for the following pivot (agreement = go right)\n     * @param claimant The address of the claimant\n     */\n    event Defend(ClaimHash indexed claimHash, Claim indexed pivot, address indexed claimant);\n\n    /**\n     * @notice State variable of the starting timestamp of the game, set on deployment.\n     * @return The starting timestamp of the game\n     */\n    function gameStart() external view returns (Timestamp);\n\n    /**\n     * @notice Maps a unique ClaimHash to a Claim.\n     * @param claimHash The unique ClaimHash\n     * @return claim The Claim associated with the ClaimHash\n     */\n    function claims(ClaimHash claimHash) external view returns (Claim claim);\n\n    /**\n     * @notice Maps a unique ClaimHash to its parent.\n     * @param claimHash The unique ClaimHash\n     * @return parent The parent ClaimHash of the passed ClaimHash\n     */\n    function parents(ClaimHash claimHash) external view returns (ClaimHash parent);\n\n    /**\n     * @notice Maps a unique ClaimHash to its Position.\n     * @param claimHash The unique ClaimHash\n     * @return position The Position associated with the ClaimHash\n     */\n    function positions(ClaimHash claimHash) external view returns (Position position);\n\n    /**\n     * @notice Maps a unique ClaimHash to a Bond.\n     * @param claimHash The unique ClaimHash\n     * @return bond The Bond associated with the ClaimHash\n     */\n    function bonds(ClaimHash claimHash) external view returns (BondAmount bond);\n\n    /**\n     * @notice Maps a unique ClaimHash its chess clock.\n     * @param claimHash The unique ClaimHash\n     * @return clock The chess clock associated with the ClaimHash\n     */\n    function clocks(ClaimHash claimHash) external view returns (Clock clock);\n\n    /**\n     * @notice Maps a unique ClaimHash to its reference counter.\n     * @param claimHash The unique ClaimHash\n     * @return _rc The reference counter associated with the ClaimHash\n     */\n    function rc(ClaimHash claimHash) external view returns (uint64 _rc);\n\n    /**\n     * @notice Maps a unique ClaimHash to a boolean indicating whether or not it has been countered.\n     * @param claimHash The unique claimHash\n     * @return _countered Whether or not `claimHash` has been countered\n     */\n    function countered(ClaimHash claimHash) external view returns (bool _countered);\n\n    /**\n     * @notice Disagree with a subclaim\n     * @param disagreement The ClaimHash of the disagreement\n     * @param pivot The claimed pivot\n     */\n    function attack(ClaimHash disagreement, Claim pivot) external;\n\n    /**\n     * @notice Agree with a subclaim\n     * @param agreement The ClaimHash of the agreement\n     * @param pivot The claimed pivot\n     */\n    function defend(ClaimHash agreement, Claim pivot) external;\n\n    /**\n     * @notice Perform the final step via an on-chain fault proof processor\n     * @dev This function should point to a fault proof processor in order to execute\n     *      a step in the fault proof program on-chain. The interface of the fault proof\n     *      processor contract should be generic enough such that we can use different\n     *      fault proof VMs (MIPS, RiscV5, etc.)\n     * @param disagreement The ClaimHash of the disagreement\n     */\n    function step(ClaimHash disagreement) external;\n}\n"
    },
    "contracts/dispute/IInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n * @title IInitializable\n * @notice An interface for initializable contracts.\n */\ninterface IInitializable {\n    /**\n     * @notice Initializes the contract.\n     * @dev This function may only be called once.\n     */\n    function initialize() external;\n}\n"
    },
    "contracts/dispute/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n * @title IVersioned\n * @notice An interface for semantically versioned contracts.\n */\ninterface IVersioned {\n    /**\n     * @notice Returns the semantic version of the contract\n     * @return _version The semantic version of the contract\n     */\n    function version() external pure returns (string memory _version);\n}\n"
    },
    "contracts/echidna/FuzzAddressAliasing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzAddressAliasing {\n    bool internal failedRoundtrip;\n\n    /**\n     * @notice Takes an address to be aliased with AddressAliasHelper and then unaliased\n     *         and updates the test contract's state indicating if the round trip encoding\n     *         failed.\n     */\n    function testRoundTrip(address addr) public {\n        // Alias our address\n        address aliasedAddr = AddressAliasHelper.applyL1ToL2Alias(addr);\n\n        // Unalias our address\n        address undoneAliasAddr = AddressAliasHelper.undoL1ToL2Alias(aliasedAddr);\n\n        // If our round trip aliasing did not return the original result, set our state.\n        if (addr != undoneAliasAddr) {\n            failedRoundtrip = true;\n        }\n    }\n\n    /**\n     * @custom:invariant Address aliases are always able to be undone.\n     *\n     * Asserts that an address that has been aliased with `applyL1ToL2Alias` can always\n     * be unaliased with `undoL1ToL2Alias`.\n     */\n    function echidna_round_trip_aliasing() public view returns (bool) {\n        // ASSERTION: The round trip aliasing done in testRoundTrip(...) should never fail.\n        return !failedRoundtrip;\n    }\n}\n"
    },
    "contracts/echidna/FuzzBurn.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { StdUtils } from \"forge-std/Test.sol\";\n\ncontract EchidnaFuzzBurnEth is StdUtils {\n    bool internal failedEthBurn;\n\n    /**\n     * @notice Takes an integer amount of eth to burn through the Burn library and\n     * updates the contract state if an incorrect amount of eth moved from the contract\n     */\n    function testBurn(uint256 _value) public {\n        // cache the contract's eth balance\n        uint256 preBurnBalance = address(this).balance;\n        uint256 value = bound(_value, 0, preBurnBalance);\n\n        // execute a burn of _value eth\n        Burn.eth(value);\n\n        // check that exactly value eth was transfered from the contract\n        unchecked {\n            if (address(this).balance != preBurnBalance - value) {\n                failedEthBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `eth(uint256)` always burns the exact amount of eth passed.\n     *\n     * Asserts that when `Burn.eth(uint256)` is called, it always burns the exact amount\n     * of ETH passed to the function.\n     */\n    function echidna_burn_eth() public view returns (bool) {\n        // ASSERTION: The amount burned should always match the amount passed exactly\n        return !failedEthBurn;\n    }\n}\n\ncontract EchidnaFuzzBurnGas is StdUtils {\n    bool internal failedGasBurn;\n\n    /**\n     * @notice Takes an integer amount of gas to burn through the Burn library and\n     * updates the contract state if at least that amount of gas was not burned\n     * by the library\n     */\n    function testGas(uint256 _value) public {\n        // cap the value to the max resource limit\n        uint256 MAX_RESOURCE_LIMIT = 8_000_000;\n        uint256 value = bound(_value, 0, MAX_RESOURCE_LIMIT);\n\n        // cache the contract's current remaining gas\n        uint256 preBurnGas = gasleft();\n\n        // execute the gas burn\n        Burn.gas(value);\n\n        // cache the remaining gas post burn\n        uint256 postBurnGas = gasleft();\n\n        // check that at least value gas was burnt (and that there was no underflow)\n        unchecked {\n            if (postBurnGas - preBurnGas > value || preBurnGas - value > preBurnGas) {\n                failedGasBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `gas(uint256)` always burns at least the amount of gas passed.\n     *\n     * Asserts that when `Burn.gas(uint256)` is called, it always burns at least the amount\n     * of gas passed to the function.\n     */\n    function echidna_burn_gas() public view returns (bool) {\n        // ASSERTION: The amount of gas burned should be strictly greater than the\n        // the amount passed as _value (minimum _value + whatever minor overhead to\n        // the value after the call)\n        return !failedGasBurn;\n    }\n}\n"
    },
    "contracts/echidna/FuzzEncoding.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract EchidnaFuzzEncoding {\n    bool internal failedRoundtripAToB;\n    bool internal failedRoundtripBToA;\n\n    /**\n     * @notice Takes a pair of integers to be encoded into a versioned nonce with the\n     *         Encoding library and then decoded and updates the test contract's state\n     *         indicating if the round trip encoding failed.\n     */\n    function testRoundTripAToB(uint240 _nonce, uint16 _version) public {\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(encodedVersionedNonce);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if ((decodedNonce != _nonce) || (decodedVersion != _version)) {\n            failedRoundtripAToB = true;\n        }\n    }\n\n    /**\n     * @notice Takes an integer representing a packed version and nonce and attempts\n     *         to decode them using the Encoding library before re-encoding and updates\n     *         the test contract's state indicating if the round trip encoding failed.\n     */\n    function testRoundTripBToA(uint256 _versionedNonce) public {\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(_versionedNonce);\n\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(decodedNonce, decodedVersion);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if (encodedVersionedNonce != _versionedNonce) {\n            failedRoundtripBToA = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `testRoundTripAToB` never fails.\n     *\n     * Asserts that a raw versioned nonce can be encoded / decoded to reach the same raw value.\n     */\n    function echidna_round_trip_encoding_AToB() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripAToB(...)\n        return !failedRoundtripAToB;\n    }\n\n    /**\n     * @custom:invariant `testRoundTripBToA` never fails.\n     *\n     * Asserts that an encoded versioned nonce can always be decoded / re-encoded to reach\n     * the same encoded value.\n     */\n    function echidna_round_trip_encoding_BToA() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripBToA should never\n        // fail.\n        return !failedRoundtripBToA;\n    }\n}\n"
    },
    "contracts/echidna/FuzzHashing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract EchidnaFuzzHashing {\n    bool internal failedCrossDomainHashHighVersion;\n    bool internal failedCrossDomainHashV0;\n    bool internal failedCrossDomainHashV1;\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash with a randomly\n     * generated version. Only schema versions 0 and 1 are supported and all others should revert.\n     */\n    function testHashCrossDomainMessageHighVersion(\n        uint16 _version,\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // hash the cross domain message. we don't need to store the result since the function\n        // validates and should revert if an invalid version (>1) is encoded\n        Hashing.hashCrossDomainMessage(encodedNonce, _sender, _target, _value, _gasLimit, _data);\n\n        // check that execution never makes it this far for an invalid version\n        if (_version > 1) {\n            failedCrossDomainHashHighVersion = true;\n        }\n    }\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash using the v0 schema\n     * and compares the output of a call to the unversioned function to the v0 function directly\n     */\n    function testHashCrossDomainMessageV0(\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce with the version set to 0\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, 0);\n\n        // hash the cross domain message using the unversioned and versioned functions for\n        // comparison\n        bytes32 sampleHash1 = Hashing.hashCrossDomainMessage(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n        bytes32 sampleHash2 = Hashing.hashCrossDomainMessageV0(\n            _target,\n            _sender,\n            _data,\n            encodedNonce\n        );\n\n        // check that the output of both functions matches\n        if (sampleHash1 != sampleHash2) {\n            failedCrossDomainHashV0 = true;\n        }\n    }\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash using the v1 schema\n     * and compares the output of a call to the unversioned function to the v1 function directly\n     */\n    function testHashCrossDomainMessageV1(\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce with the version set to 1\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, 1);\n\n        // hash the cross domain message using the unversioned and versioned functions for\n        // comparison\n        bytes32 sampleHash1 = Hashing.hashCrossDomainMessage(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n        bytes32 sampleHash2 = Hashing.hashCrossDomainMessageV1(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        // check that the output of both functions matches\n        if (sampleHash1 != sampleHash2) {\n            failedCrossDomainHashV1 = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `hashCrossDomainMessage` reverts if `version` is > `1`.\n     *\n     * The `hashCrossDomainMessage` function should always revert if the `version` passed is > `1`.\n     */\n    function echidna_hash_xdomain_msg_high_version() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage will never succeed for a version > 1\n        return !failedCrossDomainHashHighVersion;\n    }\n\n    /**\n     * @custom:invariant `version` = `0`: `hashCrossDomainMessage` and `hashCrossDomainMessageV0`\n     * are equivalent.\n     *\n     * If the version passed is 0, `hashCrossDomainMessage` and `hashCrossDomainMessageV0` should be\n     * equivalent.\n     */\n    function echidna_hash_xdomain_msg_0() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage and hashCrossDomainMessageV0\n        // should always match when the version passed is 0\n        return !failedCrossDomainHashV0;\n    }\n\n    /**\n     * @custom:invariant `version` = `1`: `hashCrossDomainMessage` and `hashCrossDomainMessageV1`\n     * are equivalent.\n     *\n     * If the version passed is 1, `hashCrossDomainMessage` and `hashCrossDomainMessageV1` should be\n     * equivalent.\n     */\n    function echidna_hash_xdomain_msg_1() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage and hashCrossDomainMessageV1\n        // should always match when the version passed is 1\n        return !failedCrossDomainHashV1;\n    }\n}\n"
    },
    "contracts/echidna/FuzzOptimismPortal.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract EchidnaFuzzOptimismPortal {\n    OptimismPortal internal portal;\n    bool internal failedToComplete;\n\n    constructor() {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        SystemConfig systemConfig = new SystemConfig({\n            _owner: address(1),\n            _overhead: 0,\n            _scalar: 10000,\n            _batcherHash: bytes32(0),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(0),\n            _config: rcfg\n        });\n\n        portal = new OptimismPortal({\n            _l2Oracle: L2OutputOracle(address(0)),\n            _guardian: address(0),\n            _paused: false,\n            _config: systemConfig\n        });\n    }\n\n    // A test intended to identify any unexpected halting conditions\n    function testDepositTransactionCompletes(\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable {\n        failedToComplete = true;\n        require(!_isCreation || _to == address(0), \"EchidnaFuzzOptimismPortal: invalid test case.\");\n        portal.depositTransaction{ value: _mint }(_to, _value, _gasLimit, _isCreation, _data);\n        failedToComplete = false;\n    }\n\n    /**\n     * @custom:invariant Deposits of any value should always succeed unless\n     * `_to` = `address(0)` or `_isCreation` = `true`.\n     *\n     * All deposits, barring creation transactions and transactions sent to `address(0)`,\n     * should always succeed.\n     */\n    function echidna_deposit_completes() public view returns (bool) {\n        return !failedToComplete;\n    }\n}\n"
    },
    "contracts/echidna/FuzzResourceMetering.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { StdUtils } from \"forge-std/Test.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract EchidnaFuzzResourceMetering is ResourceMetering, StdUtils {\n    bool internal failedMaxGasPerBlock;\n    bool internal failedRaiseBaseFee;\n    bool internal failedLowerBaseFee;\n    bool internal failedNeverBelowMinBaseFee;\n    bool internal failedMaxRaiseBaseFeePerBlock;\n    bool internal failedMaxLowerBaseFeePerBlock;\n\n    // Used as a special flag for the purpose of identifying unchecked math errors specifically\n    // in the test contracts, not the target contracts themselves.\n    bool internal underflow;\n\n    constructor() {\n        initialize();\n    }\n\n    function initialize() internal initializer {\n        __ResourceMetering_init();\n    }\n\n    function resourceConfig() public pure returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig();\n    }\n\n    function _resourceConfig()\n        internal\n        pure\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n        return rcfg;\n    }\n\n    /**\n     * @notice Takes the necessary parameters to allow us to burn arbitrary amounts of gas to test\n     *         the underlying resource metering/gas market logic\n     */\n    function testBurn(uint256 _gasToBurn, bool _raiseBaseFee) public {\n        // Part 1: we cache the current param values and do some basic checks on them.\n        uint256 cachedPrevBaseFee = uint256(params.prevBaseFee);\n        uint256 cachedPrevBoughtGas = uint256(params.prevBoughtGas);\n        uint256 cachedPrevBlockNum = uint256(params.prevBlockNum);\n\n        ResourceMetering.ResourceConfig memory rcfg = resourceConfig();\n        uint256 targetResourceLimit = uint256(rcfg.maxResourceLimit) /\n            uint256(rcfg.elasticityMultiplier);\n\n        // check that the last block's base fee hasn't dropped below the minimum\n        if (cachedPrevBaseFee < uint256(rcfg.minimumBaseFee)) {\n            failedNeverBelowMinBaseFee = true;\n        }\n        // check that the last block didn't consume more than the max amount of gas\n        if (cachedPrevBoughtGas > uint256(rcfg.maxResourceLimit)) {\n            failedMaxGasPerBlock = true;\n        }\n\n        // Part2: we perform the gas burn\n\n        // force the gasToBurn into the correct range based on whether we intend to\n        // raise or lower the baseFee after this block, respectively\n        uint256 gasToBurn;\n        if (_raiseBaseFee) {\n            gasToBurn = bound(\n                _gasToBurn,\n                uint256(targetResourceLimit),\n                uint256(rcfg.maxResourceLimit)\n            );\n        } else {\n            gasToBurn = bound(_gasToBurn, 0, targetResourceLimit);\n        }\n\n        _burnInternal(uint64(gasToBurn));\n\n        // Part 3: we run checks and modify our invariant flags based on the updated params values\n\n        // Calculate the maximum allowed baseFee change (per block)\n        uint256 maxBaseFeeChange = cachedPrevBaseFee / uint256(rcfg.baseFeeMaxChangeDenominator);\n\n        // If the last block used more than the target amount of gas (and there were no\n        // empty blocks in between), ensure this block's baseFee increased, but not by\n        // more than the max amount per block\n        if (\n            (cachedPrevBoughtGas > uint256(targetResourceLimit)) &&\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum == 1)\n        ) {\n            failedRaiseBaseFee = failedRaiseBaseFee || (params.prevBaseFee <= cachedPrevBaseFee);\n            failedMaxRaiseBaseFeePerBlock =\n                failedMaxRaiseBaseFeePerBlock ||\n                ((uint256(params.prevBaseFee) - cachedPrevBaseFee) < maxBaseFeeChange);\n        }\n\n        // If the last block used less than the target amount of gas, (or was empty),\n        // ensure that: this block's baseFee was decreased, but not by more than the max amount\n        if (\n            (cachedPrevBoughtGas < uint256(targetResourceLimit)) ||\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum > 1)\n        ) {\n            // Invariant: baseFee should decrease\n            failedLowerBaseFee =\n                failedLowerBaseFee ||\n                (uint256(params.prevBaseFee) > cachedPrevBaseFee);\n\n            if (params.prevBlockNum - cachedPrevBlockNum == 1) {\n                // No empty blocks\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            } else if (params.prevBlockNum - cachedPrevBlockNum > 1) {\n                // We have at least one empty block\n                // Update the maxBaseFeeChange to account for multiple blocks having passed\n                unchecked {\n                    maxBaseFeeChange = uint256(\n                        int256(cachedPrevBaseFee) -\n                            Arithmetic.clamp(\n                                Arithmetic.cdexp(\n                                    int256(cachedPrevBaseFee),\n                                    int256(uint256(rcfg.baseFeeMaxChangeDenominator)),\n                                    int256(uint256(params.prevBlockNum) - cachedPrevBlockNum)\n                                ),\n                                int256(uint256(rcfg.minimumBaseFee)),\n                                int256(uint256(rcfg.maximumBaseFee))\n                            )\n                    );\n                }\n\n                // Detect an underflow in the previous calculation.\n                // Without using unchecked above, and detecting the underflow here, echidna would\n                // otherwise ignore the revert.\n                underflow = underflow || maxBaseFeeChange > cachedPrevBaseFee;\n\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            }\n        }\n    }\n\n    function _burnInternal(uint64 _gasToBurn) private metered(_gasToBurn) {}\n\n    /**\n     * @custom:invariant The base fee should increase if the last block used more\n     * than the target amount of gas\n     *\n     * If the last block used more than the target amount of gas (and there were no\n     * empty blocks in between), ensure this block's baseFee increased, but not by\n     * more than the max amount per block.\n     */\n    function echidna_high_usage_raise_baseFee() public view returns (bool) {\n        return !failedRaiseBaseFee;\n    }\n\n    /**\n     * @custom:invariant The base fee should decrease if the last block used less\n     * than the target amount of gas\n     *\n     * If the previous block used less than the target amount of gas, the base fee should decrease,\n     * but not more than the max amount.\n     */\n    function echidna_low_usage_lower_baseFee() public view returns (bool) {\n        return !failedLowerBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block's base fee should never be below `MINIMUM_BASE_FEE`\n     *\n     * This test asserts that a block's base fee can never drop below the\n     * `MINIMUM_BASE_FEE` threshold.\n     */\n    function echidna_never_below_min_baseFee() public view returns (bool) {\n        return !failedNeverBelowMinBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block can never consume more than `MAX_RESOURCE_LIMIT` gas.\n     *\n     * This test asserts that a block can never consume more than the `MAX_RESOURCE_LIMIT`\n     * gas threshold.\n     */\n    function echidna_never_above_max_gas_limit() public view returns (bool) {\n        return !failedMaxGasPerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be raised more than the max base fee change.\n     *\n     * After a block consumes more gas than the target gas, the base fee cannot be raised\n     * more than the maximum amount allowed. The max base fee change (per-block) is derived\n     * as follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_increase() public view returns (bool) {\n        return !failedMaxRaiseBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be lowered more than the max base fee change.\n     *\n     * After a block consumes less than the target gas, the base fee cannot be lowered more\n     * than the maximum amount allowed. The max base fee change (per-block) is derived as\n     *follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_decrease() public view returns (bool) {\n        return !failedMaxLowerBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The `maxBaseFeeChange` calculation over multiple blocks can never\n     * underflow.\n     *\n     * When calculating the `maxBaseFeeChange` after multiple empty blocks, the calculation\n     * should never be allowed to underflow.\n     */\n    function echidna_underflow() public view returns (bool) {\n        return !underflow;\n    }\n}\n"
    },
    "contracts/governance/GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @custom:predeploy 0x4200000000000000000000000000000000000042\n * @title GovernanceToken\n * @notice The Optimism token used in governance and supporting voting and delegation. Implements\n *         EIP 2612 allowing signed approvals. Contract is \"owned\" by a `MintManager` instance with\n *         permission to the `mint` function only, for the purposes of enforcing the token inflation\n *         schedule.\n */\ncontract GovernanceToken is ERC20Burnable, ERC20Votes, Ownable {\n    constructor() ERC20(\"Optimism\", \"OP\") ERC20Permit(\"Optimism\") {}\n\n    /**\n     * @notice Allows the owner to mint tokens.\n     *\n     * @param _account The account receiving minted tokens.\n     * @param _amount  The amount of tokens to mint.\n     */\n    function mint(address _account, uint256 _amount) public onlyOwner {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice Callback called after a token transfer.\n     *\n     * @param from   The account sending tokens.\n     * @param to     The account receiving tokens.\n     * @param amount The amount of tokens being transfered.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @notice Internal mint function.\n     *\n     * @param to     The account receiving minted tokens.\n     * @param amount The amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Internal burn function.\n     *\n     * @param account The account that tokens will be burned from.\n     * @param amount  The amount of tokens that will be burned.\n     */\n    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._burn(account, amount);\n    }\n}\n"
    },
    "contracts/governance/MintManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./GovernanceToken.sol\";\n\n/**\n * @title  MintManager\n * @notice Set as `owner` of the OP token and responsible for the token inflation schedule.\n *         Contract acts as the token \"mint manager\" with permission to the `mint` function only.\n *         Currently permitted to mint once per year of up to 2% of the total token supply.\n *         Upgradable to allow changes in the inflation schedule.\n */\ncontract MintManager is Ownable {\n    /**\n     * @notice The GovernanceToken that the MintManager can mint tokens\n     */\n    GovernanceToken public immutable governanceToken;\n\n    /**\n     * @notice The amount of tokens that can be minted per year. The value is a fixed\n     *          point number with 4 decimals.\n     */\n    uint256 public constant MINT_CAP = 20; // 2%\n\n    /**\n     * @notice The number of decimals for the MINT_CAP.\n     */\n    uint256 public constant DENOMINATOR = 1000;\n\n    /**\n     * @notice The amount of time that must pass before the MINT_CAP number of tokens can\n     *         be minted again.\n     */\n    uint256 public constant MINT_PERIOD = 365 days;\n\n    /**\n     * @notice Tracks the time of last mint.\n     */\n    uint256 public mintPermittedAfter;\n\n    /**\n     * @param _upgrader        The owner of this contract\n     * @param _governanceToken The governance token this contract can mint\n     *                         tokens of\n     */\n    constructor(address _upgrader, address _governanceToken) {\n        transferOwnership(_upgrader);\n        governanceToken = GovernanceToken(_governanceToken);\n    }\n\n    /**\n     * @notice Only the token owner is allowed to mint a certain amount of OP per year.\n     *\n     * @param _account Address to mint new tokens to.\n     * @param _amount  Amount of tokens to be minted.\n     */\n    function mint(address _account, uint256 _amount) public onlyOwner {\n        if (mintPermittedAfter > 0) {\n            require(\n                mintPermittedAfter <= block.timestamp,\n                \"MintManager: minting not permitted yet\"\n            );\n\n            require(\n                _amount <= (governanceToken.totalSupply() * MINT_CAP) / DENOMINATOR,\n                \"MintManager: mint amount exceeds cap\"\n            );\n        }\n\n        mintPermittedAfter = block.timestamp + MINT_PERIOD;\n        governanceToken.mint(_account, _amount);\n    }\n\n    /**\n     * @notice Upgrade the owner of the governance token to a new MintManager.\n     *\n     * @param _newMintManager The MintManager to upgrade to.\n     */\n    function upgrade(address _newMintManager) public onlyOwner {\n        require(\n            _newMintManager != address(0),\n            \"MintManager: mint manager cannot be the zero address\"\n        );\n\n        governanceToken.transferOwnership(_newMintManager);\n    }\n}\n"
    },
    "contracts/legacy/AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @custom:legacy\n * @title AddressManager\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\n *         system to manage a registry of string names to addresses. We now use a more standard\n *         proxy system instead, but this contract is still necessary for backwards compatibility\n *         with several older contracts.\n */\ncontract AddressManager is Ownable {\n    /**\n     * @notice Mapping of the hashes of string names to addresses.\n     */\n    mapping(bytes32 => address) private addresses;\n\n    /**\n     * @notice Emitted when an address is modified in the registry.\n     *\n     * @param name       String name being set in the registry.\n     * @param newAddress Address set for the given name.\n     * @param oldAddress Address that was previously set for the given name.\n     */\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\n\n    /**\n     * @notice Changes the address associated with a particular name.\n     *\n     * @param _name    String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }\n\n    /**\n     * @notice Retrieves the address associated with a given name.\n     *\n     * @param _name Name to retrieve an address for.\n     *\n     * @return Address associated with the given name.\n     */\n    function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }\n\n    /**\n     * @notice Computes the hash of a name.\n     *\n     * @param _name Name to compute a hash for.\n     *\n     * @return Hash of the given name.\n     */\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "contracts/legacy/DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeployed 0x4200000000000000000000000000000000000002\n * @title DeployerWhitelist\n * @notice DeployerWhitelist is a legacy contract that was originally used to act as a whitelist of\n *         addresses allowed to the Optimism network. The DeployerWhitelist has since been\n *         disabled, but the code is kept in state for the sake of full backwards compatibility.\n *         As of the Bedrock upgrade, the DeployerWhitelist is completely unused by the Optimism\n *         system and could, in theory, be removed entirely.\n */\ncontract DeployerWhitelist is Semver {\n    /**\n     * @notice Address of the owner of this contract. Note that when this address is set to\n     *         address(0), the whitelist is disabled.\n     */\n    address public owner;\n\n    /**\n     * @notice Mapping of deployer addresses to boolean whitelist status.\n     */\n    mapping(address => bool) public whitelist;\n\n    /**\n     * @notice Emitted when the owner of this contract changes.\n     *\n     * @param oldOwner Address of the previous owner.\n     * @param newOwner Address of the new owner.\n     */\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    /**\n     * @notice Emitted when the whitelist status of a deployer changes.\n     *\n     * @param deployer    Address of the deployer.\n     * @param whitelisted Boolean indicating whether the deployer is whitelisted.\n     */\n    event WhitelistStatusChanged(address deployer, bool whitelisted);\n\n    /**\n     * @notice Emitted when the whitelist is disabled.\n     *\n     * @param oldOwner Address of the final owner of the whitelist.\n     */\n    event WhitelistDisabled(address oldOwner);\n\n    /**\n     * @notice Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"DeployerWhitelist: function can only be called by the owner of this contract\"\n        );\n        _;\n    }\n\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**\n     * @notice Adds or removes an address from the deployment whitelist.\n     *\n     * @param _deployer      Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external onlyOwner {\n        whitelist[_deployer] = _isWhitelisted;\n        emit WhitelistStatusChanged(_deployer, _isWhitelisted);\n    }\n\n    /**\n     * @notice Updates the owner of this contract.\n     *\n     * @param _owner Address of the new owner.\n     */\n    function setOwner(address _owner) external onlyOwner {\n        // Prevent users from setting the whitelist owner to address(0) except via\n        // enableArbitraryContractDeployment. If you want to burn the whitelist owner, send it to\n        // any other address that doesn't have a corresponding knowable private key.\n        require(\n            _owner != address(0),\n            \"DeployerWhitelist: can only be disabled via enableArbitraryContractDeployment\"\n        );\n\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * @notice Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment() external onlyOwner {\n        emit WhitelistDisabled(owner);\n        owner = address(0);\n    }\n\n    /**\n     * @notice Checks whether an address is allowed to deploy contracts.\n     *\n     * @param _deployer Address to check.\n     *\n     * @return Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(address _deployer) external view returns (bool) {\n        return (owner == address(0) || whitelist[_deployer]);\n    }\n}\n"
    },
    "contracts/legacy/L1BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000013\n * @title L1BlockNumber\n * @notice L1BlockNumber is a legacy contract that fills the roll of the OVM_L1BlockNumber contract\n *         in the old version of the Optimism system. Only necessary for backwards compatibility.\n *         If you want to access the L1 block number going forward, you should use the L1Block\n *         contract instead.\n */\ncontract L1BlockNumber is Semver {\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**\n     * @notice Returns the L1 block number.\n     */\n    receive() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    /**\n     * @notice Returns the L1 block number.\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    /**\n     * @notice Retrieves the latest L1 block number.\n     *\n     * @return Latest L1 block number.\n     */\n    function getL1BlockNumber() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).number();\n    }\n}\n"
    },
    "contracts/legacy/L1ChugSplashProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title IL1ChugSplashDeployer\n */\ninterface IL1ChugSplashDeployer {\n    function isUpgrading() external view returns (bool);\n}\n\n/**\n * @custom:legacy\n * @title L1ChugSplashProxy\n * @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\n *         functions `setCode` and `setStorage` for changing the code or storage of the contract.\n *\n *         Note for future developers: do NOT make anything in this contract 'public' unless you\n *         know what you're doing. Anything public can potentially have a function signature that\n *         conflicts with a signature attached to the implementation contract. Public functions\n *         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\n *         reason not to have that modifier. And there almost certainly is not a good reason to not\n *         have that modifier. Beware!\n */\ncontract L1ChugSplashProxy {\n    /**\n     * @notice \"Magic\" prefix. When prepended to some arbitrary bytecode and used to create a\n     *         contract, the appended bytecode will be deployed as given.\n     */\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\n\n    /**\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice Blocks a function from being called when the parent signals that the system should\n     *         be paused via an isUpgrading function.\n     */\n    modifier onlyWhenNotPaused() {\n        address owner = _getOwner();\n\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\n        // it turns out that it isn't the right type of contract.\n        (bool success, bytes memory returndata) = owner.staticcall(\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector)\n        );\n\n        // If the call was unsuccessful then we assume that there's no \"isUpgrading\" method and we\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\n        // long. If this isn't the case then we can safely ignore the result.\n        if (success && returndata.length == 32) {\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\n            // really care about the case where this value is 0 (= false).\n            uint256 ret = abi.decode(returndata, (uint256));\n            require(ret == 0, \"L1ChugSplashProxy: system is currently being upgraded\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Makes a proxy call instead of triggering the given function when the caller is\n     *         either the owner or the zero address. Caller can only ever be the zero address if\n     *         this function is being called off-chain via eth_call, which is totally fine and can\n     *         be convenient for client-side tooling. Avoids situations where the proxy and\n     *         implementation share a sighash and the proxy function ends up being called instead\n     *         of the implementation one.\n     *\n     *         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\n     *         there's a way for someone to send a transaction with msg.sender == address(0) in any\n     *         real context then we have much bigger problems. Primary reason to include this\n     *         additional allowed sender is because the owner address can be changed dynamically\n     *         and we do not want clients to have to keep track of the current owner in order to\n     *         make an eth_call that doesn't trigger the proxied contract.\n     */\n    // slither-disable-next-line incorrect-modifier\n    modifier proxyCallIfNotOwner() {\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @param _owner Address of the initial contract owner.\n     */\n    constructor(address _owner) {\n        _setOwner(_owner);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Sets the code that should be running behind this proxy.\n     *\n     *         Note: This scheme is a bit different from the standard proxy scheme where one would\n     *         typically deploy the code separately and then set the implementation address. We're\n     *         doing it this way because it gives us a lot more freedom on the client side. Can\n     *         only be triggered by the contract owner.\n     *\n     * @param _code New contract code to run inside this contract.\n     */\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\n        // Get the code hash of the current implementation.\n        address implementation = _getImplementation();\n\n        // If the code hash matches the new implementation then we return early.\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\n            return;\n        }\n\n        // Create the deploycode by appending the magic prefix.\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\n\n        // Deploy the code and set the new implementation address.\n        address newImplementation;\n        assembly {\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\n        }\n\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\n        // actually fail this check. Should only happen if the contract creation from above runs\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\n        // should be doing this check anyway though.\n        require(\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\n            \"L1ChugSplashProxy: code was not correctly deployed\"\n        );\n\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\n     *         perform upgrades in a more transparent way. Only callable by the owner.\n     *\n     * @param _key   Storage key to modify.\n     * @param _value New value for the storage key.\n     */\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\n        assembly {\n            sstore(_key, _value)\n        }\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _owner New owner of the proxy contract.\n     */\n    function setOwner(address _owner) external proxyCallIfNotOwner {\n        _setOwner(_owner);\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\n     *         making an eth_call and setting the \"from\" address to address(0).\n     *\n     * @return Owner address.\n     */\n    function getOwner() external proxyCallIfNotOwner returns (address) {\n        return _getOwner();\n    }\n\n    /**\n     * @notice Queries the implementation address. Can only be called by the owner OR by making an\n     *         eth_call and setting the \"from\" address to address(0).\n     *\n     * @return Implementation address.\n     */\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _owner New owner of the proxy contract.\n     */\n    function _setOwner(address _owner) internal {\n        assembly {\n            sstore(OWNER_KEY, _owner)\n        }\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal onlyWhenNotPaused {\n        address implementation = _getImplementation();\n\n        require(implementation != address(0), \"L1ChugSplashProxy: implementation is not set yet\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address implementation;\n        assembly {\n            implementation := sload(IMPLEMENTATION_KEY)\n        }\n        return implementation;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getOwner() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n\n    /**\n     * @notice Gets the code hash for a given account.\n     *\n     * @param _account Address of the account to get a code hash for.\n     *\n     * @return Code hash for the account.\n     */\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\n        bytes32 codeHash;\n        assembly {\n            codeHash := extcodehash(_account)\n        }\n        return codeHash;\n    }\n}\n"
    },
    "contracts/legacy/LegacyERC20ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\n * @title LegacyERC20ETH\n * @notice LegacyERC20ETH is a legacy contract that held ETH balances before the Bedrock upgrade.\n *         All ETH balances held within this contract were migrated to the state trie as part of\n *         the Bedrock upgrade. Functions within this contract that mutate state were already\n *         disabled as part of the EVM equivalence upgrade.\n */\ncontract LegacyERC20ETH is OptimismMintableERC20 {\n    /**\n     * @notice Initializes the contract as an Optimism Mintable ERC20.\n     */\n    constructor()\n        OptimismMintableERC20(Predeploys.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"ETH\")\n    {}\n\n    /**\n     * @notice Returns the ETH balance of the target account. Overrides the base behavior of the\n     *         contract to preserve the invariant that the balance within this contract always\n     *         matches the balance in the state trie.\n     *\n     * @param _who Address of the account to query.\n     *\n     * @return The ETH balance of the target account.\n     */\n    function balanceOf(address _who) public view virtual override returns (uint256) {\n        return address(_who).balance;\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Mints some amount of ETH.\n     */\n    function mint(address, uint256) public virtual override {\n        revert(\"LegacyERC20ETH: mint is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Burns some amount of ETH.\n     */\n    function burn(address, uint256) public virtual override {\n        revert(\"LegacyERC20ETH: burn is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Transfers some amount of ETH.\n     */\n    function transfer(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: transfer is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Approves a spender to spend some amount of ETH.\n     */\n    function approve(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: approve is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Transfers funds from some sender account.\n     */\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: transferFrom is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Increases the allowance of a spender.\n     */\n    function increaseAllowance(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: increaseAllowance is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Decreases the allowance of a spender.\n     */\n    function decreaseAllowance(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: decreaseAllowance is disabled\");\n    }\n}\n"
    },
    "contracts/legacy/LegacyMessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000000\n * @title LegacyMessagePasser\n * @notice The LegacyMessagePasser was the low-level mechanism used to send messages from L2 to L1\n *         before the Bedrock upgrade. It is now deprecated in favor of the new MessagePasser.\n */\ncontract LegacyMessagePasser is Semver {\n    /**\n     * @notice Mapping of sent message hashes to boolean status.\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @custom:semver 1.0.0\n     */\n    constructor() Semver(1, 0, 0) {}\n\n    /**\n     * @notice Passes a message to L1.\n     *\n     * @param _message Message to pass to L1.\n     */\n    function passMessageToL1(bytes memory _message) external {\n        sentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\n    }\n}\n"
    },
    "contracts/legacy/LegacyMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ILegacyMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @title LegacyMintableERC20\n * @notice The legacy implementation of the OptimismMintableERC20. This\n *         contract is deprecated and should no longer be used.\n */\ncontract LegacyMintableERC20 is ILegacyMintableERC20, ERC20 {\n    /**\n     * @notice Emitted when the token is minted by the bridge.\n     */\n    event Mint(address indexed _account, uint256 _amount);\n\n    /**\n     * @notice Emitted when a token is burned by the bridge.\n     */\n    event Burn(address indexed _account, uint256 _amount);\n\n    /**\n     * @notice The token on the remote domain.\n     */\n    address public l1Token;\n\n    /**\n     * @notice The local bridge.\n     */\n    address public l2Bridge;\n\n    /**\n     * @param _l2Bridge Address of the L2 standard bridge.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    constructor(\n        address _l2Bridge,\n        address _l1Token,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        l1Token = _l1Token;\n        l2Bridge = _l2Bridge;\n    }\n\n    /**\n     * @notice Modifier that requires the contract was called by the bridge.\n     */\n    modifier onlyL2Bridge() {\n        require(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @notice EIP165 implementation.\n     */\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\n        bytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 secondSupportedInterface = ILegacyMintableERC20.l1Token.selector ^\n            ILegacyMintableERC20.mint.selector ^\n            ILegacyMintableERC20.burn.selector;\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n\n    /**\n     * @notice Only the bridge can mint tokens.\n     * @param _to     The account receiving tokens.\n     * @param _amount The amount of tokens to receive.\n     */\n    function mint(address _to, uint256 _amount) public virtual onlyL2Bridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice Only the bridge can burn tokens.\n     * @param _from   The account having tokens burnt.\n     * @param _amount The amount of tokens being burnt.\n     */\n    function burn(address _from, uint256 _amount) public virtual onlyL2Bridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n}\n"
    },
    "contracts/legacy/ResolvedDelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AddressManager } from \"./AddressManager.sol\";\n\n/**\n * @custom:legacy\n * @title ResolvedDelegateProxy\n * @notice ResolvedDelegateProxy is a legacy proxy contract that makes use of the AddressManager to\n *         resolve the implementation address. We're maintaining this contract for backwards\n *         compatibility so we can manage all legacy proxies where necessary.\n */\ncontract ResolvedDelegateProxy {\n    /**\n     * @notice Mapping used to store the implementation name that corresponds to this contract. A\n     *         mapping was originally used as a way to bypass the same issue normally solved by\n     *         storing the implementation address in a specific storage slot that does not conflict\n     *         with any other storage slot. Generally NOT a safe solution but works as long as the\n     *         implementation does not also keep a mapping in the first storage slot.\n     */\n    mapping(address => string) private implementationName;\n\n    /**\n     * @notice Mapping used to store the address of the AddressManager contract where the\n     *         implementation address will be resolved from. Same concept here as with the above\n     *         mapping. Also generally unsafe but fine if the implementation doesn't keep a mapping\n     *         in the second storage slot.\n     */\n    mapping(address => AddressManager) private addressManager;\n\n    /**\n     * @param _addressManager  Address of the AddressManager.\n     * @param _implementationName implementationName of the contract to proxy to.\n     */\n    constructor(AddressManager _addressManager, string memory _implementationName) {\n        addressManager[address(this)] = _addressManager;\n        implementationName[address(this)] = _implementationName;\n    }\n\n    /**\n     * @notice Fallback, performs a delegatecall to the resolved implementation address.\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        address target = addressManager[address(this)].getAddress(\n            (implementationName[address(this)])\n        );\n\n        require(target != address(0), \"ResolvedDelegateProxy: target address must be initialized\");\n\n        // slither-disable-next-line controlled-delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\n\n        if (success == true) {\n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/Arithmetic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { FixedPointMathLib } from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title Arithmetic\n * @notice Even more math than before.\n */\nlibrary Arithmetic {\n    /**\n     * @notice Clamps a value between a minimum and maximum.\n     *\n     * @param _value The value to clamp.\n     * @param _min   The minimum value.\n     * @param _max   The maximum value.\n     *\n     * @return The clamped value.\n     */\n    function clamp(\n        int256 _value,\n        int256 _min,\n        int256 _max\n    ) internal pure returns (int256) {\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\n    }\n\n    /**\n     * @notice (c)oefficient (d)enominator (exp)onentiation function.\n     *         Returns the result of: c * (1 - 1/d)^exp.\n     *\n     * @param _coefficient Coefficient of the function.\n     * @param _denominator Fractional denominator.\n     * @param _exponent    Power function exponent.\n     *\n     * @return Result of c * (1 - 1/d)^exp.\n     */\n    function cdexp(\n        int256 _coefficient,\n        int256 _denominator,\n        int256 _exponent\n    ) internal pure returns (int256) {\n        return\n            (_coefficient *\n                (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\n    }\n}\n"
    },
    "contracts/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Burn\n * @notice Utilities for burning stuff.\n */\nlibrary Burn {\n    /**\n     * Burns a given amount of ETH.\n     *\n     * @param _amount Amount of ETH to burn.\n     */\n    function eth(uint256 _amount) internal {\n        new Burner{ value: _amount }();\n    }\n\n    /**\n     * Burns a given amount of gas.\n     *\n     * @param _amount Amount of gas to burn.\n     */\n    function gas(uint256 _amount) internal view {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n\n/**\n * @title Burner\n * @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\n *         the contract from the circulating supply. Self-destructing is the only way to remove ETH\n *         from the circulating supply.\n */\ncontract Burner {\n    constructor() payable {\n        selfdestruct(payable(address(this)));\n    }\n}\n"
    },
    "contracts/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes\n * @notice Bytes is a library for manipulating byte arrays.\n */\nlibrary Bytes {\n    /**\n     * @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\n     * @notice Slices a byte array with a given starting index and length. Returns a new byte array\n     *         as opposed to a pointer to the original array. Will throw if trying to slice more\n     *         bytes than exist in the array.\n     *\n     * @param _bytes Byte array to slice.\n     * @param _start Starting index of the slice.\n     * @param _length Length of the slice.\n     *\n     * @return Slice of the input byte array.\n     */\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n            require(_start + _length >= _start, \"slice_overflow\");\n            require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n        }\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Slices a byte array with a given starting index up to the end of the original byte\n     *         array. Returns a new array rathern than a pointer to the original.\n     *\n     * @param _bytes Byte array to slice.\n     * @param _start Starting index of the slice.\n     *\n     * @return Slice of the input byte array.\n     */\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    /**\n     * @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\n     *         Resulting nibble array will be exactly twice as long as the input byte array.\n     *\n     * @param _bytes Input byte array to convert.\n     *\n     * @return Resulting nibble array.\n     */\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        uint256 bytesLength = _bytes.length;\n        bytes memory nibbles = new bytes(bytesLength * 2);\n        bytes1 b;\n\n        for (uint256 i = 0; i < bytesLength; ) {\n            b = _bytes[i];\n            nibbles[i * 2] = b >> 4;\n            nibbles[i * 2 + 1] = b & 0x0f;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return nibbles;\n    }\n\n    /**\n     * @notice Compares two byte arrays by comparing their keccak256 hashes.\n     *\n     * @param _bytes First byte array to compare.\n     * @param _other Second byte array to compare.\n     *\n     * @return True if the two byte arrays are equal, false otherwise.\n     */\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\n/**\n * @title Constants\n * @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\n *         the stuff used in multiple contracts. Constants that only apply to a single contract\n *         should be defined in that contract instead.\n */\nlibrary Constants {\n    /**\n     * @notice Special address to be used as the tx origin for gas estimation calls in the\n     *         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\n     *         the minimum gas limit specified by the user is not actually enough to execute the\n     *         given message and you're attempting to estimate the actual necessary gas limit. We\n     *         use address(1) because it's the ecrecover precompile and therefore guaranteed to\n     *         never have any code on any EVM chain.\n     */\n    address internal constant ESTIMATION_ADDRESS = address(1);\n\n    /**\n     * @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\n     *         CrossDomainMessenger contracts before an actual sender is set. This value is\n     *         non-zero to reduce the gas cost of message passing transactions.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @notice Returns the default values for the ResourceConfig. These are the recommended values\n     *         for a production network.\n     */\n    function DEFAULT_RESOURCE_CONFIG()\n        internal\n        pure\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n        return config;\n    }\n}\n"
    },
    "contracts/libraries/DisputeErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./DisputeTypes.sol\";\n\n////////////////////////////////////////////////////////////////\n//                `DisputeGameFactory` Errors                 //\n////////////////////////////////////////////////////////////////\n\n/**\n * @notice Thrown when a dispute game is attempted to be created with an unsupported game type.\n * @param gameType The unsupported game type.\n */\nerror NoImplementation(GameType gameType);\n\n/**\n * @notice Thrown when a dispute game that already exists is attempted to be created.\n * @param uuid The UUID of the dispute game that already exists.\n */\nerror GameAlreadyExists(Hash uuid);\n\n////////////////////////////////////////////////////////////////\n//               `DisputeGame_Fault.sol` Errors               //\n////////////////////////////////////////////////////////////////\n\n/**\n * @notice Thrown when a supplied bond is too low to cover the\n *         cost of the next possible counter claim.\n */\nerror BondTooLow();\n\n/**\n * @notice Thrown when a defense against the root claim is attempted.\n */\nerror CannotDefendRootClaim();\n\n/**\n * @notice Thrown when a claim is attempting to be made that already exists.\n */\nerror ClaimAlreadyExists();\n\n////////////////////////////////////////////////////////////////\n//              `AttestationDisputeGame` Errors               //\n////////////////////////////////////////////////////////////////\n\n/**\n * @notice Thrown when an invalid signature is submitted to `challenge`.\n */\nerror InvalidSignature();\n\n/**\n * @notice Thrown when a signature that has already been used to support the\n *         `rootClaim` is submitted to `challenge`.\n */\nerror AlreadyChallenged();\n\n////////////////////////////////////////////////////////////////\n//                      `Ownable` Errors                      //\n////////////////////////////////////////////////////////////////\n\n/**\n * @notice Thrown when a function that is protected by the `onlyOwner` modifier\n *          is called from an account other than the owner.\n */\nerror NotOwner();\n"
    },
    "contracts/libraries/DisputeTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n * @notice A custom type for a generic hash.\n */\ntype Hash is bytes32;\n\n/**\n * @notice A claim represents an MPT root representing the state of the fault proof program.\n */\ntype Claim is bytes32;\n\n/**\n * @notice A claim hash represents a hash of a claim and a position within the game tree.\n * @dev Keccak hash of abi.encodePacked(Claim, Position);\n */\ntype ClaimHash is bytes32;\n\n/**\n * @notice A bondamount represents the amount of collateral that a user has locked up in a claim.\n */\ntype BondAmount is uint256;\n\n/**\n * @notice A dedicated timestamp type.\n */\ntype Timestamp is uint64;\n\n/**\n * @notice A dedicated duration type.\n * @dev Unit: seconds\n */\ntype Duration is uint64;\n\n/**\n * @notice A `Clock` represents a packed `Duration` and `Timestamp`\n * @dev The packed layout of this type is as follows:\n * ┌────────────┬────────────────┐\n * │    Bits    │     Value      │\n * ├────────────┼────────────────┤\n * │ [0, 128)   │ Duration       │\n * │ [128, 256) │ Timestamp      │\n * └────────────┴────────────────┘\n */\ntype Clock is uint256;\n\n/**\n * @notice A `Position` represents a position of a claim within the game tree.\n * @dev The packed layout of this type is as follows:\n * ┌────────────┬────────────────┐\n * │    Bits    │     Value      │\n * ├────────────┼────────────────┤\n * │ [0, 128)   │ Depth          │\n * │ [128, 256) │ Index at depth │\n * └────────────┴────────────────┘\n */\ntype Position is uint256;\n\n/**\n * @notice The current status of the dispute game.\n */\nenum GameStatus {\n    // The game is currently in progress, and has not been resolved.\n    IN_PROGRESS,\n    // The game has concluded, and the `rootClaim` was challenged successfully.\n    CHALLENGER_WINS,\n    // The game has concluded, and the `rootClaim` could not be contested.\n    DEFENDER_WINS\n}\n\n/**\n * @notice The type of proof system being used.\n */\nenum GameType {\n    // The game will use a `IDisputeGame` implementation that utilizes fault proofs.\n    FAULT,\n    // The game will use a `IDisputeGame` implementation that utilizes validity proofs.\n    VALIDITY,\n    // The game will use a `IDisputeGame` implementation that utilizes attestation proofs.\n    ATTESTATION\n}\n"
    },
    "contracts/libraries/Encoding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Types } from \"./Types.sol\";\nimport { Hashing } from \"./Hashing.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/**\n * @title Encoding\n * @notice Encoding handles Optimism's various different encoding schemes.\n */\nlibrary Encoding {\n    /**\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\n     *\n     * @param _tx User deposit transaction to encode.\n     *\n     * @return RLP encoded L2 deposit transaction.\n     */\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](8);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mint);\n        raw[4] = RLPWriter.writeUint(_tx.value);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBool(false);\n        raw[7] = RLPWriter.writeBytes(_tx.data);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.\n     *\n     * @param _target Address of the target of the message.\n     * @param _sender Address of the sender of the message.\n     * @param _data   Data to send with the message.\n     * @param _nonce  Message nonce.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _data,\n                _nonce\n            );\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V1 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Adds a version number into the first two bytes of a message nonce.\n     *\n     * @param _nonce   Message nonce to encode into.\n     * @param _version Version number to encode into the message nonce.\n     *\n     * @return Message nonce with version encoded into the first two bytes.\n     */\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /**\n     * @notice Pulls the version out of a version-encoded nonce.\n     *\n     * @param _nonce Message nonce with version encoded into the first two bytes.\n     *\n     * @return Nonce without encoded version.\n     * @return Version of the message.\n     */\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n}\n"
    },
    "contracts/libraries/Hashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Types } from \"./Types.sol\";\nimport { Encoding } from \"./Encoding.sol\";\n\n/**\n * @title Hashing\n * @notice Hashing handles Optimism's various different hashing schemes.\n */\nlibrary Hashing {\n    /**\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\n     *         system.\n     *\n     * @param _tx User deposit transaction to hash.\n     *\n     * @return Hash of the RLP encoded L2 deposit transaction.\n     */\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\n    }\n\n    /**\n     * @notice Computes the deposit transaction's \"source hash\", a value that guarantees the hash\n     *         of the L2 transaction that corresponds to a deposit is unique and is\n     *         deterministically generated from L1 transaction data.\n     *\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\n     * @param _logIndex    The index of the log that created the deposit transaction.\n     *\n     * @return Hash of the deposit transaction's \"source hash\".\n     */\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice Hashes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Hashing: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V0 (legacy) encoding.\n     *\n     * @param _target Address of the target of the message.\n     * @param _sender Address of the sender of the message.\n     * @param _data   Data to send with the message.\n     * @param _nonce  Message nonce.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes32) {\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V1 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                Encoding.encodeCrossDomainMessageV1(\n                    _nonce,\n                    _sender,\n                    _target,\n                    _value,\n                    _gasLimit,\n                    _data\n                )\n            );\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     *\n     * @param _tx Withdrawal transaction to hash.\n     *\n     * @return Hashed withdrawal transaction.\n     */\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)\n            );\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid.\n     *\n     * @param _outputRootProof Output root proof which should hash to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.messagePasserStorageRoot,\n                    _outputRootProof.latestBlockhash\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/LegacyCrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// Importing from the legacy contracts package causes issues with the build of the contract bindings\n// so we just copy the library here from\n// /packages/contracts/contracts/libraries/bridge/Lib_CrossDomainUtils.sol at commit\n// 7866168c\n/**\n * @title LegacyCrossDomainUtils\n */\nlibrary LegacyCrossDomainUtils {\n    /**\n     * Generates the correct cross domain calldata for a message.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @return ABI encoded cross domain calldata.\n     */\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _message,\n                _messageNonce\n            );\n    }\n}\n"
    },
    "contracts/libraries/Predeploys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Predeploys\n * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\n */\nlibrary Predeploys {\n    /**\n     * @notice Address of the L2ToL1MessagePasser predeploy.\n     */\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\n\n    /**\n     * @notice Address of the L2CrossDomainMessenger predeploy.\n     */\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n\n    /**\n     * @notice Address of the L2StandardBridge predeploy.\n     */\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n\n    /**\n     * @notice Address of the L2ERC721Bridge predeploy.\n     */\n    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\n\n    /**\n     * @notice Address of the SequencerFeeWallet predeploy.\n     */\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n\n    /**\n     * @notice Address of the OptimismMintableERC20Factory predeploy.\n     */\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY =\n        0x4200000000000000000000000000000000000012;\n\n    /**\n     * @notice Address of the OptimismMintableERC721Factory predeploy.\n     */\n    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY =\n        0x4200000000000000000000000000000000000017;\n\n    /**\n     * @notice Address of the L1Block predeploy.\n     */\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\n\n    /**\n     * @notice Address of the GasPriceOracle predeploy. Includes fee information\n     *         and helpers for computing the L1 portion of the transaction fee.\n     */\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\n     *         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\n     */\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the DeployerWhitelist predeploy. No longer active.\n     */\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\n     *         state trie as of the Bedrock upgrade. Contract has been locked and write functions\n     *         can no longer be accessed.\n     */\n    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\n     *         instead, which exposes more information about the L1 state.\n     */\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\n     *         L2ToL1MessagePasser contract instead.\n     */\n    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n\n    /**\n     * @notice Address of the ProxyAdmin predeploy.\n     */\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\n\n    /**\n     * @notice Address of the BaseFeeVault predeploy.\n     */\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\n\n    /**\n     * @notice Address of the L1FeeVault predeploy.\n     */\n    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\n\n    /**\n     * @notice Address of the GovernanceToken predeploy.\n     */\n    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\n}\n"
    },
    "contracts/libraries/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title SafeCall\n * @notice Perform low level safe calls\n */\nlibrary SafeCall {\n    /**\n     * @notice Performs a low level call without copying any returndata.\n     * @dev Passes no calldata to the call context.\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     */\n    function send(\n        address _target,\n        uint256 _gas,\n        uint256 _value\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                0, // inloc\n                0, // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n\n    /**\n     * @notice Helper function to determine if there is sufficient gas remaining within the context\n     *         to guarantee that the minimum gas requirement for a call will be met as well as\n     *         optionally reserving a specified amount of gas for after the call has concluded.\n     * @param _minGas      The minimum amount of gas that may be passed to the target context.\n     * @param _reservedGas Optional amount of gas to reserve for the caller after the execution\n     *                     of the target context.\n     * @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\n     *         context as well as reserve `_reservedGas` for the caller after the execution of\n     *         the target context.\n     * @dev !!!!! FOOTGUN ALERT !!!!!\n     *      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\n     *          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\n     *          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\n     *          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\n     *          that does not account for the `memory_expansion_cost` & `code_execution_cost`\n     *          factors of the dynamic cost of the `CALL` opcode.\n     *      2.) This function should *directly* precede the external call if possible. There is an\n     *          added buffer to account for gas consumed between this check and the call, but it\n     *          is only 5,700 gas.\n     *      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\n     *          frame may be passed to a subcontext, we need to ensure that the gas will not be\n     *          truncated.\n     *      4.) Use wisely. This function is not a silver bullet.\n     */\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\n        bool _hasMinGas;\n        assembly {\n            // Equation: gas × 63 ≥ minGas × 64 + 63(40_000 + reservedGas)\n            _hasMinGas := iszero(\n                lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63)))\n            )\n        }\n        return _hasMinGas;\n    }\n\n    /**\n     * @notice Perform a low level call without copying any returndata. This function\n     *         will revert if the call cannot be performed with the specified minimum\n     *         gas.\n     *\n     * @param _target   Address to call\n     * @param _minGas   The minimum amount of gas that may be passed to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function callWithMinGas(\n        address _target,\n        uint256 _minGas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        bool _hasMinGas = hasMinGas(_minGas, 0);\n        assembly {\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\n            if iszero(_hasMinGas) {\n                // Store the \"Error(string)\" selector in scratch space.\n                mstore(0, 0x08c379a0)\n                // Store the pointer to the string length in scratch space.\n                mstore(32, 32)\n                // Store the string.\n                //\n                // SAFETY:\n                // - We pad the beginning of the string with two zero bytes as well as the\n                // length (24) to ensure that we override the free memory pointer at offset\n                // 0x40. This is necessary because the free memory pointer is likely to\n                // be greater than 1 byte when this function is called, but it is incredibly\n                // unlikely that it will be greater than 3 bytes. As for the data within\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\n                // - It's fine to clobber the free memory pointer, we're reverting.\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\n\n                // Revert with 'Error(\"SafeCall: Not enough gas\")'\n                revert(28, 100)\n            }\n\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\n            // above assertion. This ensures that, in all circumstances (except for when the\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\n            // the minimum amount of gas specified.\n            _success := call(\n                gas(), // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0x00, // outloc\n                0x00 // outlen\n            )\n        }\n        return _success;\n    }\n}\n"
    },
    "contracts/libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Types\n * @notice Contains various types used throughout the Optimism contract system.\n */\nlibrary Types {\n    /**\n     * @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\n     *         timestamp that the output root is posted. This timestamp is used to verify that the\n     *         finalization period has passed since the output root was submitted.\n     *\n     * @custom:field outputRoot    Hash of the L2 output.\n     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\n     * @custom:field l2BlockNumber L2 block number that the output corresponds to.\n     */\n    struct OutputProposal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2BlockNumber;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate an output root\n     *         which itself represents a snapshot of the L2 state.\n     *\n     * @custom:field version                  Version of the output root.\n     * @custom:field stateRoot                Root of the state trie at the block of this output.\n     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.\n     * @custom:field latestBlockhash          Hash of the block this output was generated from.\n     */\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    /**\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\n     *         user (as opposed to a system deposit transaction generated by the system).\n     *\n     * @custom:field from        Address of the sender of the transaction.\n     * @custom:field to          Address of the recipient of the transaction.\n     * @custom:field isCreation  True if the transaction is a contract creation.\n     * @custom:field value       Value to send to the recipient.\n     * @custom:field mint        Amount of ETH to mint.\n     * @custom:field gasLimit    Gas limit of the transaction.\n     * @custom:field data        Data of the transaction.\n     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.\n     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.\n     */\n    struct UserDepositTransaction {\n        address from;\n        address to;\n        bool isCreation;\n        uint256 value;\n        uint256 mint;\n        uint64 gasLimit;\n        bytes data;\n        bytes32 l1BlockHash;\n        uint256 logIndex;\n    }\n\n    /**\n     * @notice Struct representing a withdrawal transaction.\n     *\n     * @custom:field nonce    Nonce of the withdrawal transaction\n     * @custom:field sender   Address of the sender of the transaction.\n     * @custom:field target   Address of the recipient of the transaction.\n     * @custom:field value    Value to send to the recipient.\n     * @custom:field gasLimit Gas limit of the transaction.\n     * @custom:field data     Data of the transaction.\n     */\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/**\n * @custom:attribution https://github.com/hamdiallam/Solidity-RLP\n * @title RLPReader\n * @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\n *         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\n *         various tweaks to improve readability.\n */\nlibrary RLPReader {\n    /**\n     * Custom pointer type to avoid confusion between pointers and uint256s.\n     */\n    type MemoryPointer is uint256;\n\n    /**\n     * @notice RLP item types.\n     *\n     * @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\n     * @custom:value LIST_ITEM Represents an RLP list item.\n     */\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /**\n     * @notice Struct representing an RLP item.\n     *\n     * @custom:field length Length of the RLP item.\n     * @custom:field ptr    Pointer to the RLP item in memory.\n     */\n    struct RLPItem {\n        uint256 length;\n        MemoryPointer ptr;\n    }\n\n    /**\n     * @notice Max list length that this library will accept.\n     */\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /**\n     * @notice Converts bytes to a reference to memory position and length.\n     *\n     * @param _in Input bytes to convert.\n     *\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        // Empty arrays are not RLP items.\n        require(\n            _in.length > 0,\n            \"RLPReader: length of an RLP item must be greater than zero to be decodable\"\n        );\n\n        MemoryPointer ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * @notice Reads an RLP list value into a list of RLP items.\n     *\n     * @param _in RLP list value.\n     *\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.LIST_ITEM,\n            \"RLPReader: decoded item type for list is not a list item\"\n        );\n\n        require(\n            listOffset + listLength == _in.length,\n            \"RLPReader: list item has an invalid data remainder\"\n        );\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({\n                    length: _in.length - offset,\n                    ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\n                })\n            );\n\n            // We don't need to check itemCount < out.length explicitly because Solidity already\n            // handles this check on our behalf, we'd just be wasting gas.\n            out[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * @notice Reads an RLP list value into a list of RLP items.\n     *\n     * @param _in RLP list value.\n     *\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP bytes value into bytes.\n     *\n     * @param _in RLP bytes value.\n     *\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"RLPReader: decoded item type for bytes is not a data item\"\n        );\n\n        require(\n            _in.length == itemOffset + itemLength,\n            \"RLPReader: bytes value contains an invalid remainder\"\n        );\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * @notice Reads an RLP bytes value into bytes.\n     *\n     * @param _in RLP bytes value.\n     *\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads the raw bytes of an RLP item.\n     *\n     * @param _in RLP item to read.\n     *\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n\n    /**\n     * @notice Decodes the length of an RLP item.\n     *\n     * @param _in RLP item to decode.\n     *\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        // Short-circuit if there's nothing to decode, note that we perform this check when\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\n        // that function and create an RLP item directly. So we need to check this anyway.\n        require(\n            _in.length > 0,\n            \"RLPReader: length of an RLP item must be greater than zero to be decodable\"\n        );\n\n        MemoryPointer ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(\n                _in.length > strLen,\n                \"RLPReader: length of content must be greater than string length (short string)\"\n            );\n\n            bytes1 firstByteOfContent;\n            assembly {\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\n            }\n\n            require(\n                strLen != 1 || firstByteOfContent >= 0x80,\n                \"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"RLPReader: length of content must be > than length of string length (long string)\"\n            );\n\n            bytes1 firstByteOfContent;\n            assembly {\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\n            }\n\n            require(\n                firstByteOfContent != 0x00,\n                \"RLPReader: length of content must not have any leading zeros (long string)\"\n            );\n\n            uint256 strLen;\n            assembly {\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\n            }\n\n            require(\n                strLen > 55,\n                \"RLPReader: length of content must be greater than 55 bytes (long string)\"\n            );\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"RLPReader: length of content must be greater than total length (long string)\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(\n                _in.length > listLen,\n                \"RLPReader: length of content must be greater than list length (short list)\"\n            );\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"RLPReader: length of content must be > than length of list length (long list)\"\n            );\n\n            bytes1 firstByteOfContent;\n            assembly {\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\n            }\n\n            require(\n                firstByteOfContent != 0x00,\n                \"RLPReader: length of content must not have any leading zeros (long list)\"\n            );\n\n            uint256 listLen;\n            assembly {\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\n            }\n\n            require(\n                listLen > 55,\n                \"RLPReader: length of content must be greater than 55 bytes (long list)\"\n            );\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"RLPReader: length of content must be greater than total length (long list)\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * @notice Copies the bytes from a memory location.\n     *\n     * @param _src    Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     *\n     * @return Copied bytes.\n     */\n    function _copy(\n        MemoryPointer _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {\n        bytes memory out = new bytes(_length);\n        if (_length == 0) {\n            return out;\n        }\n\n        // Mostly based on Solidity's copy_memory_to_memory:\n        // solhint-disable max-line-length\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\n        assembly {\n            let dest := add(out, 32)\n            let i := 0\n            for {\n\n            } lt(i, _length) {\n                i := add(i, 32)\n            } {\n                mstore(add(dest, i), mload(add(src, i)))\n            }\n\n            if gt(i, _length) {\n                mstore(add(dest, _length), 0)\n            }\n        }\n\n        return out;\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/libraries/trie/MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Bytes } from \"../Bytes.sol\";\nimport { RLPReader } from \"../rlp/RLPReader.sol\";\n\n/**\n * @title MerkleTrie\n * @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\n *         inclusion proofs. By default, this library assumes a hexary trie. One can change the\n *         trie radix constant to support other trie radixes.\n */\nlibrary MerkleTrie {\n    /**\n     * @notice Struct representing a node in the trie.\n     *\n     * @custom:field encoded The RLP-encoded node.\n     * @custom:field decoded The RLP-decoded node.\n     */\n    struct TrieNode {\n        bytes encoded;\n        RLPReader.RLPItem[] decoded;\n    }\n\n    /**\n     * @notice Determines the number of elements per branch node.\n     */\n    uint256 internal constant TREE_RADIX = 16;\n\n    /**\n     * @notice Branch nodes have TREE_RADIX elements and one value element.\n     */\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n\n    /**\n     * @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\n     */\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    /**\n     * @notice Prefix for even-nibbled extension node paths.\n     */\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\n\n    /**\n     * @notice Prefix for odd-nibbled extension node paths.\n     */\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\n\n    /**\n     * @notice Prefix for even-nibbled leaf node paths.\n     */\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\n\n    /**\n     * @notice Prefix for odd-nibbled leaf node paths.\n     */\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\n     *\n     * @param _key   Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\n     *               nodes that make a path down to the target node.\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\n     *               correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool) {\n        return Bytes.equal(_value, get(_key, _proof, _root));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key   Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root  Known root of the Merkle trie.\n     *\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        require(_key.length > 0, \"MerkleTrie: empty key\");\n\n        TrieNode[] memory proof = _parseProof(_proof);\n        bytes memory key = Bytes.toNibbles(_key);\n        bytes memory currentNodeID = abi.encodePacked(_root);\n        uint256 currentKeyIndex = 0;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < proof.length; i++) {\n            TrieNode memory currentNode = proof[i];\n\n            // Key index should never exceed total key length or we'll be out of bounds.\n            require(\n                currentKeyIndex <= key.length,\n                \"MerkleTrie: key index exceeds total key length\"\n            );\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\n                    \"MerkleTrie: invalid root hash\"\n                );\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\n                    \"MerkleTrie: invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 32 bytes aren't hashed.\n                require(\n                    Bytes.equal(currentNode.encoded, currentNodeID),\n                    \"MerkleTrie: invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // Value is the last element of the decoded list (for branch nodes). There's\n                    // some ambiguity in the Merkle trie specification because bytes(0) is a\n                    // valid value to place into the trie, but for branch nodes bytes(0) can exist\n                    // even when the value wasn't explicitly placed there. Geth treats a value of\n                    // bytes(0) as \"key does not exist\" and so we do the same.\n                    bytes memory value = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);\n                    require(\n                        value.length > 0,\n                        \"MerkleTrie: value length must be greater than zero (branch)\"\n                    );\n\n                    // Extra proof elements are not allowed.\n                    require(\n                        i == proof.length - 1,\n                        \"MerkleTrie: value node must be last node in proof (branch)\"\n                    );\n\n                    return value;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIndex += 1;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - (prefix % 2);\n                bytes memory pathRemainder = Bytes.slice(path, offset);\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                // Whether this is a leaf node or an extension node, the path remainder MUST be a\n                // prefix of the key remainder (or be equal to the key remainder) or the proof is\n                // considered invalid.\n                require(\n                    pathRemainder.length == sharedNibbleLength,\n                    \"MerkleTrie: path remainder must share all nibbles with key\"\n                );\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,\n                    // the key remainder must be exactly equal to the path remainder. We already\n                    // did the necessary byte comparison, so it's more efficient here to check that\n                    // the key remainder length equals the shared nibble length, which implies\n                    // equality with the path remainder (since we already did the same check with\n                    // the path remainder and the shared nibble length).\n                    require(\n                        keyRemainder.length == sharedNibbleLength,\n                        \"MerkleTrie: key remainder must be identical to path remainder\"\n                    );\n\n                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum\n                    // state trie. Empty values are not allowed in the state trie, so we can safely\n                    // say that if the value is empty, the key should not exist and the proof is\n                    // invalid.\n                    bytes memory value = RLPReader.readBytes(currentNode.decoded[1]);\n                    require(\n                        value.length > 0,\n                        \"MerkleTrie: value length must be greater than zero (leaf)\"\n                    );\n\n                    // Extra proof elements are not allowed.\n                    require(\n                        i == proof.length - 1,\n                        \"MerkleTrie: value node must be last node in proof (leaf)\"\n                    );\n\n                    return value;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node\n                    // in the proof and increment the key index by the length of the path remainder\n                    // which is equal to the shared nibble length.\n                    currentNodeID = _getNodeID(currentNode.decoded[1]);\n                    currentKeyIndex += sharedNibbleLength;\n                } else {\n                    revert(\"MerkleTrie: received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"MerkleTrie: received an unparseable node\");\n            }\n        }\n\n        revert(\"MerkleTrie: ran out of proof elements\");\n    }\n\n    /**\n     * @notice Parses an array of proof elements into a new array that contains both the original\n     *         encoded element and the RLP-decoded element.\n     *\n     * @param _proof Array of proof elements to parse.\n     *\n     * @return Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory) {\n        uint256 length = _proof.length;\n        TrieNode[] memory proof = new TrieNode[](length);\n        for (uint256 i = 0; i < length; ) {\n            proof[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\n            unchecked {\n                ++i;\n            }\n        }\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the \"hash\" within the\n     *         specification, but nodes < 32 bytes are not actually hashed.\n     *\n     * @param _node Node to pull an ID for.\n     *\n     * @return ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory) {\n        return _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     *\n     * @param _node Node to get a path for.\n     *\n     * @return Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory) {\n        return Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two nibble arrays.\n     *\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     *\n     * @return Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 shared;\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\n        for (; shared < max && _a[shared] == _b[shared]; ) {\n            unchecked {\n                ++shared;\n            }\n        }\n        return shared;\n    }\n}\n"
    },
    "contracts/libraries/trie/SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* Library Imports */\nimport { MerkleTrie } from \"./MerkleTrie.sol\";\n\n/**\n * @title SecureMerkleTrie\n * @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\n *         keys. Ethereum's state trie hashes input keys before storing them.\n */\nlibrary SecureMerkleTrie {\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\n     *\n     * @param _key   Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\n     *               nodes that make a path down to the target node.\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\n     *               correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool) {\n        bytes memory key = _getSecureKey(_key);\n        return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key   Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root  Known root of the Merkle trie.\n     *\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        bytes memory key = _getSecureKey(_key);\n        return MerkleTrie.get(key, _proof, _root);\n    }\n\n    /**\n     * @notice Computes the hashed version of the input key.\n     *\n     * @param _key Key to hash.\n     *\n     * @return Hashed version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory) {\n        return abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "contracts/periphery/TransferOnion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title  TransferOnion\n * @notice TransferOnion is a hash onion for distributing tokens. The shell commits\n *         to an ordered list of the token transfers and can be permissionlessly\n *         unwrapped in order. The SENDER must `approve` this contract as\n *         `transferFrom` is used to move the token balances.\n */\ncontract TransferOnion is ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    /**\n     * @notice Struct representing a layer of the onion.\n     */\n    struct Layer {\n        address recipient;\n        uint256 amount;\n        bytes32 shell;\n    }\n\n    /**\n     * @notice Address of the token to distribute.\n     */\n    ERC20 public immutable TOKEN;\n\n    /**\n     * @notice Address of the account to distribute tokens from.\n     */\n    address public immutable SENDER;\n\n    /**\n     * @notice Current shell hash.\n     */\n    bytes32 public shell;\n\n    /**\n     * @param _token  Address of the token to distribute.\n     * @param _sender Address of the sender to distribute from.\n     * @param _shell  Initial shell of the onion.\n     */\n    constructor(\n        ERC20 _token,\n        address _sender,\n        bytes32 _shell\n    ) {\n        TOKEN = _token;\n        SENDER = _sender;\n        shell = _shell;\n    }\n\n    /**\n     * @notice Peels layers from the onion and distributes tokens.\n     *\n     * @param _layers Array of onion layers to peel.\n     */\n    function peel(Layer[] memory _layers) public nonReentrant {\n        bytes32 tempShell = shell;\n        uint256 length = _layers.length;\n        for (uint256 i = 0; i < length; ) {\n            Layer memory layer = _layers[i];\n\n            // Confirm that the onion layer is correct.\n            require(\n                keccak256(abi.encode(layer.recipient, layer.amount, layer.shell)) == tempShell,\n                \"TransferOnion: what are you doing in my swamp?\"\n            );\n\n            // Update the onion layer.\n            tempShell = layer.shell;\n\n            // Transfer the tokens.\n            TOKEN.safeTransferFrom(SENDER, layer.recipient, layer.amount);\n\n            // Unchecked increment to save some gas.\n            unchecked {\n                ++i;\n            }\n        }\n\n        shell = tempShell;\n    }\n}\n"
    },
    "contracts/test/AddressAliasHelper.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract AddressAliasHelper_applyAndUndo_Test is Test {\n    /**\n     * @notice Tests that applying and then undoing an alias results in the original address.\n     */\n    function testFuzz_applyAndUndo_succeeds(address _address) external {\n        address aliased = AddressAliasHelper.applyL1ToL2Alias(_address);\n        address unaliased = AddressAliasHelper.undoL1ToL2Alias(aliased);\n        assertEq(_address, unaliased);\n    }\n}\n"
    },
    "contracts/test/BenchmarkTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\nimport \"./CommonTest.t.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\n// Free function for setting the prevBaseFee param in the OptimismPortal.\nfunction setPrevBaseFee(\n    Vm _vm,\n    address _op,\n    uint128 _prevBaseFee\n) {\n    _vm.store(address(_op), bytes32(uint256(1)), bytes32((block.number << 192) | _prevBaseFee));\n}\n\ncontract SetPrevBaseFee_Test is Portal_Initializer {\n    function test_setPrevBaseFee_succeeds() external {\n        setPrevBaseFee(vm, address(op), 100 gwei);\n        (uint128 prevBaseFee, , uint64 prevBlockNum) = op.params();\n        assertEq(uint256(prevBaseFee), 100 gwei);\n        assertEq(uint256(prevBlockNum), block.number);\n    }\n}\n\n// Tests for obtaining pure gas cost estimates for commonly used functions.\n// The objective with these benchmarks is to strip down the actual test functions\n// so that they are nothing more than the call we want measure the gas cost of.\n// In order to achieve this we make no assertions, and handle everything else in the setUp()\n// function.\ncontract GasBenchMark_OptimismPortal is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _proposedOutputIndex;\n    uint256 _proposedBlockNumber;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n    bytes32 _outputRoot;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n\n        // Get withdrawal proof data we can use for testing.\n        bytes32 _storageRoot;\n        bytes32 _stateRoot;\n        (_stateRoot, _storageRoot, _outputRoot, , _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _proposedBlockNumber = oracle.nextBlockNumber();\n        _proposedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public virtual override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_proposedBlockNumber) + 1);\n        vm.prank(oracle.PROPOSER());\n        oracle.proposeL2Output(_outputRoot, _proposedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've proposed.\n        vm.warp(\n            oracle.getL2Output(_proposedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(op), 0xFFFFFFFF);\n    }\n\n    function test_depositTransaction_benchmark() external {\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_depositTransaction_benchmark_1() external {\n        setPrevBaseFee(vm, address(op), 1 gwei);\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_proveWithdrawalTransaction_benchmark() external {\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n}\n\ncontract GasBenchMark_L1CrossDomainMessenger is Messenger_Initializer {\n    function test_sendMessage_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(op), 1 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n\n    function test_sendMessage_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(op), 10 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Deposit is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), alice, 100000, true);\n        vm.startPrank(alice, alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n    }\n\n    function test_depositETH_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(op), 1 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositETH_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(op), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositERC20_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(op), 1 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n\n    function test_depositERC20_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(op), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Finalize is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), address(L1Bridge), 100, true);\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.startPrank(address(L1Bridge.messenger()));\n        vm.deal(address(L1Bridge.messenger()), 100);\n    }\n\n    function test_finalizeETHWithdrawal_benchmark() external {\n        // TODO: Make this more accurate. It is underestimating the cost because it pranks\n        // the call coming from the messenger, which bypasses the portal\n        // and oracle.\n        L1Bridge.finalizeETHWithdrawal{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract GasBenchMark_L2OutputOracle is L2OutputOracle_Initializer {\n    uint256 nextBlockNumber;\n\n    function setUp() public override {\n        super.setUp();\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.startPrank(proposer);\n    }\n\n    function test_proposeL2Output_benchmark() external {\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n}\n"
    },
    "contracts/test/BondManager.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../libraries/DisputeTypes.sol\";\n\nimport { IDisputeGame } from \"../dispute/IDisputeGame.sol\";\nimport { IBondManager } from \"../dispute/IBondManager.sol\";\n\nimport { DisputeGameFactory } from \"../dispute/DisputeGameFactory.sol\";\n\nimport { BondManager } from \"../dispute/BondManager.sol\";\n\ncontract BondManager_Test is Test {\n    DisputeGameFactory factory;\n    BondManager bm;\n\n    // DisputeGameFactory events\n    event DisputeGameCreated(\n        address indexed disputeProxy,\n        GameType indexed gameType,\n        Claim indexed rootClaim\n    );\n\n    // BondManager events\n    event BondPosted(bytes32 bondId, address owner, uint256 expiration, uint256 amount);\n    event BondSeized(bytes32 bondId, address owner, address seizer, uint256 amount);\n    event BondReclaimed(bytes32 bondId, address claiment, uint256 amount);\n\n    function setUp() public {\n        factory = new DisputeGameFactory(address(this));\n        bm = new BondManager(factory);\n    }\n\n    /**\n     * -------------------------------------------\n     * Test Bond Posting\n     * -------------------------------------------\n     */\n\n    /**\n     * @notice Tests that posting a bond succeeds.\n     */\n    function testFuzz_post_succeeds(\n        bytes32 bondId,\n        address owner,\n        uint256 minClaimHold,\n        uint256 amount\n    ) public {\n        vm.assume(owner != address(0));\n        vm.assume(owner != address(bm));\n        vm.assume(owner != address(this));\n        // Create2Deployer\n        vm.assume(owner != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        vm.assume(amount != 0);\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold > minClaimHold);\n        }\n\n        vm.deal(address(this), amount);\n\n        vm.expectEmit(true, true, true, true);\n        uint256 expiration = block.timestamp + minClaimHold;\n        emit BondPosted(bondId, owner, expiration, amount);\n\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n\n        // Validate the bond\n        (\n            address newFetchedOwner,\n            uint256 fetchedExpiration,\n            bytes32 fetchedBondId,\n            uint256 bondAmount\n        ) = bm.bonds(bondId);\n        assertEq(newFetchedOwner, owner);\n        assertEq(fetchedExpiration, block.timestamp + minClaimHold);\n        assertEq(fetchedBondId, bondId);\n        assertEq(bondAmount, amount);\n    }\n\n    /**\n     * @notice Tests that posting a bond with the same id twice reverts.\n     */\n    function testFuzz_post_duplicates_reverts(\n        bytes32 bondId,\n        address owner,\n        uint256 minClaimHold,\n        uint256 amount\n    ) public {\n        vm.assume(owner != address(0));\n        amount = amount / 2;\n        vm.assume(amount != 0);\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold > minClaimHold);\n        }\n\n        vm.deal(address(this), amount);\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n\n        vm.deal(address(this), amount);\n        vm.expectRevert(\"BondManager: BondId already posted.\");\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n    }\n\n    /**\n     * @notice Posting with the zero address as the owner fails.\n     */\n    function testFuzz_post_zeroAddress_reverts(\n        bytes32 bondId,\n        uint256 minClaimHold,\n        uint256 amount\n    ) public {\n        address owner = address(0);\n        vm.deal(address(this), amount);\n        vm.expectRevert(\"BondManager: Owner cannot be the zero address.\");\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n    }\n\n    /**\n     * @notice Posting zero value bonds should revert.\n     */\n    function testFuzz_post_zeroAddress_reverts(\n        bytes32 bondId,\n        address owner,\n        uint256 minClaimHold\n    ) public {\n        vm.assume(owner != address(0));\n        uint256 amount = 0;\n        vm.deal(address(this), amount);\n        vm.expectRevert(\"BondManager: Value must be non-zero.\");\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n    }\n\n    /**\n     * -------------------------------------------\n     * Test Bond Seizing\n     * -------------------------------------------\n     */\n\n    /**\n     * @notice Non-existing bonds shouldn't be seizable.\n     */\n    function testFuzz_seize_missingBond_reverts(bytes32 bondId) public {\n        vm.expectRevert(\"BondManager: The bond does not exist.\");\n        bm.seize(bondId);\n    }\n\n    /**\n     * @notice Bonds that expired cannot be seized.\n     */\n    function testFuzz_seize_expired_reverts(\n        bytes32 bondId,\n        address owner,\n        uint256 minClaimHold,\n        uint256 amount\n    ) public {\n        vm.assume(owner != address(0));\n        vm.assume(owner != address(bm));\n        vm.assume(owner != address(this));\n        vm.assume(amount != 0);\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold + 1 > minClaimHold);\n        }\n        vm.deal(address(this), amount);\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n\n        vm.warp(block.timestamp + minClaimHold + 1);\n        vm.expectRevert(\"BondManager: Bond expired.\");\n        bm.seize(bondId);\n    }\n\n    /**\n     * @notice Bonds cannot be seized by unauthorized parties.\n     */\n    function testFuzz_seize_unauthorized_reverts(\n        bytes32 bondId,\n        address owner,\n        uint256 minClaimHold,\n        uint256 amount\n    ) public {\n        vm.assume(owner != address(0));\n        vm.assume(owner != address(bm));\n        vm.assume(owner != address(this));\n        vm.assume(amount != 0);\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold > minClaimHold);\n        }\n        vm.deal(address(this), amount);\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n\n        MockAttestationDisputeGame game = new MockAttestationDisputeGame();\n        vm.prank(address(game));\n        vm.expectRevert(\"BondManager: Unauthorized seizure.\");\n        bm.seize(bondId);\n    }\n\n    /**\n     * @notice Seizing a bond should succeed if the game resolves.\n     */\n    function testFuzz_seize_succeeds(\n        bytes32 bondId,\n        uint256 minClaimHold,\n        bytes calldata extraData\n    ) public {\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold > minClaimHold);\n        }\n\n        vm.deal(address(this), 1 ether);\n        bm.post{ value: 1 ether }(bondId, address(0xba5ed), minClaimHold);\n\n        // Create a mock dispute game in the factory\n        IDisputeGame proxy;\n        Claim rootClaim;\n        bytes memory ed = extraData;\n        {\n            rootClaim = Claim.wrap(bytes32(\"\"));\n            MockAttestationDisputeGame implementation = new MockAttestationDisputeGame();\n            GameType gt = GameType.ATTESTATION;\n            factory.setImplementation(gt, IDisputeGame(address(implementation)));\n            vm.expectEmit(false, true, true, false);\n            emit DisputeGameCreated(address(0), gt, rootClaim);\n            proxy = factory.create(gt, rootClaim, extraData);\n            assertEq(address(factory.games(gt, rootClaim, extraData)), address(proxy));\n        }\n\n        // Update the game fields\n        MockAttestationDisputeGame spawned = MockAttestationDisputeGame(payable(address(proxy)));\n        spawned.setBondManager(bm);\n        spawned.setRootClaim(rootClaim);\n        spawned.setGameStatus(GameStatus.CHALLENGER_WINS);\n        spawned.setBondId(bondId);\n        spawned.setExtraData(ed);\n\n        // Seize the bond by calling resolve\n        vm.expectEmit(true, true, true, true);\n        emit BondSeized(bondId, address(0xba5ed), address(spawned), 1 ether);\n        spawned.resolve();\n        assertEq(address(spawned).balance, 1 ether);\n\n        // Validate that the bond was deleted\n        (address newFetchedOwner, , , ) = bm.bonds(bondId);\n        assertEq(newFetchedOwner, address(0));\n    }\n\n    /**\n     * -------------------------------------------\n     * Test Bond Split and Seizing\n     * -------------------------------------------\n     */\n\n    /**\n     * @notice Seizing and splitting a bond should succeed if the game resolves.\n     */\n    function testFuzz_seizeAndSplit_succeeds(\n        bytes32 bondId,\n        uint256 minClaimHold,\n        bytes calldata extraData\n    ) public {\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold > minClaimHold);\n        }\n\n        vm.deal(address(this), 1 ether);\n        bm.post{ value: 1 ether }(bondId, address(0xba5ed), minClaimHold);\n\n        // Create a mock dispute game in the factory\n        IDisputeGame proxy;\n        Claim rootClaim;\n        bytes memory ed = extraData;\n        {\n            rootClaim = Claim.wrap(bytes32(\"\"));\n            MockAttestationDisputeGame implementation = new MockAttestationDisputeGame();\n            GameType gt = GameType.ATTESTATION;\n            factory.setImplementation(gt, IDisputeGame(address(implementation)));\n            vm.expectEmit(false, true, true, false);\n            emit DisputeGameCreated(address(0), gt, rootClaim);\n            proxy = factory.create(gt, rootClaim, extraData);\n            assertEq(address(factory.games(gt, rootClaim, extraData)), address(proxy));\n        }\n\n        // Update the game fields\n        MockAttestationDisputeGame spawned = MockAttestationDisputeGame(payable(address(proxy)));\n        spawned.setBondManager(bm);\n        spawned.setRootClaim(rootClaim);\n        spawned.setGameStatus(GameStatus.CHALLENGER_WINS);\n        spawned.setBondId(bondId);\n        spawned.setExtraData(ed);\n\n        // Seize the bond by calling resolve\n        vm.expectEmit(true, true, true, true);\n        emit BondSeized(bondId, address(0xba5ed), address(spawned), 1 ether);\n        spawned.splitResolve();\n        assertEq(address(spawned).balance, 0);\n        address[] memory challengers = spawned.getChallengers();\n        uint256 proportionalAmount = 1 ether / challengers.length;\n        for (uint256 i = 0; i < challengers.length; i++) {\n            assertEq(address(challengers[i]).balance, proportionalAmount);\n        }\n\n        // Validate that the bond was deleted\n        (address newFetchedOwner, , , ) = bm.bonds(bondId);\n        assertEq(newFetchedOwner, address(0));\n    }\n\n    /**\n     * -------------------------------------------\n     * Test Bond Reclaiming\n     * -------------------------------------------\n     */\n\n    /**\n     * @notice Bonds can be reclaimed after the specified amount of time.\n     */\n    function testFuzz_reclaim_succeeds(\n        bytes32 bondId,\n        address owner,\n        uint256 minClaimHold,\n        uint256 amount\n    ) public {\n        vm.assume(owner != address(0));\n        vm.assume(owner.code.length == 0);\n        vm.assume(amount != 0);\n        unchecked {\n            vm.assume(block.timestamp + minClaimHold > minClaimHold);\n        }\n        assumeNoPrecompiles(owner);\n\n        // Post the bond\n        vm.deal(address(this), amount);\n        bm.post{ value: amount }(bondId, owner, minClaimHold);\n\n        // We can't claim if the block.timestamp is less than the bond expiration.\n        (, uint256 expiration, , ) = bm.bonds(bondId);\n        if (expiration > block.timestamp) {\n            vm.prank(owner);\n            vm.expectRevert(\"BondManager: Bond isn't claimable yet.\");\n            bm.reclaim(bondId);\n        }\n\n        // Past expiration, the owner can reclaim\n        vm.warp(expiration);\n        vm.prank(owner);\n        bm.reclaim(bondId);\n        assertEq(owner.balance, amount);\n    }\n}\n\n/**\n * @title MockAttestationDisputeGame\n * @dev A mock dispute game for testing bond seizures.\n */\ncontract MockAttestationDisputeGame is IDisputeGame {\n    GameStatus internal gameStatus;\n    BondManager bm;\n    Claim internal rc;\n    bytes internal ed;\n    bytes32 internal bondId;\n\n    address[] internal challengers;\n\n    function getChallengers() public view returns (address[] memory) {\n        return challengers;\n    }\n\n    function setBondId(bytes32 bid) external {\n        bondId = bid;\n    }\n\n    function setBondManager(BondManager _bm) external {\n        bm = _bm;\n    }\n\n    function setGameStatus(GameStatus _gs) external {\n        gameStatus = _gs;\n    }\n\n    function setRootClaim(Claim _rc) external {\n        rc = _rc;\n    }\n\n    function setExtraData(bytes memory _ed) external {\n        ed = _ed;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function splitResolve() public {\n        challengers = [address(1), address(2)];\n        bm.seizeAndSplit(bondId, challengers);\n    }\n\n    /**\n     * -------------------------------------------\n     * Initializable Functions\n     * -------------------------------------------\n     */\n\n    function initialize() external {\n        /* noop */\n    }\n\n    /**\n     * -------------------------------------------\n     * IVersioned Functions\n     * -------------------------------------------\n     */\n\n    function version() external pure returns (string memory _version) {\n        return \"0.1.0\";\n    }\n\n    /**\n     * -------------------------------------------\n     * IDisputeGame Functions\n     * -------------------------------------------\n     */\n\n    function createdAt() external pure override returns (Timestamp _createdAt) {\n        return Timestamp.wrap(uint64(0));\n    }\n\n    function status() external view override returns (GameStatus _status) {\n        return gameStatus;\n    }\n\n    function gameType() external pure returns (GameType _gameType) {\n        return GameType.ATTESTATION;\n    }\n\n    function rootClaim() external view override returns (Claim _rootClaim) {\n        return rc;\n    }\n\n    function extraData() external view returns (bytes memory _extraData) {\n        return ed;\n    }\n\n    function bondManager() external view override returns (IBondManager _bondManager) {\n        return IBondManager(address(bm));\n    }\n\n    function resolve() external returns (GameStatus _status) {\n        bm.seize(bondId);\n        return gameStatus;\n    }\n}\n"
    },
    "contracts/test/Bytes.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Bytes } from \"../libraries/Bytes.sol\";\n\ncontract Bytes_slice_Test is Test {\n    /**\n     * @notice Tests that the `slice` function works as expected when starting from index 0.\n     */\n    function test_slice_fromZeroIdx_works() public {\n        bytes memory input = hex\"11223344556677889900\";\n\n        // Exhaustively check if all possible slices starting from index 0 are correct.\n        assertEq(Bytes.slice(input, 0, 0), hex\"\");\n        assertEq(Bytes.slice(input, 0, 1), hex\"11\");\n        assertEq(Bytes.slice(input, 0, 2), hex\"1122\");\n        assertEq(Bytes.slice(input, 0, 3), hex\"112233\");\n        assertEq(Bytes.slice(input, 0, 4), hex\"11223344\");\n        assertEq(Bytes.slice(input, 0, 5), hex\"1122334455\");\n        assertEq(Bytes.slice(input, 0, 6), hex\"112233445566\");\n        assertEq(Bytes.slice(input, 0, 7), hex\"11223344556677\");\n        assertEq(Bytes.slice(input, 0, 8), hex\"1122334455667788\");\n        assertEq(Bytes.slice(input, 0, 9), hex\"112233445566778899\");\n        assertEq(Bytes.slice(input, 0, 10), hex\"11223344556677889900\");\n    }\n\n    /**\n     * @notice Tests that the `slice` function works as expected when starting from indices [1, 9]\n     *         with lengths [1, 9], in reverse order.\n     */\n    function test_slice_fromNonZeroIdx_works() public {\n        bytes memory input = hex\"11223344556677889900\";\n\n        // Exhaustively check correctness of slices starting from indexes [1, 9]\n        // and spanning [1, 9] bytes, in reverse order\n        assertEq(Bytes.slice(input, 9, 1), hex\"00\");\n        assertEq(Bytes.slice(input, 8, 2), hex\"9900\");\n        assertEq(Bytes.slice(input, 7, 3), hex\"889900\");\n        assertEq(Bytes.slice(input, 6, 4), hex\"77889900\");\n        assertEq(Bytes.slice(input, 5, 5), hex\"6677889900\");\n        assertEq(Bytes.slice(input, 4, 6), hex\"556677889900\");\n        assertEq(Bytes.slice(input, 3, 7), hex\"44556677889900\");\n        assertEq(Bytes.slice(input, 2, 8), hex\"3344556677889900\");\n        assertEq(Bytes.slice(input, 1, 9), hex\"223344556677889900\");\n    }\n\n    /**\n     * @notice Tests that the `slice` function works as expected when slicing between multiple words\n     *         in memory. In this case, we test that a 2 byte slice between the 32nd byte of the\n     *         first word and the 1st byte of the second word is correct.\n     */\n    function test_slice_acrossWords_works() public {\n        bytes\n            memory input = hex\"00000000000000000000000000000000000000000000000000000000000000112200000000000000000000000000000000000000000000000000000000000000\";\n\n        assertEq(Bytes.slice(input, 31, 2), hex\"1122\");\n    }\n\n    /**\n     * @notice Tests that the `slice` function works as expected when slicing between multiple\n     *         words in memory. In this case, we test that a 34 byte slice between 3 separate words\n     *         returns the correct result.\n     */\n    function test_slice_acrossMultipleWords_works() public {\n        bytes\n            memory input = hex\"000000000000000000000000000000000000000000000000000000000000001122FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1100000000000000000000000000000000000000000000000000000000000000\";\n        bytes\n            memory expected = hex\"1122FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF11\";\n\n        assertEq(Bytes.slice(input, 31, 34), expected);\n    }\n\n    /**\n     * @notice Tests that, when given an input bytes array of length `n`, the `slice` function will\n     *         always revert if `_start + _length > n`.\n     */\n    function testFuzz_slice_outOfBounds_reverts(\n        bytes memory _input,\n        uint256 _start,\n        uint256 _length\n    ) public {\n        // We want a valid start index and a length that will not overflow.\n        vm.assume(_start < _input.length && _length < type(uint256).max - 31);\n        // But, we want an invalid slice length.\n        vm.assume(_start + _length > _input.length);\n\n        vm.expectRevert(\"slice_outOfBounds\");\n        Bytes.slice(_input, _start, _length);\n    }\n\n    /**\n     * @notice Tests that, when given a length `n` that is greater than `type(uint256).max - 31`,\n     *         the `slice` function reverts.\n     */\n    function testFuzz_slice_lengthOverflows_reverts(\n        bytes memory _input,\n        uint256 _start,\n        uint256 _length\n    ) public {\n        // Ensure that the `_length` will overflow if a number >= 31 is added to it.\n        vm.assume(_length > type(uint256).max - 31);\n\n        vm.expectRevert(\"slice_overflow\");\n        Bytes.slice(_input, _start, _length);\n    }\n\n    /**\n     * @notice Tests that, when given a start index `n` that is greater than\n     *         `type(uint256).max - n`, the `slice` function reverts.\n     */\n    function testFuzz_slice_rangeOverflows_reverts(\n        bytes memory _input,\n        uint256 _start,\n        uint256 _length\n    ) public {\n        // Ensure that `_length` is a realistic length of a slice. This is to make sure\n        // we revert on the correct require statement.\n        vm.assume(_length < _input.length);\n        // Ensure that `_start` will overflow if `_length` is added to it.\n        vm.assume(_start > type(uint256).max - _length);\n\n        vm.expectRevert(\"slice_overflow\");\n        Bytes.slice(_input, _start, _length);\n    }\n\n    /**\n     * @notice Tests that the `slice` function correctly updates the free memory pointer depending\n     *         on the length of the slice.\n     */\n    function testFuzz_slice_memorySafety_succeeds(\n        bytes memory _input,\n        uint256 _start,\n        uint256 _length\n    ) public {\n        // The start should never be more than the length of the input bytes array - 1\n        vm.assume(_start < _input.length);\n        // The length should never be more than the length of the input bytes array - the starting\n        // slice index.\n        vm.assume(_length <= _input.length - _start);\n\n        // Grab the free memory pointer before the slice operation\n        uint64 initPtr;\n        assembly {\n            initPtr := mload(0x40)\n        }\n        uint64 expectedPtr = uint64(initPtr + 0x20 + ((_length + 0x1f) & ~uint256(0x1f)));\n\n        // Ensure that all memory outside of the expected range is safe.\n        vm.expectSafeMemory(initPtr, expectedPtr);\n\n        // Slice the input bytes array from `_start` to `_start + _length`\n        bytes memory slice = Bytes.slice(_input, _start, _length);\n\n        // Grab the free memory pointer after the slice operation\n        uint64 finalPtr;\n        assembly {\n            finalPtr := mload(0x40)\n        }\n\n        // The free memory pointer should have been updated properly\n        if (_length == 0) {\n            // If the slice length is zero, only 32 bytes of memory should have been allocated.\n            assertEq(finalPtr, initPtr + 0x20);\n        } else {\n            // If the slice length is greater than zero, the memory allocated should be the\n            // length of the slice rounded up to the next 32 byte word + 32 bytes for the\n            // length of the byte array.\n            //\n            // Note that we use a slightly less efficient, but equivalent method of rounding\n            // up `_length` to the next multiple of 32 than is used in the `slice` function.\n            // This is to diff test the method used in `slice`.\n            uint64 _expectedPtr = uint64(initPtr + 0x20 + (((_length + 0x1F) >> 5) << 5));\n            assertEq(finalPtr, _expectedPtr);\n\n            // Sanity check for equivalence of the rounding methods.\n            assertEq(_expectedPtr, expectedPtr);\n        }\n\n        // The slice length should be equal to `_length`\n        assertEq(slice.length, _length);\n    }\n}\n\ncontract Bytes_toNibbles_Test is Test {\n    /**\n     * @notice Diffs the test Solidity version of `toNibbles` against the Yul version.\n     *\n     * @param _bytes The `bytes` array to convert to nibbles.\n     *\n     * @return Yul version of `toNibbles` applied to `_bytes`.\n     */\n    function _toNibblesYul(bytes memory _bytes) internal pure returns (bytes memory) {\n        // Allocate memory for the `nibbles` array.\n        bytes memory nibbles = new bytes(_bytes.length << 1);\n\n        assembly {\n            // Load the length of the passed bytes array from memory\n            let bytesLength := mload(_bytes)\n\n            // Store the memory offset of the _bytes array's contents on the stack\n            let bytesStart := add(_bytes, 0x20)\n\n            // Store the memory offset of the nibbles array's contents on the stack\n            let nibblesStart := add(nibbles, 0x20)\n\n            // Loop through each byte in the input array\n            for {\n                let i := 0x00\n            } lt(i, bytesLength) {\n                i := add(i, 0x01)\n            } {\n                // Get the starting offset of the next 2 bytes in the nibbles array\n                let offset := add(nibblesStart, shl(0x01, i))\n\n                // Load the byte at the current index within the `_bytes` array\n                let b := byte(0x00, mload(add(bytesStart, i)))\n\n                // Pull out the first nibble and store it in the new array\n                mstore8(offset, shr(0x04, b))\n                // Pull out the second nibble and store it in the new array\n                mstore8(add(offset, 0x01), and(b, 0x0F))\n            }\n        }\n\n        return nibbles;\n    }\n\n    /**\n     * @notice Tests that, given an input of 5 bytes, the `toNibbles` function returns an array of\n     *         10 nibbles corresponding to the input data.\n     */\n    function test_toNibbles_expectedResult5Bytes_works() public {\n        bytes memory input = hex\"1234567890\";\n        bytes memory expected = hex\"01020304050607080900\";\n        bytes memory actual = Bytes.toNibbles(input);\n\n        assertEq(input.length * 2, actual.length);\n        assertEq(expected.length, actual.length);\n        assertEq(actual, expected);\n    }\n\n    /**\n     * @notice Tests that, given an input of 128 bytes, the `toNibbles` function returns an array\n     *         of 256 nibbles corresponding to the input data. This test exists to ensure that,\n     *         given a large input, the `toNibbles` function works as expected.\n     */\n    function test_toNibbles_expectedResult128Bytes_works() public {\n        bytes\n            memory input = hex\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\";\n        bytes\n            memory expected = hex\"0000000100020003000400050006000700080009000a000b000c000d000e000f0100010101020103010401050106010701080109010a010b010c010d010e010f0200020102020203020402050206020702080209020a020b020c020d020e020f0300030103020303030403050306030703080309030a030b030c030d030e030f0400040104020403040404050406040704080409040a040b040c040d040e040f0500050105020503050405050506050705080509050a050b050c050d050e050f0600060106020603060406050606060706080609060a060b060c060d060e060f0700070107020703070407050706070707080709070a070b070c070d070e070f\";\n        bytes memory actual = Bytes.toNibbles(input);\n\n        assertEq(input.length * 2, actual.length);\n        assertEq(expected.length, actual.length);\n        assertEq(actual, expected);\n    }\n\n    /**\n     * @notice Tests that, given an input of 0 bytes, the `toNibbles` function returns a zero\n     *         length array.\n     */\n    function test_toNibbles_zeroLengthInput_works() public {\n        bytes memory input = hex\"\";\n        bytes memory expected = hex\"\";\n        bytes memory actual = Bytes.toNibbles(input);\n\n        assertEq(input.length, 0);\n        assertEq(expected.length, 0);\n        assertEq(actual.length, 0);\n        assertEq(actual, expected);\n    }\n\n    /**\n     * @notice Test that the `toNibbles` function in the `Bytes` library is equivalent to the Yul\n     *         implementation.\n     */\n    function testDiff_toNibbles_succeeds(bytes memory _input) public {\n        assertEq(Bytes.toNibbles(_input), _toNibblesYul(_input));\n    }\n}\n\ncontract Bytes_equal_Test is Test {\n    /**\n     * @notice Manually checks equality of two dynamic `bytes` arrays in memory.\n     *\n     * @param _a The first `bytes` array to compare.\n     * @param _b The second `bytes` array to compare.\n     *\n     * @return True if the two `bytes` arrays are equal in memory.\n     */\n    function manualEq(bytes memory _a, bytes memory _b) internal pure returns (bool) {\n        bool _eq;\n        assembly {\n            _eq := and(\n                // Check if the contents of the two bytes arrays are equal in memory.\n                eq(keccak256(add(0x20, _a), mload(_a)), keccak256(add(0x20, _b), mload(_b))),\n                // Check if the length of the two bytes arrays are equal in memory.\n                // This is redundant given the above check, but included for completeness.\n                eq(mload(_a), mload(_b))\n            )\n        }\n        return _eq;\n    }\n\n    /**\n     * @notice Tests that the `equal` function in the `Bytes` library returns `false` if given two\n     *         non-equal byte arrays.\n     */\n    function testFuzz_equal_notEqual_works(bytes memory _a, bytes memory _b) public {\n        vm.assume(!manualEq(_a, _b));\n        assertFalse(Bytes.equal(_a, _b));\n    }\n\n    /**\n     * @notice Test whether or not the `equal` function in the `Bytes` library is equivalent to\n     *         manually checking equality of the two dynamic `bytes` arrays in memory.\n     */\n    function testDiff_equal_works(bytes memory _a, bytes memory _b) public {\n        assertEq(Bytes.equal(_a, _b), manualEq(_a, _b));\n    }\n}\n"
    },
    "contracts/test/CommonTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test, StdUtils } from \"forge-std/Test.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { OptimismMintableERC20Factory } from \"../universal/OptimismMintableERC20Factory.sol\";\nimport { OptimismMintableERC721Factory } from \"../universal/OptimismMintableERC721Factory.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { LegacyERC20ETH } from \"../legacy/LegacyERC20ETH.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ResolvedDelegateProxy } from \"../legacy/ResolvedDelegateProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { IL1ChugSplashDeployer } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { LegacyMintableERC20 } from \"../legacy/LegacyMintableERC20.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract CommonTest is Test {\n    address alice = address(128);\n    address bob = address(256);\n    address multisig = address(512);\n\n    address immutable ZERO_ADDRESS = address(0);\n    address immutable NON_ZERO_ADDRESS = address(1);\n    uint256 immutable NON_ZERO_VALUE = 100;\n    uint256 immutable ZERO_VALUE = 0;\n    uint64 immutable NON_ZERO_GASLIMIT = 50000;\n    bytes32 nonZeroHash = keccak256(abi.encode(\"NON_ZERO\"));\n    bytes NON_ZERO_DATA = hex\"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff0000\";\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    FFIInterface ffi;\n\n    function setUp() public virtual {\n        // Give alice and bob some ETH\n        vm.deal(alice, 1 << 16);\n        vm.deal(bob, 1 << 16);\n        vm.deal(multisig, 1 << 16);\n\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n        vm.label(multisig, \"multisig\");\n\n        // Make sure we have a non-zero base fee\n        vm.fee(1000000000);\n\n        ffi = new FFIInterface();\n    }\n\n    function emitTransactionDeposited(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) internal {\n        emit TransactionDeposited(\n            _from,\n            _to,\n            0,\n            abi.encodePacked(_mint, _value, _gasLimit, _isCreation, _data)\n        );\n    }\n}\n\ncontract L2OutputOracle_Initializer is CommonTest {\n    // Test target\n    L2OutputOracle oracle;\n    L2OutputOracle oracleImpl;\n\n    L2ToL1MessagePasser messagePasser =\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER));\n\n    // Constructor arguments\n    address internal proposer = 0x000000000000000000000000000000000000AbBa;\n    address internal owner = 0x000000000000000000000000000000000000ACDC;\n    uint256 internal submissionInterval = 1800;\n    uint256 internal l2BlockTime = 2;\n    uint256 internal startingBlockNumber = 200;\n    uint256 internal startingTimestamp = 1000;\n    address guardian;\n\n    // Test data\n    uint256 initL1Time;\n\n    event OutputProposed(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\n\n    // Advance the evm's time to meet the L2OutputOracle's requirements for proposeL2Output\n    function warpToProposeTime(uint256 _nextBlockNumber) public {\n        vm.warp(oracle.computeL2Timestamp(_nextBlockNumber) + 1);\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n        guardian = makeAddr(\"guardian\");\n\n        // By default the first block has timestamp and number zero, which will cause underflows in the\n        // tests, so we'll move forward to these block values.\n        initL1Time = startingTimestamp + 1;\n        vm.warp(initL1Time);\n        vm.roll(startingBlockNumber);\n        // Deploy the L2OutputOracle and transfer owernship to the proposer\n        oracleImpl = new L2OutputOracle({\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: startingTimestamp,\n            _proposer: proposer,\n            _challenger: owner,\n            _finalizationPeriodSeconds: 7 days\n        });\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(oracleImpl),\n            abi.encodeCall(L2OutputOracle.initialize, (startingBlockNumber, startingTimestamp))\n        );\n        oracle = L2OutputOracle(address(proxy));\n        vm.label(address(oracle), \"L2OutputOracle\");\n\n        // Set the L2ToL1MessagePasser at the correct address\n        vm.etch(Predeploys.L2_TO_L1_MESSAGE_PASSER, address(new L2ToL1MessagePasser()).code);\n\n        vm.label(Predeploys.L2_TO_L1_MESSAGE_PASSER, \"L2ToL1MessagePasser\");\n    }\n}\n\ncontract Portal_Initializer is L2OutputOracle_Initializer {\n    // Test target\n    OptimismPortal internal opImpl;\n    OptimismPortal internal op;\n    SystemConfig systemConfig;\n\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        ResourceMetering.ResourceConfig memory config = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        systemConfig = new SystemConfig({\n            _owner: address(1),\n            _overhead: 0,\n            _scalar: 10000,\n            _batcherHash: bytes32(0),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(0),\n            _config: config\n        });\n\n        opImpl = new OptimismPortal({\n            _l2Oracle: oracle,\n            _guardian: guardian,\n            _paused: true,\n            _config: systemConfig\n        });\n\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(opImpl),\n            abi.encodeWithSelector(OptimismPortal.initialize.selector, false)\n        );\n        op = OptimismPortal(payable(address(proxy)));\n        vm.label(address(op), \"OptimismPortal\");\n    }\n}\n\ncontract Messenger_Initializer is Portal_Initializer {\n    AddressManager internal addressManager;\n    L1CrossDomainMessenger internal L1Messenger;\n    L2CrossDomainMessenger internal L2Messenger =\n        L2CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event SentMessageExtension1(address indexed sender, uint256 value);\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    event WhatHappened(bool success, bytes returndata);\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the address manager\n        vm.prank(multisig);\n        addressManager = new AddressManager();\n\n        // Setup implementation\n        L1CrossDomainMessenger L1MessengerImpl = new L1CrossDomainMessenger(op);\n\n        // Setup the address manager and proxy\n        vm.prank(multisig);\n        addressManager.setAddress(\"OVM_L1CrossDomainMessenger\", address(L1MessengerImpl));\n        ResolvedDelegateProxy proxy = new ResolvedDelegateProxy(\n            addressManager,\n            \"OVM_L1CrossDomainMessenger\"\n        );\n        L1Messenger = L1CrossDomainMessenger(address(proxy));\n        L1Messenger.initialize();\n\n        vm.etch(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            address(new L2CrossDomainMessenger(address(L1Messenger))).code\n        );\n\n        L2Messenger.initialize();\n\n        // Label addresses\n        vm.label(address(addressManager), \"AddressManager\");\n        vm.label(address(L1MessengerImpl), \"L1CrossDomainMessenger_Impl\");\n        vm.label(address(L1Messenger), \"L1CrossDomainMessenger_Proxy\");\n        vm.label(Predeploys.LEGACY_ERC20_ETH, \"LegacyERC20ETH\");\n        vm.label(Predeploys.L2_CROSS_DOMAIN_MESSENGER, \"L2CrossDomainMessenger\");\n\n        vm.label(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            \"L1CrossDomainMessenger_aliased\"\n        );\n    }\n}\n\ncontract Bridge_Initializer is Messenger_Initializer {\n    L1StandardBridge L1Bridge;\n    L2StandardBridge L2Bridge;\n    OptimismMintableERC20Factory L2TokenFactory;\n    OptimismMintableERC20Factory L1TokenFactory;\n    ERC20 L1Token;\n    ERC20 BadL1Token;\n    OptimismMintableERC20 L2Token;\n    LegacyMintableERC20 LegacyL2Token;\n    ERC20 NativeL2Token;\n    ERC20 BadL2Token;\n    OptimismMintableERC20 RemoteL1Token;\n\n    event ETHDepositInitiated(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ETHWithdrawalFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20DepositInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event WithdrawalInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event DepositFailed(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.label(Predeploys.L2_STANDARD_BRIDGE, \"L2StandardBridge\");\n        vm.label(Predeploys.OPTIMISM_MINTABLE_ERC20_FACTORY, \"OptimismMintableERC20Factory\");\n\n        // Deploy the L1 bridge and initialize it with the address of the\n        // L1CrossDomainMessenger\n        L1ChugSplashProxy proxy = new L1ChugSplashProxy(multisig);\n        vm.mockCall(\n            multisig,\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector),\n            abi.encode(true)\n        );\n        vm.startPrank(multisig);\n        proxy.setCode(address(new L1StandardBridge(payable(address(L1Messenger)))).code);\n        vm.clearMockedCalls();\n        address L1Bridge_Impl = proxy.getImplementation();\n        vm.stopPrank();\n\n        L1Bridge = L1StandardBridge(payable(address(proxy)));\n\n        vm.label(address(proxy), \"L1StandardBridge_Proxy\");\n        vm.label(address(L1Bridge_Impl), \"L1StandardBridge_Impl\");\n\n        // Deploy the L2StandardBridge, move it to the correct predeploy\n        // address and then initialize it\n        L2StandardBridge l2B = new L2StandardBridge(payable(proxy));\n        vm.etch(Predeploys.L2_STANDARD_BRIDGE, address(l2B).code);\n        L2Bridge = L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE));\n\n        // Set up the L2 mintable token factory\n        OptimismMintableERC20Factory factory = new OptimismMintableERC20Factory(\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n        vm.etch(Predeploys.OPTIMISM_MINTABLE_ERC20_FACTORY, address(factory).code);\n        L2TokenFactory = OptimismMintableERC20Factory(Predeploys.OPTIMISM_MINTABLE_ERC20_FACTORY);\n\n        vm.etch(Predeploys.LEGACY_ERC20_ETH, address(new LegacyERC20ETH()).code);\n\n        L1Token = new ERC20(\"Native L1 Token\", \"L1T\");\n\n        LegacyL2Token = new LegacyMintableERC20({\n            _l2Bridge: address(L2Bridge),\n            _l1Token: address(L1Token),\n            _name: string.concat(\"LegacyL2-\", L1Token.name()),\n            _symbol: string.concat(\"LegacyL2-\", L1Token.symbol())\n        });\n        vm.label(address(LegacyL2Token), \"LegacyMintableERC20\");\n\n        // Deploy the L2 ERC20 now\n        L2Token = OptimismMintableERC20(\n            L2TokenFactory.createStandardL2Token(\n                address(L1Token),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        BadL2Token = OptimismMintableERC20(\n            L2TokenFactory.createStandardL2Token(\n                address(1),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        NativeL2Token = new ERC20(\"Native L2 Token\", \"L2T\");\n        L1TokenFactory = new OptimismMintableERC20Factory(address(L1Bridge));\n\n        RemoteL1Token = OptimismMintableERC20(\n            L1TokenFactory.createStandardL2Token(\n                address(NativeL2Token),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n\n        BadL1Token = OptimismMintableERC20(\n            L1TokenFactory.createStandardL2Token(\n                address(1),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n    }\n}\n\ncontract ERC721Bridge_Initializer is Messenger_Initializer {\n    L1ERC721Bridge L1Bridge;\n    L2ERC721Bridge L2Bridge;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the L1ERC721Bridge.\n        L1Bridge = new L1ERC721Bridge(address(L1Messenger), Predeploys.L2_ERC721_BRIDGE);\n\n        // Deploy the implementation for the L2ERC721Bridge and etch it into the predeploy address.\n        vm.etch(\n            Predeploys.L2_ERC721_BRIDGE,\n            address(new L2ERC721Bridge(Predeploys.L2_CROSS_DOMAIN_MESSENGER, address(L1Bridge)))\n                .code\n        );\n\n        // Set up a reference to the L2ERC721Bridge.\n        L2Bridge = L2ERC721Bridge(Predeploys.L2_ERC721_BRIDGE);\n\n        // Label the L1 and L2 bridges.\n        vm.label(address(L1Bridge), \"L1ERC721Bridge\");\n        vm.label(address(L2Bridge), \"L2ERC721Bridge\");\n    }\n}\n\ncontract FFIInterface is Test {\n    function getProveWithdrawalTransactionInputs(Types.WithdrawalTransaction memory _tx)\n        external\n        returns (\n            bytes32,\n            bytes32,\n            bytes32,\n            bytes32,\n            bytes[] memory\n        )\n    {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"getProveWithdrawalTransactionInputs\";\n        cmds[2] = vm.toString(_tx.nonce);\n        cmds[3] = vm.toString(_tx.sender);\n        cmds[4] = vm.toString(_tx.target);\n        cmds[5] = vm.toString(_tx.value);\n        cmds[6] = vm.toString(_tx.gasLimit);\n        cmds[7] = vm.toString(_tx.data);\n\n        bytes memory result = vm.ffi(cmds);\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = abi.decode(result, (bytes32, bytes32, bytes32, bytes32, bytes[]));\n\n        return (stateRoot, storageRoot, outputRoot, withdrawalHash, withdrawalProof);\n    }\n\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashCrossDomainMessage\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashWithdrawal(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashWithdrawal\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashOutputRootProof(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _latestBlockhash\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](6);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashOutputRootProof\";\n        cmds[2] = Strings.toHexString(uint256(_version));\n        cmds[3] = Strings.toHexString(uint256(_stateRoot));\n        cmds[4] = Strings.toHexString(uint256(_messagePasserStorageRoot));\n        cmds[5] = Strings.toHexString(uint256(_latestBlockhash));\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashDepositTransaction(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](10);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashDepositTransaction\";\n        cmds[2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n        cmds[3] = vm.toString(_logIndex);\n        cmds[4] = vm.toString(_from);\n        cmds[5] = vm.toString(_to);\n        cmds[6] = vm.toString(_mint);\n        cmds[7] = vm.toString(_value);\n        cmds[8] = vm.toString(_gas);\n        cmds[9] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function encodeDepositTransaction(Types.UserDepositTransaction calldata txn)\n        external\n        returns (bytes memory)\n    {\n        string[] memory cmds = new string[](11);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"encodeDepositTransaction\";\n        cmds[2] = vm.toString(txn.from);\n        cmds[3] = vm.toString(txn.to);\n        cmds[4] = vm.toString(txn.value);\n        cmds[5] = vm.toString(txn.mint);\n        cmds[6] = vm.toString(txn.gasLimit);\n        cmds[7] = vm.toString(txn.isCreation);\n        cmds[8] = vm.toString(txn.data);\n        cmds[9] = vm.toString(txn.l1BlockHash);\n        cmds[10] = vm.toString(txn.logIndex);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"encodeCrossDomainMessage\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function decodeVersionedNonce(uint256 nonce) external returns (uint256, uint256) {\n        string[] memory cmds = new string[](3);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"decodeVersionedNonce\";\n        cmds[2] = vm.toString(nonce);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (uint256, uint256));\n    }\n\n    function getMerkleTrieFuzzCase(string memory variant)\n        external\n        returns (\n            bytes32,\n            bytes memory,\n            bytes memory,\n            bytes[] memory\n        )\n    {\n        string[] memory cmds = new string[](5);\n        cmds[0] = \"./test-case-generator/fuzz\";\n        cmds[1] = \"-m\";\n        cmds[2] = \"trie\";\n        cmds[3] = \"-v\";\n        cmds[4] = variant;\n\n        return abi.decode(vm.ffi(cmds), (bytes32, bytes, bytes, bytes[]));\n    }\n}\n\n// Used for testing a future upgrade beyond the current implementations.\n// We include some variables so that we can sanity check accessing storage values after an upgrade.\ncontract NextImpl is Initializable {\n    // Initializable occupies the zero-th slot.\n    bytes32 slot1;\n    bytes32[19] __gap;\n    bytes32 slot21;\n    bytes32 public constant slot21Init = bytes32(hex\"1337\");\n\n    function initialize() public reinitializer(2) {\n        // Slot21 is unused by an of our upgradeable contracts.\n        // This is used to verify that we can access this value after an upgrade.\n        slot21 = slot21Init;\n    }\n}\n\ncontract Reverter {\n    fallback() external {\n        revert();\n    }\n}\n\n// Useful for testing reentrancy guards\ncontract CallerCaller {\n    event WhatHappened(bool success, bytes returndata);\n\n    fallback() external {\n        (bool success, bytes memory returndata) = msg.sender.call(msg.data);\n        emit WhatHappened(success, returndata);\n        assembly {\n            switch success\n            case 0 {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n            default {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n\n// Used for testing the `CrossDomainMessenger`'s per-message reentrancy guard.\ncontract ConfigurableCaller {\n    bool doRevert = true;\n    address target;\n    bytes payload;\n\n    event WhatHappened(bool success, bytes returndata);\n\n    /**\n     * @notice Call the configured target with the configured payload OR revert.\n     */\n    function call() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        } else {\n            (bool success, bytes memory returndata) = address(target).call(payload);\n            emit WhatHappened(success, returndata);\n            assembly {\n                switch success\n                case 0 {\n                    revert(add(returndata, 0x20), mload(returndata))\n                }\n                default {\n                    return(add(returndata, 0x20), mload(returndata))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Set whether or not to have `call` revert.\n     */\n    function setDoRevert(bool _doRevert) external {\n        doRevert = _doRevert;\n    }\n\n    /**\n     * @notice Set the target for the call made in `call`.\n     */\n    function setTarget(address _target) external {\n        target = _target;\n    }\n\n    /**\n     * @notice Set the payload for the call made in `call`.\n     */\n    function setPayload(bytes calldata _payload) external {\n        payload = _payload;\n    }\n\n    /**\n     * @notice Fallback function that reverts if `doRevert` is true.\n     *         Otherwise, it does nothing.\n     */\n    fallback() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        }\n    }\n}\n"
    },
    "contracts/test/CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Messenger_Initializer, Reverter, CallerCaller, CommonTest } from \"./CommonTest.t.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\n\n// Libraries\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\n// CrossDomainMessenger_Test is for testing functionality which is common to both the L1 and L2\n// CrossDomainMessenger contracts. For simplicity, we use the L1 Messenger as the test contract.\ncontract CrossDomainMessenger_BaseGas_Test is Messenger_Initializer {\n    // Ensure that baseGas passes for the max value of _minGasLimit,\n    // this is about 4 Billion.\n    function test_baseGas_succeeds() external view {\n        L1Messenger.baseGas(hex\"ff\", type(uint32).max);\n    }\n\n    // Fuzz for other values which might cause a revert in baseGas.\n    function testFuzz_baseGas_succeeds(uint32 _minGasLimit) external view {\n        L1Messenger.baseGas(hex\"ff\", _minGasLimit);\n    }\n\n    /**\n     * @notice The baseGas function should always return a value greater than\n     *         or equal to the minimum gas limit value on the OptimismPortal.\n     *         This guarantees that the messengers will always pass sufficient\n     *         gas to the OptimismPortal.\n     */\n    function testFuzz_baseGas_portalMinGasLimit_succeeds(bytes memory _data, uint32 _minGasLimit)\n        external\n    {\n        vm.assume(_data.length <= type(uint64).max);\n        uint64 baseGas = L1Messenger.baseGas(_data, _minGasLimit);\n        uint64 minGasLimit = op.minimumGasLimit(uint64(_data.length));\n        assertTrue(baseGas >= minGasLimit);\n    }\n}\n\n/**\n * @title ExternalRelay\n * @notice A mock external contract called via the SafeCall inside\n *         the CrossDomainMessenger's `relayMessage` function.\n */\ncontract ExternalRelay is CommonTest {\n    address internal op;\n    address internal fuzzedSender;\n    L1CrossDomainMessenger internal L1Messenger;\n\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    constructor(L1CrossDomainMessenger _l1Messenger, address _op) {\n        L1Messenger = _l1Messenger;\n        op = _op;\n    }\n\n    /**\n     * @notice Internal helper function to relay a message and perform assertions.\n     */\n    function _internalRelay(address _innerSender) internal {\n        address initialSender = L1Messenger.xDomainMessageSender();\n\n        bytes memory callMessage = getCallData();\n\n        bytes32 hash = Hashing.hashCrossDomainMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            _sender: _innerSender,\n            _target: address(this),\n            _value: 0,\n            _gasLimit: 0,\n            _data: callMessage\n        });\n\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(address(op));\n        L1Messenger.relayMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            _sender: _innerSender,\n            _target: address(this),\n            _value: 0,\n            _minGasLimit: 0,\n            _message: callMessage\n        });\n\n        assertTrue(L1Messenger.failedMessages(hash));\n        assertFalse(L1Messenger.successfulMessages(hash));\n        assertEq(initialSender, L1Messenger.xDomainMessageSender());\n    }\n\n    /**\n     * @notice externalCallWithMinGas is called by the CrossDomainMessenger.\n     */\n    function externalCallWithMinGas() external payable {\n        for (uint256 i = 0; i < 10; i++) {\n            address _innerSender;\n            unchecked {\n                _innerSender = address(uint160(uint256(uint160(fuzzedSender)) + i));\n            }\n            _internalRelay(_innerSender);\n        }\n    }\n\n    /**\n     * @notice Helper function to get the callData for an `externalCallWithMinGas\n     */\n    function getCallData() public pure returns (bytes memory) {\n        return abi.encodeWithSelector(ExternalRelay.externalCallWithMinGas.selector);\n    }\n\n    /**\n     * @notice Helper function to set the fuzzed sender\n     */\n    function setFuzzedSender(address _fuzzedSender) public {\n        fuzzedSender = _fuzzedSender;\n    }\n}\n\n/**\n * @title CrossDomainMessenger_RelayMessage_Test\n * @notice Fuzz tests re-entrancy into the CrossDomainMessenger relayMessage function.\n */\ncontract CrossDomainMessenger_RelayMessage_Test is Messenger_Initializer {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    ExternalRelay public er;\n\n    function setUp() public override {\n        super.setUp();\n        er = new ExternalRelay(L1Messenger, address(op));\n    }\n\n    /**\n     * @dev This test mocks an OptimismPortal call to the L1CrossDomainMessenger via\n     *      the relayMessage function. The relayMessage function will then use SafeCall's\n     *      callWithMinGas to call the target with call data packed in the callMessage.\n     *      For this test, the callWithMinGas will call the mock ExternalRelay test contract\n     *      defined above, executing the externalCallWithMinGas function which will try to\n     *      re-enter the CrossDomainMessenger's relayMessage function, resulting in that message\n     *      being recorded as failed.\n     */\n    function testFuzz_relayMessageReenter_succeeds(address _sender, uint256 _gasLimit) external {\n        vm.assume(_sender != Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        er.setFuzzedSender(_sender);\n        address target = address(er);\n        bytes memory callMessage = er.getCallData();\n\n        vm.expectCall(target, callMessage);\n\n        uint64 gasLimit = uint64(bound(_gasLimit, 0, 30_000_000));\n\n        bytes32 hash = Hashing.hashCrossDomainMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            _sender: sender,\n            _target: target,\n            _value: 0,\n            _gasLimit: gasLimit,\n            _data: callMessage\n        });\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n        L1Messenger.relayMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            _sender: sender,\n            _target: target,\n            _value: 0,\n            _minGasLimit: gasLimit,\n            _message: callMessage\n        });\n\n        assertTrue(L1Messenger.successfulMessages(hash));\n        assertEq(L1Messenger.failedMessages(hash), false);\n\n        // Ensures that the `xDomainMsgSender` is set back to `Predeploys.L2_CROSS_DOMAIN_MESSENGER`\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest, Portal_Initializer } from \"./CommonTest.t.sol\";\nimport { CrossDomainOwnable } from \"../L2/CrossDomainOwnable.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Vm, VmSafe } from \"forge-std/Vm.sol\";\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract XDomainSetter is CrossDomainOwnable {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable_Test is CommonTest {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n        setter = new XDomainSetter();\n    }\n\n    // Check that the revert message is correct\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable: caller is not the owner\");\n        setter.set(1);\n    }\n\n    // Check that making a call can set the value properly\n    function test_onlyOwner_succeeds() external {\n        assertEq(setter.value(), 0);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(setter.owner()));\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n\ncontract CrossDomainOwnableThroughPortal_Test is Portal_Initializer {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.prank(alice);\n        setter = new XDomainSetter();\n    }\n\n    function test_depositTransaction_crossDomainOwner_succeeds() external {\n        vm.recordLogs();\n\n        vm.prank(alice);\n        op.depositTransaction({\n            _to: address(setter),\n            _value: 0,\n            _gasLimit: 30_000,\n            _isCreation: false,\n            _data: abi.encodeWithSelector(XDomainSetter.set.selector, 1)\n        });\n\n        // Simulate the operation of the `op-node` by parsing data\n        // from logs\n        VmSafe.Log[] memory logs = vm.getRecordedLogs();\n        // Only 1 log emitted\n        assertEq(logs.length, 1);\n\n        VmSafe.Log memory log = logs[0];\n\n        // It is the expected topic\n        bytes32 topic = log.topics[0];\n        assertEq(topic, keccak256(\"TransactionDeposited(address,address,uint256,bytes)\"));\n\n        // from is indexed and the first argument to the event.\n        bytes32 _from = log.topics[1];\n        address from = Bytes32AddressLib.fromLast20Bytes(_from);\n\n        assertEq(AddressAliasHelper.undoL1ToL2Alias(from), alice);\n\n        // Make a call from the \"from\" value received from the log.\n        // In theory the opaque data could be parsed from the log\n        // and passed to a low level call to \"to\", but calling set\n        // directly on the setter is good enough.\n        vm.prank(from);\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable2.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\nimport { CrossDomainOwnable2 } from \"../L2/CrossDomainOwnable2.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract XDomainSetter2 is CrossDomainOwnable2 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable2_Test is Messenger_Initializer {\n    XDomainSetter2 setter;\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter2();\n    }\n\n    function test_onlyOwner_notMessenger_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(204));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(address(alice));\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner2_reverts() external {\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter2.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce(nonce, 1),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(nonce, 1),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_onlyOwner_succeeds() external {\n        address owner = setter.owner();\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(1, 1),\n            owner,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter2.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable3.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\nimport { CrossDomainOwnable3 } from \"../L2/CrossDomainOwnable3.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract XDomainSetter3 is CrossDomainOwnable3 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable3_Test is Messenger_Initializer {\n    XDomainSetter3 setter;\n\n    /**\n     * @notice OpenZeppelin Ownable.sol transferOwnership event\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice CrossDomainOwnable3.sol transferOwnership event\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter3();\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(setter.owner(), alice);\n        assertEq(setter.isLocal(), true);\n    }\n\n    function test_localOnlyOwner_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n    }\n\n    function test_crossDomainOnlyOwner_notOwner_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(204));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(bob);\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_crossDomainOnlyOwner_notOwner2_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter3.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce(nonce, 1),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(nonce, 1),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_crossDomainOnlyOwner_notMessenger_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_zeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"CrossDomainOwnable3: new owner is the zero address\");\n        setter.transferOwnership({ _owner: address(0), _isLocal: true });\n    }\n\n    function test_transferOwnership_noLocalZeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"Ownable: new owner is the zero address\");\n        setter.transferOwnership(address(0));\n    }\n\n    function test_localOnlyOwner_succeeds() public {\n        assertEq(setter.isLocal(), true);\n        vm.prank(setter.owner());\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n\n    function test_localTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, true);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n\n        assertEq(setter.isLocal(), true);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    /**\n     * @notice The existing transferOwnership(address) method\n     *         still exists on the contract\n     */\n    function test_transferOwnershipNoLocal_succeeds() public {\n        bool isLocal = setter.isLocal();\n\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership(bob);\n\n        // isLocal has not changed\n        assertEq(setter.isLocal(), isLocal);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    function test_crossDomainTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(1, 1),\n            bob,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter3.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/DeployerWhitelist.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { DeployerWhitelist } from \"../legacy/DeployerWhitelist.sol\";\n\ncontract DeployerWhitelist_Test is CommonTest {\n    DeployerWhitelist list;\n\n    function setUp() public virtual override {\n        list = new DeployerWhitelist();\n    }\n\n    // The owner should be address(0)\n    function test_owner_succeeds() external {\n        assertEq(list.owner(), address(0));\n    }\n\n    // The storage slot for the owner must be the same\n    function test_storageSlots_succeeds() external {\n        vm.prank(list.owner());\n        list.setOwner(address(1));\n\n        assertEq(bytes32(uint256(1)), vm.load(address(list), bytes32(uint256(0))));\n    }\n}\n"
    },
    "contracts/test/DisputeGameFactory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../libraries/DisputeTypes.sol\";\nimport \"../libraries/DisputeErrors.sol\";\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { DisputeGameFactory } from \"../dispute/DisputeGameFactory.sol\";\nimport { IDisputeGame } from \"../dispute/IDisputeGame.sol\";\n\ncontract DisputeGameFactory_Test is Test {\n    DisputeGameFactory factory;\n    FakeClone fakeClone;\n\n    event DisputeGameCreated(\n        address indexed disputeProxy,\n        GameType indexed gameType,\n        Claim indexed rootClaim\n    );\n\n    event ImplementationSet(address indexed impl, GameType indexed gameType);\n\n    function setUp() public {\n        factory = new DisputeGameFactory(address(this));\n        fakeClone = new FakeClone();\n    }\n\n    /**\n     * @dev Tests that the `create` function succeeds when creating a new dispute game\n     *      with a `GameType` that has an implementation set.\n     */\n    function testFuzz_create_succeeds(\n        uint8 gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) public {\n        // Ensure that the `gameType` is within the bounds of the `GameType` enum's possible values.\n        GameType gt = GameType(uint8(bound(gameType, 0, 2)));\n\n        // Set all three implementations to the same `FakeClone` contract.\n        for (uint8 i; i < 3; i++) {\n            factory.setImplementation(GameType(i), IDisputeGame(address(fakeClone)));\n        }\n\n        vm.expectEmit(false, true, true, false);\n        emit DisputeGameCreated(address(0), gt, rootClaim);\n        IDisputeGame proxy = factory.create(gt, rootClaim, extraData);\n\n        // Ensure that the dispute game was assigned to the `disputeGames` mapping.\n        assertEq(address(factory.games(gt, rootClaim, extraData)), address(proxy));\n    }\n\n    /**\n     * @dev Tests that the `create` function reverts when there is no implementation\n     *      set for the given `GameType`.\n     */\n    function testFuzz_create_noImpl_reverts(\n        uint8 gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) public {\n        // Ensure that the `gameType` is within the bounds of the `GameType` enum's possible values.\n        GameType gt = GameType(uint8(bound(gameType, 0, 2)));\n\n        vm.expectRevert(abi.encodeWithSelector(NoImplementation.selector, gt));\n        factory.create(gt, rootClaim, extraData);\n    }\n\n    /**\n     * @dev Tests that the `create` function reverts when there exists a dispute game with the same UUID.\n     */\n    function testFuzz_create_sameUUID_reverts(\n        uint8 gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) public {\n        // Ensure that the `gameType` is within the bounds of the `GameType` enum's possible values.\n        GameType gt = GameType(uint8(bound(gameType, 0, 2)));\n\n        // Set all three implementations to the same `FakeClone` contract.\n        for (uint8 i; i < 3; i++) {\n            factory.setImplementation(GameType(i), IDisputeGame(address(fakeClone)));\n        }\n\n        // Create our first dispute game - this should succeed.\n        vm.expectEmit(false, true, true, false);\n        emit DisputeGameCreated(address(0), gt, rootClaim);\n        IDisputeGame proxy = factory.create(gt, rootClaim, extraData);\n\n        // Ensure that the dispute game was assigned to the `disputeGames` mapping.\n        assertEq(address(factory.games(gt, rootClaim, extraData)), address(proxy));\n\n        // Ensure that the `create` function reverts when called with parameters that would result in the same UUID.\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                GameAlreadyExists.selector,\n                factory.getGameUUID(gt, rootClaim, extraData)\n            )\n        );\n        factory.create(gt, rootClaim, extraData);\n    }\n\n    /**\n     * @dev Tests that the `setImplementation` function properly sets the implementation for a given `GameType`.\n     */\n    function test_setImplementation_succeeds() public {\n        // There should be no implementation for the `GameType.FAULT` enum value, it has not been set.\n        assertEq(address(factory.gameImpls(GameType.FAULT)), address(0));\n\n        vm.expectEmit(true, true, true, true, address(factory));\n        emit ImplementationSet(address(1), GameType.FAULT);\n\n        // Set the implementation for the `GameType.FAULT` enum value.\n        factory.setImplementation(GameType.FAULT, IDisputeGame(address(1)));\n\n        // Ensure that the implementation for the `GameType.FAULT` enum value is set.\n        assertEq(address(factory.gameImpls(GameType.FAULT)), address(1));\n    }\n\n    /**\n     * @dev Tests that the `setImplementation` function reverts when called by a non-owner.\n     */\n    function test_setImplementation_notOwner_reverts() public {\n        // Ensure that the `setImplementation` function reverts when called by a non-owner.\n        vm.prank(address(0));\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        factory.setImplementation(GameType.FAULT, IDisputeGame(address(1)));\n    }\n\n    /**\n     * @dev Tests that the `getGameUUID` function returns the correct hash when comparing\n     *      against the keccak256 hash of the abi-encoded parameters.\n     */\n    function testDiff_getGameUUID_succeeds(\n        uint8 gameType,\n        Claim rootClaim,\n        bytes calldata extraData\n    ) public {\n        // Ensure that the `gameType` is within the bounds of the `GameType` enum's possible values.\n        GameType gt = GameType(uint8(bound(gameType, 0, 2)));\n\n        assertEq(\n            Hash.unwrap(factory.getGameUUID(gt, rootClaim, extraData)),\n            keccak256(abi.encode(gt, rootClaim, extraData))\n        );\n    }\n\n    /**\n     * @dev Tests that the `owner` function returns the correct address after deployment.\n     */\n    function test_owner_succeeds() public {\n        assertEq(factory.owner(), address(this));\n    }\n\n    /**\n     * @dev Tests that the `transferOwnership` function succeeds when called by the owner.\n     */\n    function test_transferOwnership_succeeds() public {\n        factory.transferOwnership(address(1));\n        assertEq(factory.owner(), address(1));\n    }\n\n    /**\n     * @dev Tests that the `transferOwnership` function reverts when called by a non-owner.\n     */\n    function test_transferOwnership_notOwner_reverts() public {\n        vm.prank(address(0));\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        factory.transferOwnership(address(1));\n    }\n}\n\n/**\n * @dev A fake clone used for testing the `DisputeGameFactory` contract's `create` function.\n */\ncontract FakeClone {\n    function initialize() external {\n        // noop\n    }\n}\n"
    },
    "contracts/test/Encoding.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { LegacyCrossDomainUtils } from \"../libraries/LegacyCrossDomainUtils.sol\";\n\ncontract Encoding_Test is CommonTest {\n    function testFuzz_nonceVersioning_succeeds(uint240 _nonce, uint16 _version) external {\n        (uint240 nonce, uint16 version) = Encoding.decodeVersionedNonce(\n            Encoding.encodeVersionedNonce(_nonce, _version)\n        );\n        assertEq(version, _version);\n        assertEq(nonce, _nonce);\n    }\n\n    function testDiff_decodeVersionedNonce_succeeds(uint240 _nonce, uint16 _version) external {\n        uint256 nonce = uint256(Encoding.encodeVersionedNonce(_nonce, _version));\n        (uint256 decodedNonce, uint256 decodedVersion) = ffi.decodeVersionedNonce(nonce);\n\n        assertEq(_version, uint16(decodedVersion));\n\n        assertEq(_nonce, uint240(decodedNonce));\n    }\n\n    function testDiff_encodeCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint8 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint8 version = _version % 2;\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        bytes memory encoding = Encoding.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        bytes memory _encoding = ffi.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(encoding, _encoding);\n    }\n\n    function testFuzz_encodeCrossDomainMessageV0_matchesLegacy_succeeds(\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        bytes memory _data\n    ) external {\n        uint8 version = 0;\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        bytes memory legacyEncoding = LegacyCrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _data,\n            nonce\n        );\n\n        bytes memory bedrockEncoding = Encoding.encodeCrossDomainMessageV0(\n            _target,\n            _sender,\n            _data,\n            nonce\n        );\n\n        assertEq(legacyEncoding, bedrockEncoding);\n    }\n\n    function testDiff_encodeDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bool isCreate,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        Types.UserDepositTransaction memory t = Types.UserDepositTransaction(\n            _from,\n            _to,\n            isCreate,\n            _value,\n            _mint,\n            _gas,\n            _data,\n            bytes32(uint256(0)),\n            _logIndex\n        );\n\n        bytes memory txn = Encoding.encodeDepositTransaction(t);\n        bytes memory _txn = ffi.encodeDepositTransaction(t);\n\n        assertEq(txn, _txn);\n    }\n}\n"
    },
    "contracts/test/FeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\nimport { L1FeeVault } from \"../L2/L1FeeVault.sol\";\nimport { BaseFeeVault } from \"../L2/BaseFeeVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\n// Test the implementations of the FeeVault\ncontract FeeVault_Test is Bridge_Initializer {\n    BaseFeeVault baseFeeVault = BaseFeeVault(payable(Predeploys.BASE_FEE_VAULT));\n    L1FeeVault l1FeeVault = L1FeeVault(payable(Predeploys.L1_FEE_VAULT));\n\n    address constant recipient = address(0x10000);\n\n    function setUp() public override {\n        super.setUp();\n        vm.etch(Predeploys.BASE_FEE_VAULT, address(new BaseFeeVault(recipient)).code);\n        vm.etch(Predeploys.L1_FEE_VAULT, address(new L1FeeVault(recipient)).code);\n\n        vm.label(Predeploys.BASE_FEE_VAULT, \"BaseFeeVault\");\n        vm.label(Predeploys.L1_FEE_VAULT, \"L1FeeVault\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(baseFeeVault.RECIPIENT(), recipient);\n        assertEq(l1FeeVault.RECIPIENT(), recipient);\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(baseFeeVault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n        assertEq(l1FeeVault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n    }\n}\n"
    },
    "contracts/test/GasPriceOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { GasPriceOracle } from \"../L2/GasPriceOracle.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract GasPriceOracle_Test is CommonTest {\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    GasPriceOracle gasOracle;\n    L1Block l1Block;\n    address depositor;\n\n    // set the initial L1 context values\n    uint64 constant number = 10;\n    uint64 constant timestamp = 11;\n    uint256 constant basefee = 100;\n    bytes32 constant hash = bytes32(uint256(64));\n    uint64 constant sequenceNumber = 0;\n    bytes32 constant batcherHash = bytes32(uint256(777));\n    uint256 constant l1FeeOverhead = 310;\n    uint256 constant l1FeeScalar = 10;\n\n    function setUp() public virtual override {\n        super.setUp();\n        // place the L1Block contract at the predeploy address\n        vm.etch(Predeploys.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n\n        l1Block = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n\n        // We are not setting the gas oracle at its predeploy\n        // address for simplicity purposes. Nothing in this test\n        // requires it to be at a particular address\n        gasOracle = new GasPriceOracle();\n\n        vm.prank(depositor);\n        l1Block.setL1BlockValues({\n            _number: number,\n            _timestamp: timestamp,\n            _basefee: basefee,\n            _hash: hash,\n            _sequenceNumber: sequenceNumber,\n            _batcherHash: batcherHash,\n            _l1FeeOverhead: l1FeeOverhead,\n            _l1FeeScalar: l1FeeScalar\n        });\n    }\n\n    function test_l1BaseFee_succeeds() external {\n        assertEq(gasOracle.l1BaseFee(), basefee);\n    }\n\n    function test_gasPrice_succeeds() external {\n        vm.fee(100);\n        uint256 gasPrice = gasOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    function test_baseFee_succeeds() external {\n        vm.fee(64);\n        uint256 gasPrice = gasOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    function test_scalar_succeeds() external {\n        assertEq(gasOracle.scalar(), l1FeeScalar);\n    }\n\n    function test_overhead_succeeds() external {\n        assertEq(gasOracle.overhead(), l1FeeOverhead);\n    }\n\n    function test_decimals_succeeds() external {\n        assertEq(gasOracle.decimals(), 6);\n        assertEq(gasOracle.DECIMALS(), 6);\n    }\n\n    // Removed in bedrock\n    function test_setGasPrice_doesNotExist_reverts() external {\n        (bool success, bytes memory returndata) = address(gasOracle).call(\n            abi.encodeWithSignature(\"setGasPrice(uint256)\", 1)\n        );\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n\n    // Removed in bedrock\n    function test_setL1BaseFee_doesNotExist_reverts() external {\n        (bool success, bytes memory returndata) = address(gasOracle).call(\n            abi.encodeWithSignature(\"setL1BaseFee(uint256)\", 1)\n        );\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n}\n"
    },
    "contracts/test/GovernanceToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { GovernanceToken } from \"../governance/GovernanceToken.sol\";\n\ncontract GovernanceToken_Test is CommonTest {\n    address constant owner = address(0x1234);\n    address constant rando = address(0x5678);\n    GovernanceToken internal gov;\n\n    function setUp() public virtual override {\n        super.setUp();\n        vm.prank(owner);\n        gov = new GovernanceToken();\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(gov.owner(), owner);\n        assertEq(gov.name(), \"Optimism\");\n        assertEq(gov.symbol(), \"OP\");\n        assertEq(gov.decimals(), 18);\n        assertEq(gov.totalSupply(), 0);\n    }\n\n    function test_mint_fromOwner_succeeds() external {\n        // Mint 100 tokens.\n        vm.prank(owner);\n        gov.mint(owner, 100);\n\n        // Balances have updated correctly.\n        assertEq(gov.balanceOf(owner), 100);\n        assertEq(gov.totalSupply(), 100);\n    }\n\n    function test_mint_fromNotOwner_reverts() external {\n        // Mint 100 tokens as rando.\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gov.mint(owner, 100);\n\n        // Balance does not update.\n        assertEq(gov.balanceOf(owner), 0);\n        assertEq(gov.totalSupply(), 0);\n    }\n\n    function test_burn_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando burns their tokens.\n        vm.prank(rando);\n        gov.burn(50);\n\n        // Balances have updated correctly.\n        assertEq(gov.balanceOf(rando), 50);\n        assertEq(gov.totalSupply(), 50);\n    }\n\n    function test_burnFrom_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando approves owner to burn 50 tokens.\n        vm.prank(rando);\n        gov.approve(owner, 50);\n\n        // Owner burns 50 tokens from rando.\n        vm.prank(owner);\n        gov.burnFrom(rando, 50);\n\n        // Balances have updated correctly.\n        assertEq(gov.balanceOf(rando), 50);\n        assertEq(gov.totalSupply(), 50);\n    }\n\n    function test_transfer_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando transfers 50 tokens to owner.\n        vm.prank(rando);\n        gov.transfer(owner, 50);\n\n        // Balances have updated correctly.\n        assertEq(gov.balanceOf(owner), 50);\n        assertEq(gov.balanceOf(rando), 50);\n        assertEq(gov.totalSupply(), 100);\n    }\n\n    function test_approve_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando approves owner to spend 50 tokens.\n        vm.prank(rando);\n        gov.approve(owner, 50);\n\n        // Allowances have updated.\n        assertEq(gov.allowance(rando, owner), 50);\n    }\n\n    function test_transferFrom_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando approves owner to spend 50 tokens.\n        vm.prank(rando);\n        gov.approve(owner, 50);\n\n        // Owner transfers 50 tokens from rando to owner.\n        vm.prank(owner);\n        gov.transferFrom(rando, owner, 50);\n\n        // Balances have updated correctly.\n        assertEq(gov.balanceOf(owner), 50);\n        assertEq(gov.balanceOf(rando), 50);\n        assertEq(gov.totalSupply(), 100);\n    }\n\n    function test_increaseAllowance_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando approves owner to spend 50 tokens.\n        vm.prank(rando);\n        gov.approve(owner, 50);\n\n        // Rando increases allowance by 50 tokens.\n        vm.prank(rando);\n        gov.increaseAllowance(owner, 50);\n\n        // Allowances have updated.\n        assertEq(gov.allowance(rando, owner), 100);\n    }\n\n    function test_decreaseAllowance_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(owner);\n        gov.mint(rando, 100);\n\n        // Rando approves owner to spend 100 tokens.\n        vm.prank(rando);\n        gov.approve(owner, 100);\n\n        // Rando decreases allowance by 50 tokens.\n        vm.prank(rando);\n        gov.decreaseAllowance(owner, 50);\n\n        // Allowances have updated.\n        assertEq(gov.allowance(rando, owner), 50);\n    }\n}\n"
    },
    "contracts/test/Hashing.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { LegacyCrossDomainUtils } from \"../libraries/LegacyCrossDomainUtils.sol\";\n\ncontract Hashing_hashDepositSource_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositSource returns the correct hash in a simple case.\n     */\n    function test_hashDepositSource_succeeds() external {\n        assertEq(\n            Hashing.hashDepositSource(\n                0xd25df7858efc1778118fb133ac561b138845361626dfb976699c5287ed0f4959,\n                0x1\n            ),\n            0xf923fb07134d7d287cb52c770cc619e17e82606c21a875c92f4c63b65280a5cc\n        );\n    }\n}\n\ncontract Hashing_hashCrossDomainMessage_Test is CommonTest {\n    /**\n     * @notice Tests that hashCrossDomainMessage returns the correct hash in a simple case.\n     */\n    function testDiff_hashCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint16 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Ensure the version is valid.\n        uint16 version = uint16(bound(uint256(_version), 0, 1));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        assertEq(\n            Hashing.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data),\n            ffi.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n\n    /**\n     * @notice Tests that hashCrossDomainMessageV0 matches the hash of the legacy encoding.\n     */\n    function testFuzz_hashCrossDomainMessageV0_matchesLegacy_succeeds(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) external {\n        assertEq(\n            keccak256(\n                LegacyCrossDomainUtils.encodeXDomainCalldata(\n                    _target,\n                    _sender,\n                    _message,\n                    _messageNonce\n                )\n            ),\n            Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _messageNonce)\n        );\n    }\n}\n\ncontract Hashing_hashWithdrawal_Test is CommonTest {\n    /**\n     * @notice Tests that hashWithdrawal returns the correct hash in a simple case.\n     */\n    function testDiff_hashWithdrawal_succeeds(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        assertEq(\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction(_nonce, _sender, _target, _value, _gasLimit, _data)\n            ),\n            ffi.hashWithdrawal(_nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashOutputRootProof_Test is CommonTest {\n    /**\n     * @notice Tests that hashOutputRootProof returns the correct hash in a simple case.\n     */\n    function testDiff_hashOutputRootProof_succeeds(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _latestBlockhash\n    ) external {\n        assertEq(\n            Hashing.hashOutputRootProof(\n                Types.OutputRootProof({\n                    version: _version,\n                    stateRoot: _stateRoot,\n                    messagePasserStorageRoot: _messagePasserStorageRoot,\n                    latestBlockhash: _latestBlockhash\n                })\n            ),\n            ffi.hashOutputRootProof(\n                _version,\n                _stateRoot,\n                _messagePasserStorageRoot,\n                _latestBlockhash\n            )\n        );\n    }\n}\n\ncontract Hashing_hashDepositTransaction_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositTransaction returns the correct hash in a simple case.\n     */\n    function testDiff_hashDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        assertEq(\n            Hashing.hashDepositTransaction(\n                Types.UserDepositTransaction(\n                    _from,\n                    _to,\n                    false, // isCreate\n                    _value,\n                    _mint,\n                    _gas,\n                    _data,\n                    bytes32(uint256(0)),\n                    _logIndex\n                )\n            ),\n            ffi.hashDepositTransaction(_from, _to, _mint, _value, _gas, _data, _logIndex)\n        );\n    }\n}\n"
    },
    "contracts/test/L1Block.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\ncontract L1BlockTest is CommonTest {\n    L1Block lb;\n    address depositor;\n    bytes32 immutable NON_ZERO_HASH = keccak256(abi.encode(1));\n\n    function setUp() public virtual override {\n        super.setUp();\n        lb = new L1Block();\n        depositor = lb.DEPOSITOR_ACCOUNT();\n        vm.prank(depositor);\n        lb.setL1BlockValues({\n            _number: uint64(1),\n            _timestamp: uint64(2),\n            _basefee: 3,\n            _hash: NON_ZERO_HASH,\n            _sequenceNumber: uint64(4),\n            _batcherHash: bytes32(0),\n            _l1FeeOverhead: 2,\n            _l1FeeScalar: 3\n        });\n    }\n\n    function testFuzz_updatesValues_succeeds(\n        uint64 n,\n        uint64 t,\n        uint256 b,\n        bytes32 h,\n        uint64 s,\n        bytes32 bt,\n        uint256 fo,\n        uint256 fs\n    ) external {\n        vm.prank(depositor);\n        lb.setL1BlockValues(n, t, b, h, s, bt, fo, fs);\n        assertEq(lb.number(), n);\n        assertEq(lb.timestamp(), t);\n        assertEq(lb.basefee(), b);\n        assertEq(lb.hash(), h);\n        assertEq(lb.sequenceNumber(), s);\n        assertEq(lb.batcherHash(), bt);\n        assertEq(lb.l1FeeOverhead(), fo);\n        assertEq(lb.l1FeeScalar(), fs);\n    }\n\n    function test_number_succeeds() external {\n        assertEq(lb.number(), uint64(1));\n    }\n\n    function test_timestamp_succeeds() external {\n        assertEq(lb.timestamp(), uint64(2));\n    }\n\n    function test_basefee_succeeds() external {\n        assertEq(lb.basefee(), 3);\n    }\n\n    function test_hash_succeeds() external {\n        assertEq(lb.hash(), NON_ZERO_HASH);\n    }\n\n    function test_sequenceNumber_succeeds() external {\n        assertEq(lb.sequenceNumber(), uint64(4));\n    }\n\n    function test_updateValues_succeeds() external {\n        vm.prank(depositor);\n        lb.setL1BlockValues({\n            _number: type(uint64).max,\n            _timestamp: type(uint64).max,\n            _basefee: type(uint256).max,\n            _hash: keccak256(abi.encode(1)),\n            _sequenceNumber: type(uint64).max,\n            _batcherHash: bytes32(type(uint256).max),\n            _l1FeeOverhead: type(uint256).max,\n            _l1FeeScalar: type(uint256).max\n        });\n    }\n}\n"
    },
    "contracts/test/L1BlockNumber.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { L1BlockNumber } from \"../legacy/L1BlockNumber.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract L1BlockNumberTest is Test {\n    L1Block lb;\n    L1BlockNumber bn;\n\n    uint64 constant number = 99;\n\n    function setUp() external {\n        vm.etch(Predeploys.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n        lb = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        bn = new L1BlockNumber();\n        vm.prank(lb.DEPOSITOR_ACCOUNT());\n\n        lb.setL1BlockValues({\n            _number: number,\n            _timestamp: uint64(2),\n            _basefee: 3,\n            _hash: bytes32(uint256(10)),\n            _sequenceNumber: uint64(4),\n            _batcherHash: bytes32(uint256(0)),\n            _l1FeeOverhead: 2,\n            _l1FeeScalar: 3\n        });\n    }\n\n    function test_getL1BlockNumber_succeeds() external {\n        assertEq(bn.getL1BlockNumber(), number);\n    }\n\n    function test_fallback_succeeds() external {\n        (bool success, bytes memory ret) = address(bn).call(hex\"\");\n        assertEq(success, true);\n        assertEq(ret, abi.encode(number));\n    }\n\n    function test_receive_succeeds() external {\n        (bool success, bytes memory ret) = address(bn).call{ value: 1 }(hex\"\");\n        assertEq(success, true);\n        assertEq(ret, abi.encode(number));\n    }\n}\n"
    },
    "contracts/test/L1CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle_Initializer } from \"./L2OutputOracle.t.sol\";\n\n/* Libraries */\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\n/* Target contract dependencies */\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\n\n/* Target contract */\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\n\ncontract L1CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    // the version is encoded in the nonce\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L1Messenger.messageNonce());\n        assertEq(version, L1Messenger.MESSAGE_VERSION());\n    }\n\n    // sendMessage: should be able to send a single message\n    // TODO: this same test needs to be done with the legacy message type\n    // by setting the message version to 0\n    function test_sendMessage_succeeds() external {\n        // deposit transaction on the optimism portal should be called\n        vm.expectCall(\n            address(op),\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n                0,\n                L1Messenger.baseGas(hex\"ff\", 100),\n                false,\n                Encoding.encodeCrossDomainMessage(\n                    L1Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // TransactionDeposited event\n        vm.expectEmit(true, true, true, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            0,\n            0,\n            L1Messenger.baseGas(hex\"ff\", 100),\n            false,\n            Encoding.encodeCrossDomainMessage(\n                L1Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        // SentMessage event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(recipient, alice, hex\"ff\", L1Messenger.messageNonce(), 100);\n\n        // SentMessageExtension1 event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessageExtension1(alice, 0);\n\n        vm.prank(alice);\n        L1Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    // sendMessage: should be able to send the same message twice\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L1Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_notSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v2_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Expect a revert.\n        vm.expectRevert(\n            \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n        );\n\n        // Try to relay a v2 message.\n        vm.prank(address(op));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 2 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    // relayMessage: should send a successful call to the target contract\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.expectCall(target, hex\"1111\");\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L1Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L1Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        // set the target to be the OptimismPortal\n        address target = address(op);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.prank(address(op));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n\n        vm.store(address(op), 0, bytes32(abi.encode(sender)));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: should revert if eth is sent from a contract other than the standard bridge\n    function test_replayMessage_withValue_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.expectRevert(\n            \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n        );\n        L1Messenger.relayMessage{ value: 100 }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retryAfterFailure_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        vm.expectCall(target, hex\"1111\");\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(op), value);\n        vm.prank(address(op));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), true);\n    }\n\n    function test_relayMessage_legacy_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Compute the message hash.\n        bytes32 hash = Hashing.hashCrossDomainMessageV1(\n            // Using a legacy nonce with version 0.\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        // Set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Target should be called with expected data.\n        vm.expectCall(target, hex\"1111\");\n\n        // Expect RelayedMessage event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit RelayedMessage(hash);\n\n        // Relay the message.\n        vm.prank(address(op));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // Message was successfully relayed.\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), false);\n    }\n\n    function test_relayMessage_legacyOldReplay_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Compute the message hash.\n        bytes32 hash = Hashing.hashCrossDomainMessageV1(\n            // Using a legacy nonce with version 0.\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        // Set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Mark legacy message as already relayed.\n        uint256 successfulMessagesSlot = 203;\n        bytes32 oldHash = Hashing.hashCrossDomainMessageV0(target, sender, hex\"1111\", 0);\n        bytes32 slot = keccak256(abi.encode(oldHash, successfulMessagesSlot));\n        vm.store(address(L1Messenger), slot, bytes32(uint256(1)));\n\n        // Expect revert.\n        vm.expectRevert(\"CrossDomainMessenger: legacy withdrawal already relayed\");\n\n        // Relay the message.\n        vm.prank(address(op));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // Message was not relayed.\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), false);\n    }\n\n    function test_relayMessage_legacyRetryAfterFailure_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        // Compute the message hash.\n        bytes32 hash = Hashing.hashCrossDomainMessageV1(\n            // Using a legacy nonce with version 0.\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Turn the target into a Reverter.\n        vm.etch(target, address(new Reverter()).code);\n\n        // Target should be called with expected data.\n        vm.expectCall(target, hex\"1111\");\n\n        // Expect FailedRelayedMessage event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        // Relay the message.\n        vm.deal(address(op), value);\n        vm.prank(address(op));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Message failed.\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        // Make the target not revert anymore.\n        vm.etch(target, address(0).code);\n\n        // Target should be called with expected data.\n        vm.expectCall(target, hex\"1111\");\n\n        // Expect RelayedMessage event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit RelayedMessage(hash);\n\n        // Retry the message.\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Message was successfully relayed.\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), true);\n    }\n\n    function test_relayMessage_legacyRetryAfterSuccess_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        // Compute the message hash.\n        bytes32 hash = Hashing.hashCrossDomainMessageV1(\n            // Using a legacy nonce with version 0.\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Target should be called with expected data.\n        vm.expectCall(target, hex\"1111\");\n\n        // Expect RelayedMessage event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit RelayedMessage(hash);\n\n        // Relay the message.\n        vm.deal(address(op), value);\n        vm.prank(address(op));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Message was successfully relayed.\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), false);\n\n        // Expect a revert.\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n\n        // Retry the message.\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n    }\n\n    function test_relayMessage_legacyRetryAfterFailureThenSuccess_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        // Compute the message hash.\n        bytes32 hash = Hashing.hashCrossDomainMessageV1(\n            // Using a legacy nonce with version 0.\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Turn the target into a Reverter.\n        vm.etch(target, address(new Reverter()).code);\n\n        // Target should be called with expected data.\n        vm.expectCall(target, hex\"1111\");\n\n        // Relay the message.\n        vm.deal(address(op), value);\n        vm.prank(address(op));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Message failed.\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        // Make the target not revert anymore.\n        vm.etch(target, address(0).code);\n\n        // Target should be called with expected data.\n        vm.expectCall(target, hex\"1111\");\n\n        // Expect RelayedMessage event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit RelayedMessage(hash);\n\n        // Retry the message\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        // Message was successfully relayed.\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        // Expect a revert.\n        vm.expectRevert(\"CrossDomainMessenger: message has already been relayed\");\n\n        // Retry the message again.\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n    }\n}\n"
    },
    "contracts/test/L1ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L1ERC721Bridge_Test is Messenger_Initializer {\n    TestERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L1ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L1ERC721Bridge(address(L1Messenger), otherBridge);\n        localToken = new TestERC721();\n        remoteToken = new TestERC721();\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L1ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L1Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n        assertEq(address(bridge.messenger()), address(L1Messenger));\n        assertEq(address(bridge.otherBridge()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notEscrowed_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n"
    },
    "contracts/test/L1StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\n\ncontract L1StandardBridge_Getter_Test is Bridge_Initializer {\n    function test_getters_succeeds() external {\n        assert(L1Bridge.l2TokenBridge() == address(L2Bridge));\n        assert(L1Bridge.OTHER_BRIDGE() == L2Bridge);\n        assert(L1Bridge.messenger() == L1Messenger);\n        assert(L1Bridge.MESSENGER() == L1Messenger);\n        assertEq(L1Bridge.version(), \"1.1.0\");\n    }\n}\n\ncontract L1StandardBridge_Initialize_Test is Bridge_Initializer {\n    function test_initialize_succeeds() external {\n        assertEq(address(L1Bridge.messenger()), address(L1Messenger));\n\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), Predeploys.L2_STANDARD_BRIDGE);\n\n        assertEq(address(L2Bridge), Predeploys.L2_STANDARD_BRIDGE);\n    }\n}\n\ncontract L1StandardBridge_Initialize_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_Receive_Test is Bridge_Initializer {\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(op).balance, 0);\n\n        // The legacy event must be emitted for backwards compatibility\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHDepositInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    100,\n                    hex\"\"\n                ),\n                200_000\n            )\n        );\n\n        vm.prank(alice, alice);\n        (bool success, ) = address(L1Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(op).balance, 100);\n    }\n}\n\ncontract L1StandardBridge_Receive_TestFail {}\n\ncontract PreBridgeETH is Bridge_Initializer {\n    function _preBridgeETH(bool isLegacy) internal {\n        assertEq(address(op).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the OptimismPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            alice,\n            500,\n            hex\"dead\"\n        );\n\n        if (isLegacy) {\n            vm.expectCall(\n                address(L1Bridge),\n                500,\n                abi.encodeWithSelector(L1Bridge.depositETH.selector, 50000, hex\"dead\")\n            );\n        } else {\n            vm.expectCall(\n                address(L1Bridge),\n                500,\n                abi.encodeWithSelector(L1Bridge.bridgeETH.selector, 50000, hex\"dead\")\n            );\n        }\n        vm.expectCall(\n            address(L1Messenger),\n            500,\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                50000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            500,\n            50000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 50000);\n        vm.expectCall(\n            address(op),\n            500,\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                address(L2Messenger),\n                500,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(500),\n            uint256(500),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHDepositInitiated(alice, alice, 500, hex\"dead\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 500, hex\"dead\");\n\n        // OptimismPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(op));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), message, nonce, 50000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessageExtension1(address(L1Bridge), 500);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_DepositETH_Test is PreBridgeETH {\n    // depositETH\n    // - emits ETHDepositInitiated\n    // - emits ETHBridgeInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the optimismPortal\n    function test_depositETH_succeeds() external {\n        _preBridgeETH({ isLegacy: true });\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"dead\");\n        assertEq(address(op).balance, 500);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_Test is PreBridgeETH {\n    // BridgeETH\n    // - emits ETHDepositInitiated\n    // - emits ETHBridgeInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the optimismPortal\n    function test_bridgeETH_succeeds() external {\n        _preBridgeETH({ isLegacy: false });\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"dead\");\n        assertEq(address(op).balance, 500);\n    }\n}\n\ncontract L1StandardBridge_DepositETH_TestFail is Bridge_Initializer {\n    function test_depositETH_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, address(L1Token).code);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice);\n        L1Bridge.depositETH{ value: 1 }(300, hex\"\");\n    }\n}\n\ncontract PreBridgeETHTo is Bridge_Initializer {\n    function _preBridgeETHTo(bool isLegacy) internal {\n        assertEq(address(op).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the OptimismPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        if (isLegacy) {\n            vm.expectCall(\n                address(L1Bridge),\n                600,\n                abi.encodeWithSelector(L1Bridge.depositETHTo.selector, bob, 60000, hex\"dead\")\n            );\n        } else {\n            vm.expectCall(\n                address(L1Bridge),\n                600,\n                abi.encodeWithSelector(L1Bridge.bridgeETHTo.selector, bob, 60000, hex\"dead\")\n            );\n        }\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            bob,\n            600,\n            hex\"dead\"\n        );\n\n        // the L1 bridge should call\n        // L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                60000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            600,\n            60000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 60000);\n        vm.expectCall(\n            address(op),\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                address(L2Messenger),\n                600,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(600),\n            uint256(600),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHDepositInitiated(alice, bob, 600, hex\"dead\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, bob, 600, hex\"dead\");\n\n        // OptimismPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(op));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), message, nonce, 60000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessageExtension1(address(L1Bridge), 600);\n\n        // deposit eth to bob\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_DepositETHTo_Test is PreBridgeETHTo {\n    // depositETHTo\n    // - emits ETHDepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - EOA or contract can call\n    // - ETH ends up in the optimismPortal\n    function test_depositETHTo_succeeds() external {\n        _preBridgeETHTo({ isLegacy: true });\n        L1Bridge.depositETHTo{ value: 600 }(bob, 60000, hex\"dead\");\n        assertEq(address(op).balance, 600);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_Test is PreBridgeETHTo {\n    // BridgeETHTo\n    // - emits ETHDepositInitiated\n    // - emits ETHBridgeInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the optimismPortal\n    function test_bridgeETHTo_succeeds() external {\n        _preBridgeETHTo({ isLegacy: false });\n        L1Bridge.bridgeETHTo{ value: 600 }(bob, 60000, hex\"dead\");\n        assertEq(address(op).balance, 600);\n    }\n}\n\ncontract L1StandardBridge_DepositETHTo_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_DepositERC20_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // depositERC20\n    // - updates bridge.deposits\n    // - emits ERC20DepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only callable by EOA\n    function test_depositERC20_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the OptimismPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Deal Alice's ERC20 State\n        deal(address(L1Token), alice, 100000, true);\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // The L1Bridge should transfer alice's tokens to itself\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 100)\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        vm.expectCall(\n            address(op),\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        // Should emit both the bedrock and legacy events\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20DepositInitiated(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        // OptimismPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(op));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), message, nonce, 10000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessageExtension1(address(L1Bridge), 0);\n\n        vm.prank(alice);\n        L1Bridge.depositERC20(address(L1Token), address(L2Token), 100, 10000, hex\"\");\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n    }\n}\n\ncontract L1StandardBridge_DepositERC20_TestFail is Bridge_Initializer {\n    function test_depositERC20_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, hex\"ffff\");\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice, alice);\n        L1Bridge.depositERC20(address(0), address(0), 100, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_DepositERC20To_Test is Bridge_Initializer {\n    // depositERC20To\n    // - updates bridge.deposits\n    // - emits ERC20DepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - callable by a contract\n    function test_depositERC20To_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the OptimismPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            bob,\n            1000,\n            hex\"\"\n        );\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        vm.expectCall(\n            address(op),\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        // Should emit both the bedrock and legacy events\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20DepositInitiated(address(L1Token), address(L2Token), alice, bob, 1000, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, bob, 1000, hex\"\");\n\n        // OptimismPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(op));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), message, nonce, 10000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessageExtension1(address(L1Bridge), 0);\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 1000)\n        );\n\n        vm.prank(alice);\n        L1Bridge.depositERC20To(address(L1Token), address(L2Token), bob, 1000, 10000, hex\"\");\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 1000);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeETHWithdrawal\n    // - emits ETHWithdrawalFinalized\n    // - only callable by L2 bridge\n    function test_finalizeETHWithdrawal_succeeds() external {\n        uint256 aliceBalance = alice.balance;\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHWithdrawalFinalized(alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        vm.expectCall(alice, hex\"\");\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        // ensure that the messenger has ETH to call with\n        vm.deal(address(L1Bridge.messenger()), 100);\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeETHWithdrawal{ value: 100 }(alice, alice, 100, hex\"\");\n\n        assertEq(address(L1Bridge.messenger()).balance, 0);\n        assertEq(aliceBalance + 100, alice.balance);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_FinalizeERC20Withdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeERC20Withdrawal\n    // - updates bridge.deposits\n    // - emits ERC20WithdrawalFinalized\n    // - only callable by L2 bridge\n    function test_finalizeERC20Withdrawal_succeeds() external {\n        deal(address(L1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(L1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20WithdrawalFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transfer.selector, alice, 100)\n        );\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        assertEq(L1Token.balanceOf(address(L1Bridge)), 0);\n        assertEq(L1Token.balanceOf(address(alice)), 100);\n    }\n}\n\ncontract L1StandardBridge_FinalizeERC20Withdrawal_TestFail is Bridge_Initializer {\n    function test_finalizeERC20Withdrawal_notMessenger_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(28));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    function test_finalizeERC20Withdrawal_notOtherBridge_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(address(0)))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L1Bridge.messenger());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        address messenger = address(L1Bridge.messenger());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L1Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        address messenger = address(L1Bridge.messenger());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L1Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        address messenger = address(L1Bridge.messenger());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, messenger, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\ncontract L2CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L2Messenger.messageNonce());\n        assertEq(version, L2Messenger.MESSAGE_VERSION());\n    }\n\n    function test_sendMessage_succeeds() external {\n        bytes memory xDomainCallData = Encoding.encodeCrossDomainMessage(\n            L2Messenger.messageNonce(),\n            alice,\n            recipient,\n            0,\n            100,\n            hex\"ff\"\n        );\n        vm.expectCall(\n            address(messagePasser),\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                L2Messenger.baseGas(hex\"ff\", 100),\n                xDomainCallData\n            )\n        );\n\n        // MessagePassed event\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            L2Messenger.baseGas(hex\"ff\", 100),\n            xDomainCallData,\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction({\n                    nonce: messagePasser.messageNonce(),\n                    sender: address(L2Messenger),\n                    target: address(L1Messenger),\n                    value: 0,\n                    gasLimit: L2Messenger.baseGas(hex\"ff\", 100),\n                    data: xDomainCallData\n                })\n            )\n        );\n\n        vm.prank(alice);\n        L2Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L2Messenger.messageNonce();\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L2Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_senderNotSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v2_reverts() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Expect a revert.\n        vm.expectRevert(\n            \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n        );\n\n        // Try to relay a v2 message.\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(0, 2), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(target, hex\"1111\");\n\n        vm.prank(caller);\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce(0, 1),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(0, 1), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L2Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L2Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        address target = address(messagePasser);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = hex\"1111\";\n\n        vm.prank(caller);\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(0, 1),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(0, 1),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retry_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        uint256 value = 100;\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce(0, 1),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(caller), value);\n        vm.prank(caller);\n        L2Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce(0, 1), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L2Messenger.successfulMessages(hash), false);\n        assertEq(L2Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce(0, 1), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L2Messenger.successfulMessages(hash), true);\n        assertEq(L2Messenger.failedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L2ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { OptimismMintableERC721 } from \"../universal/OptimismMintableERC721.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract TestMintableERC721 is OptimismMintableERC721 {\n    constructor(address _bridge, address _remoteToken)\n        OptimismMintableERC721(_bridge, 1, _remoteToken, \"Test\", \"TST\")\n    {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L2ERC721Bridge_Test is Messenger_Initializer {\n    TestMintableERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L2ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L2ERC721Bridge(address(L2Messenger), otherBridge);\n        remoteToken = new TestERC721();\n        localToken = new TestMintableERC721(address(bridge), address(remoteToken));\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L2ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n        assertEq(address(bridge.messenger()), address(L2Messenger));\n        assertEq(address(bridge.otherBridge()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L1ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_interfaceNotCompliant_reverts() external {\n        // Create a non-compliant token\n        NonCompliantERC721 nonCompliantToken = new NonCompliantERC721(alice);\n\n        // Bridge the non-compliant token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(nonCompliantToken), address(0x01), tokenId, 1234, hex\"5678\");\n\n        // Attempt to finalize the withdrawal. Should revert because the token does not claim\n        // to be compliant with the `IOptimismMintableERC721` interface.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token interface is not compliant\");\n        bridge.finalizeBridgeERC721(\n            address(address(nonCompliantToken)),\n            address(address(0x01)),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_alreadyExists_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721: token already minted\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n\n/**\n * @dev A non-compliant ERC721 token that does not implement the full ERC721 interface.\n *\n * This is used to test that the bridge will revert if the token does not claim to support\n * the ERC721 interface.\n */\ncontract NonCompliantERC721 {\n    address internal immutable owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    function ownerOf(uint256) external view returns (address) {\n        return owner;\n    }\n\n    function remoteToken() external pure returns (address) {\n        return address(0x01);\n    }\n\n    function burn(address, uint256) external {\n        // Do nothing.\n    }\n\n    function supportsInterface(bytes4) external pure returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/test/L2OutputOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\nimport { L2OutputOracle_Initializer, NextImpl } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\ncontract L2OutputOracleTest is L2OutputOracle_Initializer {\n    bytes32 proposedOutput1 = keccak256(abi.encode(1));\n\n    function test_constructor_succeeds() external {\n        assertEq(oracle.PROPOSER(), proposer);\n        assertEq(oracle.CHALLENGER(), owner);\n        assertEq(oracle.SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(oracle.latestBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingTimestamp(), startingTimestamp);\n    }\n\n    function test_constructor_badTimestamp_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: starting L2 timestamp must be less than current time\");\n\n        // startingTimestamp is in the future\n        new L2OutputOracle({\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp + 1,\n            _proposer: proposer,\n            _challenger: owner,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    function test_constructor_l2BlockTimeZero_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: L2 block time must be greater than 0\");\n        new L2OutputOracle({\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: 0,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _proposer: proposer,\n            _challenger: owner,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    function test_constructor_submissionInterval_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: submission interval must be greater than 0\");\n        new L2OutputOracle({\n            _submissionInterval: 0,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _proposer: proposer,\n            _challenger: owner,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    /****************\n     * Getter Tests *\n     ****************/\n\n    // Test: latestBlockNumber() should return the correct value\n    function test_latestBlockNumber_succeeds() external {\n        uint256 proposedNumber = oracle.nextBlockNumber();\n\n        // Roll to after the block number we'll propose\n        warpToProposeTime(proposedNumber);\n        vm.prank(proposer);\n        oracle.proposeL2Output(proposedOutput1, proposedNumber, 0, 0);\n        assertEq(oracle.latestBlockNumber(), proposedNumber);\n    }\n\n    // Test: getL2Output() should return the correct value\n    function test_getL2Output_succeeds() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        oracle.proposeL2Output(proposedOutput1, nextBlockNumber, 0, 0);\n\n        Types.OutputProposal memory proposal = oracle.getL2Output(nextOutputIndex);\n        assertEq(proposal.outputRoot, proposedOutput1);\n        assertEq(proposal.timestamp, block.timestamp);\n\n        // The block number is larger than the latest proposed output:\n        vm.expectRevert(stdError.indexOOBError);\n        oracle.getL2Output(nextOutputIndex + 1);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is exact block\n    function test_getL2OutputIndexAfter_sameBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber1);\n        vm.prank(proposer);\n        oracle.proposeL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with exact same block as proposed returns the proposal.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is previous block\n    function test_getL2OutputIndexAfter_previousBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber1);\n        vm.prank(proposer);\n        oracle.proposeL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with previous block returns the proposal too.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 - 1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value during binary search\n    function test_getL2OutputIndexAfter_multipleOutputsExist_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber1);\n        vm.prank(proposer);\n        oracle.proposeL2Output(output1, nextBlockNumber1, 0, 0);\n\n        bytes32 output2 = keccak256(abi.encode(2));\n        uint256 nextBlockNumber2 = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber2);\n        vm.prank(proposer);\n        oracle.proposeL2Output(output2, nextBlockNumber2, 0, 0);\n\n        bytes32 output3 = keccak256(abi.encode(3));\n        uint256 nextBlockNumber3 = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber3);\n        vm.prank(proposer);\n        oracle.proposeL2Output(output3, nextBlockNumber3, 0, 0);\n\n        bytes32 output4 = keccak256(abi.encode(4));\n        uint256 nextBlockNumber4 = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber4);\n        vm.prank(proposer);\n        oracle.proposeL2Output(output4, nextBlockNumber4, 0, 0);\n\n        // Querying with a block number between the first and second proposal\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 + 1);\n        assertEq(index1, 1);\n\n        // Querying with a block number between the second and third proposal\n        uint256 index2 = oracle.getL2OutputIndexAfter(nextBlockNumber2 + 1);\n        assertEq(index2, 2);\n\n        // Querying with a block number between the third and fourth proposal\n        uint256 index3 = oracle.getL2OutputIndexAfter(nextBlockNumber3 + 1);\n        assertEq(index3, 3);\n    }\n\n    // Test: getL2OutputIndexAfter() reverts when no output exists yet\n    function test_getL2OutputIndexAfter_noOutputsExis_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: cannot get output as no outputs have been proposed yet\");\n        oracle.getL2OutputIndexAfter(0);\n    }\n\n    // Test: nextBlockNumber() should return the correct value\n    function test_nextBlockNumber_succeeds() external {\n        assertEq(\n            oracle.nextBlockNumber(),\n            // The return value should match this arithmetic\n            oracle.latestBlockNumber() + oracle.SUBMISSION_INTERVAL()\n        );\n    }\n\n    function test_computeL2Timestamp_succeeds() external {\n        // reverts if timestamp is too low\n        vm.expectRevert(stdError.arithmeticError);\n        oracle.computeL2Timestamp(startingBlockNumber - 1);\n\n        // returns the correct value...\n        // ... for the very first block\n        assertEq(oracle.computeL2Timestamp(startingBlockNumber), startingTimestamp);\n\n        // ... for the first block after the starting block\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 1),\n            startingTimestamp + l2BlockTime\n        );\n\n        // ... for some other block number\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 96024),\n            startingTimestamp + l2BlockTime * 96024\n        );\n    }\n\n    /*****************************\n     * Propose Tests - Happy Path *\n     *****************************/\n\n    // Test: proposeL2Output succeeds when given valid input, and no block hash and number are\n    // specified.\n    function test_proposeL2Output_proposeAnotherOutput_succeeds() public {\n        bytes32 proposedOutput2 = keccak256(abi.encode());\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToProposeTime(nextBlockNumber);\n        uint256 proposedNumber = oracle.latestBlockNumber();\n\n        // Ensure the submissionInterval is enforced\n        assertEq(nextBlockNumber, proposedNumber + submissionInterval);\n\n        vm.roll(nextBlockNumber + 1);\n\n        vm.expectEmit(true, true, true, true);\n        emit OutputProposed(proposedOutput2, nextOutputIndex, nextBlockNumber, block.timestamp);\n\n        vm.prank(proposer);\n        oracle.proposeL2Output(proposedOutput2, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output succeeds when given valid input, and when a block hash and number are\n    // specified for reorg protection.\n    function test_proposeWithBlockhashAndHeight_succeeds() external {\n        // Get the number and hash of a previous block in the chain\n        uint256 prevL1BlockNumber = block.number - 1;\n        bytes32 prevL1BlockHash = blockhash(prevL1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, prevL1BlockHash, prevL1BlockNumber);\n    }\n\n    /***************************\n     * Propose Tests - Sad Path *\n     ***************************/\n\n    // Test: proposeL2Output fails if called by a party that is not the proposer.\n    function test_proposeL2Output_notProposer_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n\n        vm.prank(address(128));\n        vm.expectRevert(\"L2OutputOracle: only the proposer address can propose new outputs\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output fails given a zero blockhash.\n    function test_proposeL2Output_emptyOutput_reverts() external {\n        bytes32 outputToPropose = bytes32(0);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: L2 output proposal cannot be the zero hash\");\n        oracle.proposeL2Output(outputToPropose, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output fails if the block number doesn't match the next expected number.\n    function test_proposeL2Output_unexpectedBlockNumber_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: block number must be equal to next expected block number\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber - 1, 0, 0);\n    }\n\n    // Test: proposeL2Output fails if it would have a timestamp in the future.\n    function test_proposeL2Output_futureTimetamp_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextTimestamp = oracle.computeL2Timestamp(nextBlockNumber);\n        vm.warp(nextTimestamp);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: cannot propose L2 output in the future\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output fails if a non-existent L1 block hash and number are provided for reorg\n    // protection.\n    function test_proposeL2Output_wrongFork_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.proposeL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            bytes32(uint256(0x01)),\n            block.number - 1\n        );\n    }\n\n    // Test: proposeL2Output fails when given valid input, but the block hash and number do not\n    // match.\n    function test_proposeL2Output_unmatchedBlockhash_reverts() external {\n        // Move ahead to block 100 so that we can reference historical blocks\n        vm.roll(100);\n\n        // Get the number and hash of a previous block in the chain\n        uint256 l1BlockNumber = block.number - 1;\n        bytes32 l1BlockHash = blockhash(l1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n\n        // This will fail when foundry no longer returns zerod block hashes\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, l1BlockHash, l1BlockNumber - 1);\n    }\n\n    /*****************************\n     * Delete Tests - Happy Path *\n     *****************************/\n\n    function test_deleteOutputs_singleOutput_succeeds() external {\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n        Types.OutputProposal memory newLatestOutput = oracle.getL2Output(latestOutputIndex - 1);\n\n        vm.prank(owner);\n        vm.expectEmit(true, true, false, false);\n        emit OutputsDeleted(latestOutputIndex + 1, latestOutputIndex);\n        oracle.deleteL2Outputs(latestOutputIndex);\n\n        // validate latestBlockNumber has been reduced\n        uint256 latestBlockNumberAfter = oracle.latestBlockNumber();\n        uint256 latestOutputIndexAfter = oracle.latestOutputIndex();\n        assertEq(latestBlockNumber - submissionInterval, latestBlockNumberAfter);\n\n        // validate that the new latest output is as expected.\n        Types.OutputProposal memory proposal = oracle.getL2Output(latestOutputIndexAfter);\n        assertEq(newLatestOutput.outputRoot, proposal.outputRoot);\n        assertEq(newLatestOutput.timestamp, proposal.timestamp);\n    }\n\n    function test_deleteOutputs_multipleOutputs_succeeds() external {\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n        Types.OutputProposal memory newLatestOutput = oracle.getL2Output(latestOutputIndex - 3);\n\n        vm.prank(owner);\n        vm.expectEmit(true, true, false, false);\n        emit OutputsDeleted(latestOutputIndex + 1, latestOutputIndex - 2);\n        oracle.deleteL2Outputs(latestOutputIndex - 2);\n\n        // validate latestBlockNumber has been reduced\n        uint256 latestBlockNumberAfter = oracle.latestBlockNumber();\n        uint256 latestOutputIndexAfter = oracle.latestOutputIndex();\n        assertEq(latestBlockNumber - submissionInterval * 3, latestBlockNumberAfter);\n\n        // validate that the new latest output is as expected.\n        Types.OutputProposal memory proposal = oracle.getL2Output(latestOutputIndexAfter);\n        assertEq(newLatestOutput.outputRoot, proposal.outputRoot);\n        assertEq(newLatestOutput.timestamp, proposal.timestamp);\n    }\n\n    /***************************\n     * Delete Tests - Sad Path *\n     ***************************/\n\n    function test_deleteL2Outputs_ifNotChallenger_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.expectRevert(\"L2OutputOracle: only the challenger address can delete outputs\");\n        oracle.deleteL2Outputs(latestBlockNumber);\n    }\n\n    function test_deleteL2Outputs_nonExistent_reverts() external {\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.prank(owner);\n        vm.expectRevert(\"L2OutputOracle: cannot delete outputs after the latest output index\");\n        oracle.deleteL2Outputs(latestBlockNumber + 1);\n    }\n\n    function test_deleteL2Outputs_afterLatest_reverts() external {\n        // Start by proposing three outputs\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n\n        // Delete the latest two outputs\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n        vm.prank(owner);\n        oracle.deleteL2Outputs(latestOutputIndex - 2);\n\n        // Now try to delete the same output again\n        vm.prank(owner);\n        vm.expectRevert(\"L2OutputOracle: cannot delete outputs after the latest output index\");\n        oracle.deleteL2Outputs(latestOutputIndex - 2);\n    }\n\n    function test_deleteL2Outputs_finalized_reverts() external {\n        test_proposeL2Output_proposeAnotherOutput_succeeds();\n\n        // Warp past the finalization period + 1 second\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n\n        // Try to delete a finalized output\n        vm.prank(owner);\n        vm.expectRevert(\"L2OutputOracle: cannot delete outputs that have already been finalized\");\n        oracle.deleteL2Outputs(latestOutputIndex);\n    }\n}\n\ncontract L2OutputOracleUpgradeable_Test is L2OutputOracle_Initializer {\n    Proxy internal proxy;\n\n    function setUp() public override {\n        super.setUp();\n        proxy = Proxy(payable(address(oracle)));\n    }\n\n    function test_initValuesOnProxy_succeeds() external {\n        assertEq(submissionInterval, oracleImpl.SUBMISSION_INTERVAL());\n        assertEq(l2BlockTime, oracleImpl.L2_BLOCK_TIME());\n        assertEq(startingBlockNumber, oracleImpl.startingBlockNumber());\n        assertEq(startingTimestamp, oracleImpl.startingTimestamp());\n\n        assertEq(proposer, oracleImpl.PROPOSER());\n        assertEq(owner, oracleImpl.CHALLENGER());\n    }\n\n    function test_initializeProxy_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(payable(proxy)).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_initializeImpl_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(oracleImpl).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(oracle), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(oracle), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(oracle)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L2StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\ncontract L2StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function test_initialize_succeeds() external {\n        assertEq(address(L2Bridge.messenger()), address(L2Messenger));\n        assertEq(L1Bridge.l2TokenBridge(), address(L2Bridge));\n        assertEq(address(L2Bridge.OTHER_BRIDGE()), address(L1Bridge));\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(messagePasser).balance, 0);\n        uint256 nonce = L2Messenger.messageNonce();\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 200_000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            100,\n            200_000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 100,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(address(0), Predeploys.LEGACY_ERC20_ETH, alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        // L2ToL1MessagePasser will emit a MessagePassed event\n        vm.expectEmit(true, true, true, true, address(messagePasser));\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            100,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessage(address(L1Bridge), address(L2Bridge), message, nonce, 200_000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessageExtension1(address(L2Bridge), 100);\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                200_000 // StandardBridge's RECEIVE_DEFAULT_GAS_LIMIT\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        vm.prank(alice, alice);\n        (bool success, ) = address(L2Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(messagePasser).balance, 100);\n    }\n\n    // withrdraw\n    // - requires amount == msg.value\n    function test_withdraw_insufficientValue_reverts() external {\n        assertEq(address(messagePasser).balance, 0);\n\n        vm.expectRevert(\"StandardBridge: bridging ETH must include sufficient ETH value\");\n        vm.prank(alice, alice);\n        L2Bridge.withdraw(address(Predeploys.LEGACY_ERC20_ETH), 100, 1000, hex\"\");\n    }\n\n    /**\n     * @notice Use the legacy `withdraw` interface on the L2StandardBridge to\n     *         withdraw ether from L2 to L1.\n     */\n    function test_withdraw_ether_succeeds() external {\n        assertTrue(alice.balance >= 100);\n        assertEq(Predeploys.L2_TO_L1_MESSAGE_PASSER.balance, 0);\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit WithdrawalInitiated({\n            l1Token: address(0),\n            l2Token: Predeploys.LEGACY_ERC20_ETH,\n            from: alice,\n            to: alice,\n            amount: 100,\n            data: hex\"\"\n        });\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ETHBridgeInitiated({ from: alice, to: alice, amount: 100, data: hex\"\" });\n\n        vm.prank(alice, alice);\n        L2Bridge.withdraw{ value: 100 }({\n            _l2Token: Predeploys.LEGACY_ERC20_ETH,\n            _amount: 100,\n            _minGasLimit: 1000,\n            _extraData: hex\"\"\n        });\n\n        assertEq(Predeploys.L2_TO_L1_MESSAGE_PASSER.balance, 100);\n    }\n}\n\ncontract PreBridgeERC20 is Bridge_Initializer {\n    // withdraw and BridgeERC20 should behave the same when transferring ERC20 tokens\n    // so they should share the same setup and expectEmit calls\n    function _preBridgeERC20(bool _isLegacy, address _l2Token) internal {\n        // Alice has 100 L2Token\n        deal(_l2Token, alice, 100, true);\n        assertEq(ERC20(_l2Token).balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            _l2Token,\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        if (_isLegacy) {\n            vm.expectCall(\n                address(L2Bridge),\n                abi.encodeWithSelector(L2Bridge.withdraw.selector, _l2Token, 100, 1000, hex\"\")\n            );\n        } else {\n            vm.expectCall(\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    L2Bridge.bridgeERC20.selector,\n                    _l2Token,\n                    address(L1Token),\n                    100,\n                    1000,\n                    hex\"\"\n                )\n            );\n        }\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            _l2Token,\n            abi.encodeWithSelector(OptimismMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(address(L1Token), _l2Token, alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeInitiated(_l2Token, address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(address(L1Bridge), address(L2Bridge), message, nonce, 1000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true);\n        emit SentMessageExtension1(address(L2Bridge), 0);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20_Test is PreBridgeERC20 {\n    // withdraw\n    // - token is burned\n    // - emits WithdrawalInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_withdraw_withdrawingERC20_succeeds() external {\n        _preBridgeERC20({ _isLegacy: true, _l2Token: address(L2Token) });\n        L2Bridge.withdraw(address(L2Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    // BridgeERC20\n    // - token is burned\n    // - emits WithdrawalInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20_succeeds() external {\n        _preBridgeERC20({ _isLegacy: false, _l2Token: address(L2Token) });\n        L2Bridge.bridgeERC20(address(L2Token), address(L1Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_withdrawLegacyERC20_succeeds() external {\n        _preBridgeERC20({ _isLegacy: true, _l2Token: address(LegacyL2Token) });\n        L2Bridge.withdraw(address(LegacyL2Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_bridgeLegacyERC20_succeeds() external {\n        _preBridgeERC20({ _isLegacy: false, _l2Token: address(LegacyL2Token) });\n        L2Bridge.bridgeERC20(address(LegacyL2Token), address(L1Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_withdraw_notEOA_reverts() external {\n        // This contract has 100 L2Token\n        deal(address(L2Token), address(this), 100, true);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        L2Bridge.withdraw(address(L2Token), 100, 1000, hex\"\");\n    }\n}\n\ncontract PreBridgeERC20To is Bridge_Initializer {\n    // withdrawTo and BridgeERC20To should behave the same when transferring ERC20 tokens\n    // so they should share the same setup and expectEmit calls\n    function _preBridgeERC20To(bool _isLegacy, address _l2Token) internal {\n        deal(_l2Token, alice, 100, true);\n        assertEq(ERC20(L2Token).balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            _l2Token,\n            alice,\n            bob,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit WithdrawalInitiated(address(L1Token), _l2Token, alice, bob, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeInitiated(_l2Token, address(L1Token), alice, bob, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(messagePasser));\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessage(address(L1Bridge), address(L2Bridge), message, nonce, 1000);\n\n        // SentMessageExtension1 event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessageExtension1(address(L2Bridge), 0);\n\n        if (_isLegacy) {\n            vm.expectCall(\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    L2Bridge.withdrawTo.selector,\n                    _l2Token,\n                    bob,\n                    100,\n                    1000,\n                    hex\"\"\n                )\n            );\n        } else {\n            vm.expectCall(\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    L2Bridge.bridgeERC20To.selector,\n                    _l2Token,\n                    address(L1Token),\n                    bob,\n                    100,\n                    1000,\n                    hex\"\"\n                )\n            );\n        }\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(OptimismMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20To_Test is PreBridgeERC20To {\n    // withdrawTo\n    // - token is burned\n    // - emits WithdrawalInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_withdrawTo_withdrawingERC20_succeeds() external {\n        _preBridgeERC20To({ _isLegacy: true, _l2Token: address(L2Token) });\n        L2Bridge.withdrawTo(address(L2Token), bob, 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    // bridgeERC20To\n    // - token is burned\n    // - emits WithdrawalInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20To_succeeds() external {\n        _preBridgeERC20To({ _isLegacy: false, _l2Token: address(L2Token) });\n        L2Bridge.bridgeERC20To(address(L2Token), address(L1Token), bob, 100, 1000, hex\"\");\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract L2StandardBridge_Bridge_Test is Bridge_Initializer {\n    // finalizeDeposit\n    // - only callable by l1TokenBridge\n    // - supported token pair emits DepositFinalized\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeDeposit_depositingERC20_succeeds() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(OptimismMintableERC20.mint.selector, alice, 100)\n        );\n\n        // Should emit both the bedrock and legacy events\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit DepositFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeFinalized(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeDeposit(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeDeposit_depositingETH_succeeds() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n\n        // Should emit both the bedrock and legacy events\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit DepositFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeFinalized(\n            address(L2Token), // localToken\n            address(L1Token), // remoteToken\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeDeposit(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L2Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Messenger), 100, hex\"\");\n    }\n}\n\ncontract L2StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L2Bridge.messenger());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true);\n        emit DepositFinalized(address(0), Predeploys.LEGACY_ERC20_ETH, alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2ToL1MessagePasser.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\n\ncontract L2ToL1MessagePasserTest is CommonTest {\n    L2ToL1MessagePasser messagePasser;\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    function setUp() public virtual override {\n        super.setUp();\n        messagePasser = new L2ToL1MessagePasser();\n    }\n\n    function testFuzz_initiateWithdrawal_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint256 nonce = messagePasser.messageNonce();\n\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: _sender,\n                target: _target,\n                value: _value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, _sender, _target, _value, _gasLimit, _data, withdrawalHash);\n\n        vm.deal(_sender, _value);\n        vm.prank(_sender);\n        messagePasser.initiateWithdrawal{ value: _value }(_target, _gasLimit, _data);\n\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n\n        bytes32 slot = keccak256(bytes.concat(withdrawalHash, bytes32(0)));\n\n        assertEq(vm.load(address(messagePasser), slot), bytes32(uint256(1)));\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by a contract\n    function test_initiateWithdrawal_fromContract_succeeds() external {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                messagePasser.messageNonce(),\n                address(this),\n                address(4),\n                100,\n                64000,\n                hex\"\"\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(this),\n            address(4),\n            100,\n            64000,\n            hex\"\",\n            withdrawalHash\n        );\n\n        vm.deal(address(this), 2**64);\n        messagePasser.initiateWithdrawal{ value: 100 }(address(4), 64000, hex\"\");\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by an EOA\n    function test_initiateWithdrawal_fromEOA_succeeds() external {\n        uint256 gasLimit = 64000;\n        address target = address(4);\n        uint256 value = 100;\n        bytes memory data = hex\"ff\";\n        uint256 nonce = messagePasser.messageNonce();\n\n        // EOA emulation\n        vm.prank(alice, alice);\n        vm.deal(alice, 2**64);\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(nonce, alice, target, value, gasLimit, data)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, alice, target, value, gasLimit, data, withdrawalHash);\n\n        messagePasser.initiateWithdrawal{ value: value }(target, gasLimit, data);\n\n        // the sent messages mapping is filled\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n        // the nonce increments\n        assertEq(nonce + 1, messagePasser.messageNonce());\n    }\n\n    // Test: burn should destroy the ETH held in the contract\n    function test_burn_succeeds() external {\n        messagePasser.initiateWithdrawal{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            NON_ZERO_GASLIMIT,\n            NON_ZERO_DATA\n        );\n\n        assertEq(address(messagePasser).balance, NON_ZERO_VALUE);\n        vm.expectEmit(true, false, false, false);\n        emit WithdrawerBalanceBurnt(NON_ZERO_VALUE);\n        messagePasser.burn();\n\n        // The Withdrawer should have no balance\n        assertEq(address(messagePasser).balance, 0);\n    }\n}\n"
    },
    "contracts/test/LegacyERC20ETH.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { LegacyERC20ETH } from \"../legacy/LegacyERC20ETH.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract LegacyERC20ETH_Test is CommonTest {\n    LegacyERC20ETH eth;\n\n    function setUp() public virtual override {\n        super.setUp();\n        eth = new LegacyERC20ETH();\n    }\n\n    function test_metadata_succeeds() external {\n        assertEq(eth.name(), \"Ether\");\n        assertEq(eth.symbol(), \"ETH\");\n        assertEq(eth.decimals(), 18);\n    }\n\n    function test_crossDomain_succeeds() external {\n        assertEq(eth.l2Bridge(), Predeploys.L2_STANDARD_BRIDGE);\n        assertEq(eth.l1Token(), address(0));\n    }\n\n    function test_transfer_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: transfer is disabled\");\n        eth.transfer(alice, 100);\n    }\n\n    function test_approve_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: approve is disabled\");\n        eth.approve(alice, 100);\n    }\n\n    function test_transferFrom_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: transferFrom is disabled\");\n        eth.transferFrom(bob, alice, 100);\n    }\n\n    function test_increaseAllowance_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: increaseAllowance is disabled\");\n        eth.increaseAllowance(alice, 100);\n    }\n\n    function test_decreaseAllowance_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: decreaseAllowance is disabled\");\n        eth.decreaseAllowance(alice, 100);\n    }\n\n    function test_mint_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: mint is disabled\");\n        eth.mint(alice, 100);\n    }\n\n    function test_burn_doesNotExist_reverts() external {\n        vm.expectRevert(\"LegacyERC20ETH: burn is disabled\");\n        eth.burn(alice, 100);\n    }\n}\n"
    },
    "contracts/test/LegacyMessagePasser.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { LegacyMessagePasser } from \"../legacy/LegacyMessagePasser.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract LegacyMessagePasser_Test is CommonTest {\n    LegacyMessagePasser messagePasser;\n\n    function setUp() public virtual override {\n        super.setUp();\n        messagePasser = new LegacyMessagePasser();\n    }\n\n    function test_passMessageToL1_succeeds() external {\n        vm.prank(alice);\n        messagePasser.passMessageToL1(hex\"ff\");\n        assert(messagePasser.sentMessages(keccak256(abi.encodePacked(hex\"ff\", alice))));\n    }\n}\n"
    },
    "contracts/test/MerkleTrie.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { MerkleTrie } from \"../libraries/trie/MerkleTrie.sol\";\n\ncontract MerkleTrie_get_Test is CommonTest {\n    function test_get_validProof1_succeeds() external {\n        bytes32 root = 0xd582f99275e227a1cf4284899e5ff06ee56da8859be71b553397c69151bc942f;\n        bytes memory key = hex\"6b6579326262\";\n        bytes memory val = hex\"6176616c32\";\n        bytes[] memory proof = new bytes[](3);\n        proof[\n            0\n        ] = hex\"e68416b65793a03101b4447781f1e6c51ce76c709274fc80bd064f3a58ff981b6015348a826386\";\n        proof[\n            1\n        ] = hex\"f84580a0582eed8dd051b823d13f8648cdcd08aa2d8dac239f458863c4620e8c4d605debca83206262856176616c32ca83206363856176616c3380808080808080808080808080\";\n        proof[2] = hex\"ca83206262856176616c32\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof2_succeeds() external {\n        bytes32 root = 0xd582f99275e227a1cf4284899e5ff06ee56da8859be71b553397c69151bc942f;\n        bytes memory key = hex\"6b6579316161\";\n        bytes\n            memory val = hex\"303132333435363738393031323334353637383930313233343536373839303132333435363738397878\";\n        bytes[] memory proof = new bytes[](3);\n        proof[\n            0\n        ] = hex\"e68416b65793a03101b4447781f1e6c51ce76c709274fc80bd064f3a58ff981b6015348a826386\";\n        proof[\n            1\n        ] = hex\"f84580a0582eed8dd051b823d13f8648cdcd08aa2d8dac239f458863c4620e8c4d605debca83206262856176616c32ca83206363856176616c3380808080808080808080808080\";\n        proof[\n            2\n        ] = hex\"ef83206161aa303132333435363738393031323334353637383930313233343536373839303132333435363738397878\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof3_succeeds() external {\n        bytes32 root = 0xf838216fa749aefa91e0b672a9c06d3e6e983f913d7107b5dab4af60b5f5abed;\n        bytes memory key = hex\"6b6579316161\";\n        bytes\n            memory val = hex\"303132333435363738393031323334353637383930313233343536373839303132333435363738397878\";\n        bytes[] memory proof = new bytes[](1);\n        proof[\n            0\n        ] = hex\"f387206b6579316161aa303132333435363738393031323334353637383930313233343536373839303132333435363738397878\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof4_succeeds() external {\n        bytes32 root = 0x37956bab6bba472308146808d5311ac19cb4a7daae5df7efcc0f32badc97f55e;\n        bytes memory key = hex\"6b6579316161\";\n        bytes memory val = hex\"3031323334\";\n        bytes[] memory proof = new bytes[](1);\n        proof[0] = hex\"ce87206b6579316161853031323334\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof5_succeeds() external {\n        bytes32 root = 0xcb65032e2f76c48b82b5c24b3db8f670ce73982869d38cd39a624f23d62a9e89;\n        bytes memory key = hex\"6b657931\";\n        bytes\n            memory val = hex\"30313233343536373839303132333435363738393031323334353637383930313233343536373839566572795f4c6f6e67\";\n        bytes[] memory proof = new bytes[](3);\n        proof[\n            0\n        ] = hex\"e68416b65793a0f3f387240403976788281c0a6ee5b3fc08360d276039d635bb824ea7e6fed779\";\n        proof[\n            1\n        ] = hex\"f87180a034d14ccc7685aa2beb64f78b11ee2a335eae82047ef97c79b7dda7f0732b9f4ca05fb052b64e23d177131d9f32e9c5b942209eb7229e9a07c99a5d93245f53af18a09a137197a43a880648d5887cce656a5e6bbbe5e44ecb4f264395ccaddbe1acca80808080808080808080808080\";\n        proof[\n            2\n        ] = hex\"f862808080808080a057895fdbd71e2c67c2f9274a56811ff5cf458720a7fa713a135e3890f8cafcf8808080808080808080b130313233343536373839303132333435363738393031323334353637383930313233343536373839566572795f4c6f6e67\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof6_succeeds() external {\n        bytes32 root = 0xcb65032e2f76c48b82b5c24b3db8f670ce73982869d38cd39a624f23d62a9e89;\n        bytes memory key = hex\"6b657932\";\n        bytes memory val = hex\"73686f7274\";\n        bytes[] memory proof = new bytes[](3);\n        proof[\n            0\n        ] = hex\"e68416b65793a0f3f387240403976788281c0a6ee5b3fc08360d276039d635bb824ea7e6fed779\";\n        proof[\n            1\n        ] = hex\"f87180a034d14ccc7685aa2beb64f78b11ee2a335eae82047ef97c79b7dda7f0732b9f4ca05fb052b64e23d177131d9f32e9c5b942209eb7229e9a07c99a5d93245f53af18a09a137197a43a880648d5887cce656a5e6bbbe5e44ecb4f264395ccaddbe1acca80808080808080808080808080\";\n        proof[2] = hex\"df808080808080c9823262856176616c338080808080808080808573686f7274\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof7_succeeds() external {\n        bytes32 root = 0xcb65032e2f76c48b82b5c24b3db8f670ce73982869d38cd39a624f23d62a9e89;\n        bytes memory key = hex\"6b657933\";\n        bytes memory val = hex\"31323334353637383930313233343536373839303132333435363738393031\";\n        bytes[] memory proof = new bytes[](3);\n        proof[\n            0\n        ] = hex\"e68416b65793a0f3f387240403976788281c0a6ee5b3fc08360d276039d635bb824ea7e6fed779\";\n        proof[\n            1\n        ] = hex\"f87180a034d14ccc7685aa2beb64f78b11ee2a335eae82047ef97c79b7dda7f0732b9f4ca05fb052b64e23d177131d9f32e9c5b942209eb7229e9a07c99a5d93245f53af18a09a137197a43a880648d5887cce656a5e6bbbe5e44ecb4f264395ccaddbe1acca80808080808080808080808080\";\n        proof[\n            2\n        ] = hex\"f839808080808080c9823363856176616c338080808080808080809f31323334353637383930313233343536373839303132333435363738393031\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof8_succeeds() external {\n        bytes32 root = 0x72e6c01ad0c9a7b517d4bc68a5b323287fe80f0e68f5415b4b95ecbc8ad83978;\n        bytes memory key = hex\"61\";\n        bytes memory val = hex\"61\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"d916d780c22061c22062c2206380808080808080808080808080\";\n        proof[1] = hex\"d780c22061c22062c2206380808080808080808080808080\";\n        proof[2] = hex\"c22061\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof9_succeeds() external {\n        bytes32 root = 0x72e6c01ad0c9a7b517d4bc68a5b323287fe80f0e68f5415b4b95ecbc8ad83978;\n        bytes memory key = hex\"62\";\n        bytes memory val = hex\"62\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"d916d780c22061c22062c2206380808080808080808080808080\";\n        proof[1] = hex\"d780c22061c22062c2206380808080808080808080808080\";\n        proof[2] = hex\"c22062\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_validProof10_succeeds() external {\n        bytes32 root = 0x72e6c01ad0c9a7b517d4bc68a5b323287fe80f0e68f5415b4b95ecbc8ad83978;\n        bytes memory key = hex\"63\";\n        bytes memory val = hex\"63\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"d916d780c22061c22062c2206380808080808080808080808080\";\n        proof[1] = hex\"d780c22061c22062c2206380808080808080808080808080\";\n        proof[2] = hex\"c22063\";\n\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    function test_get_nonexistentKey1_reverts() external {\n        bytes32 root = 0xd582f99275e227a1cf4284899e5ff06ee56da8859be71b553397c69151bc942f;\n        bytes memory key = hex\"6b657932\";\n        bytes[] memory proof = new bytes[](3);\n        proof[\n            0\n        ] = hex\"e68416b65793a03101b4447781f1e6c51ce76c709274fc80bd064f3a58ff981b6015348a826386\";\n        proof[\n            1\n        ] = hex\"f84580a0582eed8dd051b823d13f8648cdcd08aa2d8dac239f458863c4620e8c4d605debca83206262856176616c32ca83206363856176616c3380808080808080808080808080\";\n        proof[2] = hex\"ca83206262856176616c32\";\n\n        vm.expectRevert(\"MerkleTrie: path remainder must share all nibbles with key\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_nonexistentKey2_reverts() external {\n        bytes32 root = 0xd582f99275e227a1cf4284899e5ff06ee56da8859be71b553397c69151bc942f;\n        bytes memory key = hex\"616e7972616e646f6d6b6579\";\n        bytes[] memory proof = new bytes[](1);\n        proof[\n            0\n        ] = hex\"e68416b65793a03101b4447781f1e6c51ce76c709274fc80bd064f3a58ff981b6015348a826386\";\n\n        vm.expectRevert(\"MerkleTrie: path remainder must share all nibbles with key\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_wrongKeyProof_reverts() external {\n        bytes32 root = 0x2858eebfa9d96c8a9e6a0cae9d86ec9189127110f132d63f07d3544c2a75a696;\n        bytes memory key = hex\"6b6579316161\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"e216a04892c039d654f1be9af20e88ae53e9ab5fa5520190e0fb2f805823e45ebad22f\";\n        proof[\n            1\n        ] = hex\"f84780d687206e6f746865728d33343938683472697568677765808080808080808080a0854405b57aa6dc458bc41899a761cbbb1f66a4998af6dd0e8601c1b845395ae38080808080\";\n        proof[2] = hex\"d687206e6f746865728d33343938683472697568677765\";\n\n        vm.expectRevert(\"MerkleTrie: invalid internal node hash\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_corruptedProof_reverts() external {\n        bytes32 root = 0x2858eebfa9d96c8a9e6a0cae9d86ec9189127110f132d63f07d3544c2a75a696;\n        bytes memory key = hex\"6b6579326262\";\n        bytes[] memory proof = new bytes[](5);\n        proof[0] = hex\"2fd2ba5ee42358802ffbe0900152a55fabe953ae880ef29abef154d639c09248a016e2\";\n        proof[\n            1\n        ] = hex\"f84780d687206e6f746865728d33343938683472697568677765808080808080808080a0854405b57aa6dc458bc41899a761cbbb1f66a4998af6dd0e8601c1b845395ae38080808080\";\n        proof[\n            2\n        ] = hex\"e583165793a03101b4447781f1e6c51ce76c709274fc80bd064f3a58ff981b6015348a826386\";\n        proof[\n            3\n        ] = hex\"f84580a0582eed8dd051b823d13f8648cdcd08aa2d8dac239f458863c4620e8c4d605debca83206262856176616c32ca83206363856176616c3380808080808080808080808080\";\n        proof[4] = hex\"ca83206262856176616c32\";\n\n        vm.expectRevert(\"RLPReader: decoded item type for list is not a list item\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_invalidDataRemainder_reverts() external {\n        bytes32 root = 0x278c88eb59beba4f8b94f940c41614bb0dd80c305859ebffcd6ce07c93ca3749;\n        bytes memory key = hex\"aa\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"d91ad780808080808080808080c32081aac32081ab8080808080\";\n        proof[1] = hex\"d780808080808080808080c32081aac32081ab8080808080\";\n        proof[2] = hex\"c32081aa000000000000000000000000000000\";\n\n        vm.expectRevert(\"RLPReader: list item has an invalid data remainder\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_invalidInternalNodeHash_reverts() external {\n        bytes32 root = 0xa827dff1a657bb9bb9a1c3abe9db173e2f1359f15eb06f1647ea21ac7c95d8fa;\n        bytes memory key = hex\"aa\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"e21aa09862c6b113008c4204c13755693cbb868acc25ebaa98db11df8c89a0c0dd3157\";\n        proof[\n            1\n        ] = hex\"f380808080808080808080a0de2a9c6a46b6ea71ab9e881c8420570cf19e833c85df6026b04f085016e78f00c220118080808080\";\n        proof[2] = hex\"de2a9c6a46b6ea71ab9e881c8420570cf19e833c85df6026b04f085016e78f\";\n\n        vm.expectRevert(\"MerkleTrie: invalid internal node hash\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_zeroBranchValueLength_reverts() external {\n        bytes32 root = 0xe04b3589eef96b237cd49ccb5dcf6e654a47682bfa0961d563ab843f7ad1e035;\n        bytes memory key = hex\"aa\";\n        bytes[] memory proof = new bytes[](2);\n        proof[0] = hex\"dd8200aad98080808080808080808080c43b82aabbc43c82aacc80808080\";\n        proof[1] = hex\"d98080808080808080808080c43b82aabbc43c82aacc80808080\";\n\n        vm.expectRevert(\"MerkleTrie: value length must be greater than zero (branch)\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_zeroLengthKey_reverts() external {\n        bytes32 root = 0x54157fd62cdf2f474e7bfec2d3cd581e807bee38488c9590cb887add98936b73;\n        bytes memory key = hex\"\";\n        bytes[] memory proof = new bytes[](1);\n        proof[0] = hex\"c78320f00082b443\";\n\n        vm.expectRevert(\"MerkleTrie: empty key\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_smallerPathThanKey1_reverts() external {\n        bytes32 root = 0xa513ba530659356fb7588a2c831944e80fd8aedaa5a4dc36f918152be2be0605;\n        bytes memory key = hex\"01\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"db10d9c32081bbc582202381aa808080808080808080808080808080\";\n        proof[1] = hex\"d9c32081bbc582202381aa808080808080808080808080808080\";\n        proof[2] = hex\"c582202381aa\";\n\n        vm.expectRevert(\"MerkleTrie: path remainder must share all nibbles with key\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_smallerPathThanKey2_reverts() external {\n        bytes32 root = 0xa06abffaec4ebe8ccde595f4547b864b4421b21c1fc699973f94710c9bc17979;\n        bytes memory key = hex\"aa\";\n        bytes[] memory proof = new bytes[](3);\n        proof[0] = hex\"e21aa07ea462226a3dc0a46afb4ded39306d7a84d311ada3557dfc75a909fd25530905\";\n        proof[\n            1\n        ] = hex\"f380808080808080808080a027f11bd3af96d137b9287632f44dd00fea1ca1bd70386c30985ede8cc287476e808080c220338080\";\n        proof[2] = hex\"e48200bba0a6911545ed01c2d3f4e15b8b27c7bfba97738bd5e6dd674dd07033428a4c53af\";\n\n        vm.expectRevert(\"MerkleTrie: path remainder must share all nibbles with key\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    function test_get_extraProofElements_reverts() external {\n        bytes32 root = 0x278c88eb59beba4f8b94f940c41614bb0dd80c305859ebffcd6ce07c93ca3749;\n        bytes memory key = hex\"aa\";\n        bytes[] memory proof = new bytes[](4);\n        proof[0] = hex\"d91ad780808080808080808080c32081aac32081ab8080808080\";\n        proof[1] = hex\"d780808080808080808080c32081aac32081ab8080808080\";\n        proof[2] = hex\"c32081aa\";\n        proof[3] = hex\"c32081aa\";\n\n        vm.expectRevert(\"MerkleTrie: value node must be last node in proof (leaf)\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_validProofs_succeeds(bytes4) external {\n        // Generate a test case with a valid proof of inclusion for the k/v pair in the trie.\n        (bytes32 root, bytes memory key, bytes memory val, bytes[] memory proof) = ffi\n            .getMerkleTrieFuzzCase(\"valid\");\n\n        // Assert that our expected value is equal to our actual value.\n        assertEq(val, MerkleTrie.get(key, proof, root));\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_invalidRoot_reverts(bytes4) external {\n        // Get a random test case with a valid trie / proof\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"valid\"\n        );\n\n        bytes32 rootHash = keccak256(abi.encodePacked(root));\n        vm.expectRevert(\"MerkleTrie: invalid root hash\");\n        MerkleTrie.get(key, proof, rootHash);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_extraProofElements_reverts(bytes4) external {\n        // Generate an invalid test case with an extra proof element attached to an otherwise\n        // valid proof of inclusion for the passed k/v.\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"extra_proof_elems\"\n        );\n\n        vm.expectRevert(\"MerkleTrie: value node must be last node in proof (leaf)\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_invalidLargeInternalHash_reverts(bytes4) external {\n        // Generate an invalid test case where a long proof element is incorrect for the root.\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"invalid_large_internal_hash\"\n        );\n\n        vm.expectRevert(\"MerkleTrie: invalid large internal hash\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_invalidInternalNodeHash_reverts(bytes4) external {\n        // Generate an invalid test case where a small proof element is incorrect for the root.\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"invalid_internal_node_hash\"\n        );\n\n        vm.expectRevert(\"MerkleTrie: invalid internal node hash\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_corruptedProof_reverts(bytes4) external {\n        // Generate an invalid test case where the proof is malformed.\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"corrupted_proof\"\n        );\n\n        vm.expectRevert(\"RLPReader: decoded item type for list is not a list item\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_invalidDataRemainder_reverts(bytes4) external {\n        // Generate an invalid test case where a random element of the proof has more bytes than the\n        // length designates within the RLP list encoding.\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"invalid_data_remainder\"\n        );\n\n        vm.expectRevert(\"RLPReader: list item has an invalid data remainder\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_prefixedValidKey_reverts(bytes4) external {\n        // Get a random test case with a valid trie / proof and a valid key that is prefixed\n        // with random bytes\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"prefixed_valid_key\"\n        );\n\n        // Ambiguous revert check- all that we care is that it *does* fail. This case may\n        // fail within different branches.\n        vm.expectRevert();\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_emptyKey_reverts(bytes4) external {\n        // Get a random test case with a valid trie / proof and an empty key\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"empty_key\"\n        );\n\n        vm.expectRevert(\"MerkleTrie: empty key\");\n        MerkleTrie.get(key, proof, root);\n    }\n\n    /// @notice The `bytes4` parameter is to enable parallel fuzz runs; it is ignored.\n    function testFuzz_get_partialProof_reverts(bytes4) external {\n        // Get a random test case with a valid trie / partially correct proof\n        (bytes32 root, bytes memory key, , bytes[] memory proof) = ffi.getMerkleTrieFuzzCase(\n            \"partial_proof\"\n        );\n\n        vm.expectRevert(\"MerkleTrie: ran out of proof elements\");\n        MerkleTrie.get(key, proof, root);\n    }\n}\n"
    },
    "contracts/test/MintManager.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { MintManager } from \"../governance/MintManager.sol\";\nimport { GovernanceToken } from \"../governance/GovernanceToken.sol\";\n\ncontract MintManager_Initializer is CommonTest {\n    address constant owner = address(0x1234);\n    address constant rando = address(0x5678);\n    GovernanceToken internal gov;\n    MintManager internal manager;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.prank(owner);\n        gov = new GovernanceToken();\n\n        vm.prank(owner);\n        manager = new MintManager(owner, address(gov));\n\n        vm.prank(owner);\n        gov.transferOwnership(address(manager));\n    }\n}\n\ncontract MintManager_constructor_Test is MintManager_Initializer {\n    /**\n     * @notice Tests that the constructor properly configures the contract.\n     */\n    function test_constructor_succeeds() external {\n        assertEq(manager.owner(), owner);\n        assertEq(address(manager.governanceToken()), address(gov));\n    }\n}\n\ncontract MintManager_mint_Test is MintManager_Initializer {\n    /**\n     * @notice Tests that the mint function properly mints tokens when called by the owner.\n     */\n    function test_mint_fromOwner_succeeds() external {\n        // Mint once.\n        vm.prank(owner);\n        manager.mint(owner, 100);\n\n        // Token balance increases.\n        assertEq(gov.balanceOf(owner), 100);\n    }\n\n    /**\n     * @notice Tests that the mint function reverts when called by a non-owner.\n     */\n    function test_mint_fromNotOwner_reverts() external {\n        // Mint from rando fails.\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        manager.mint(owner, 100);\n    }\n\n    /**\n     * @notice Tests that the mint function properly mints tokens when called by the owner a second\n     *         time after the mint period has elapsed.\n     */\n    function test_mint_afterPeriodElapsed_succeeds() external {\n        // Mint once.\n        vm.prank(owner);\n        manager.mint(owner, 100);\n\n        // Token balance increases.\n        assertEq(gov.balanceOf(owner), 100);\n\n        // Mint again after period elapsed (2% max).\n        vm.warp(block.timestamp + manager.MINT_PERIOD() + 1);\n        vm.prank(owner);\n        manager.mint(owner, 2);\n\n        // Token balance increases.\n        assertEq(gov.balanceOf(owner), 102);\n    }\n\n    /**\n     * @notice Tests that the mint function always reverts when called before the mint period has\n     *         elapsed, even if the caller is the owner.\n     */\n    function test_mint_beforePeriodElapsed_reverts() external {\n        // Mint once.\n        vm.prank(owner);\n        manager.mint(owner, 100);\n\n        // Token balance increases.\n        assertEq(gov.balanceOf(owner), 100);\n\n        // Mint again.\n        vm.prank(owner);\n        vm.expectRevert(\"MintManager: minting not permitted yet\");\n        manager.mint(owner, 100);\n\n        // Token balance does not increase.\n        assertEq(gov.balanceOf(owner), 100);\n    }\n\n    /**\n     * @notice Tests that the owner cannot mint more than the mint cap.\n     */\n    function test_mint_moreThanCap_reverts() external {\n        // Mint once.\n        vm.prank(owner);\n        manager.mint(owner, 100);\n\n        // Token balance increases.\n        assertEq(gov.balanceOf(owner), 100);\n\n        // Mint again (greater than 2% max).\n        vm.warp(block.timestamp + manager.MINT_PERIOD() + 1);\n        vm.prank(owner);\n        vm.expectRevert(\"MintManager: mint amount exceeds cap\");\n        manager.mint(owner, 3);\n\n        // Token balance does not increase.\n        assertEq(gov.balanceOf(owner), 100);\n    }\n}\n\ncontract MintManager_upgrade_Test is MintManager_Initializer {\n    /**\n     * @notice Tests that the owner can upgrade the mint manager.\n     */\n    function test_upgrade_fromOwner_succeeds() external {\n        // Upgrade to new manager.\n        vm.prank(owner);\n        manager.upgrade(rando);\n\n        // New manager is rando.\n        assertEq(gov.owner(), rando);\n    }\n\n    /**\n     * @notice Tests that the upgrade function reverts when called by a non-owner.\n     */\n    function test_upgrade_fromNotOwner_reverts() external {\n        // Upgrade from rando fails.\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        manager.upgrade(rando);\n    }\n\n    /**\n     * @notice Tests that the upgrade function reverts when attempting to update to the zero\n     *         address, even if the caller is the owner.\n     */\n    function test_upgrade_toZeroAddress_reverts() external {\n        // Upgrade to zero address fails.\n        vm.prank(owner);\n        vm.expectRevert(\"MintManager: mint manager cannot be the zero address\");\n        manager.upgrade(address(0));\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC20.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport {\n    ILegacyMintableERC20,\n    IOptimismMintableERC20\n} from \"../universal/IOptimismMintableERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract OptimismMintableERC20_Test is Bridge_Initializer {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    function test_semver_succeeds() external {\n        assertEq(L2Token.version(), \"1.0.0\");\n    }\n\n    function test_remoteToken_succeeds() external {\n        assertEq(L2Token.remoteToken(), address(L1Token));\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(L2Token.bridge(), address(L2Bridge));\n    }\n\n    function test_l1Token_succeeds() external {\n        assertEq(L2Token.l1Token(), address(L1Token));\n    }\n\n    function test_l2Bridge_succeeds() external {\n        assertEq(L2Token.l2Bridge(), address(L2Bridge));\n    }\n\n    function test_legacy_succeeds() external {\n        // Getters for the remote token\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n        assertEq(L2Token.remoteToken(), address(L1Token));\n        assertEq(L2Token.l1Token(), address(L1Token));\n        // Getters for the bridge\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n        assertEq(L2Token.bridge(), address(L2Bridge));\n        assertEq(L2Token.l2Bridge(), address(L2Bridge));\n    }\n\n    function test_mint_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 100);\n    }\n\n    function test_mint_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"OptimismMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.mint(alice, 100);\n    }\n\n    function test_burn_succeeds() external {\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"OptimismMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 100);\n    }\n\n    function test_erc165_supportsInterface_succeeds() external {\n        // The assertEq calls in this test are comparing the manual calculation of the iface,\n        // with what is returned by the solidity's type().interfaceId, just to be safe.\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n        assertEq(iface1, type(IERC165).interfaceId);\n        assert(L2Token.supportsInterface(iface1));\n\n        bytes4 iface2 = L2Token.l1Token.selector ^ L2Token.mint.selector ^ L2Token.burn.selector;\n        assertEq(iface2, type(ILegacyMintableERC20).interfaceId);\n        assert(L2Token.supportsInterface(iface2));\n\n        bytes4 iface3 = L2Token.remoteToken.selector ^\n            L2Token.bridge.selector ^\n            L2Token.mint.selector ^\n            L2Token.burn.selector;\n        assertEq(iface3, type(IOptimismMintableERC20).interfaceId);\n        assert(L2Token.supportsInterface(iface3));\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC20Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract OptimismMintableTokenFactory_Test is Bridge_Initializer {\n    event StandardL2TokenCreated(address indexed remoteToken, address indexed localToken);\n    event OptimismMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(address(L2TokenFactory.BRIDGE()), address(L2Bridge));\n    }\n\n    function test_createStandardL2Token_succeeds() external {\n        address remote = address(4);\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit StandardL2TokenCreated(remote, local);\n\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createStandardL2Token_sameTwice_succeeds() external {\n        address remote = address(4);\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 3);\n\n        vm.expectEmit(true, true, true, true);\n        emit StandardL2TokenCreated(remote, local);\n\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createStandardL2Token_remoteIsZero_succeeds() external {\n        address remote = address(0);\n        vm.expectRevert(\"OptimismMintableERC20Factory: must provide remote token address\");\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC721.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {\n    IERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport {\n    OptimismMintableERC721,\n    IOptimismMintableERC721\n} from \"../universal/OptimismMintableERC721.sol\";\n\ncontract OptimismMintableERC721_Test is ERC721Bridge_Initializer {\n    ERC721 internal L1Token;\n    OptimismMintableERC721 internal L2Token;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Mint(address indexed account, uint256 tokenId);\n\n    event Burn(address indexed account, uint256 tokenId);\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        L1Token = new ERC721(\"L1Token\", \"L1T\");\n        L2Token = new OptimismMintableERC721(\n            address(L2Bridge),\n            1,\n            address(L1Token),\n            \"L2Token\",\n            \"L2T\"\n        );\n\n        // Label the addresses for nice traces.\n        vm.label(address(L1Token), \"L1ERC721Token\");\n        vm.label(address(L2Token), \"L2ERC721Token\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(L2Token.name(), \"L2Token\");\n        assertEq(L2Token.symbol(), \"L2T\");\n        assertEq(L2Token.remoteToken(), address(L1Token));\n        assertEq(L2Token.bridge(), address(L2Bridge));\n        assertEq(L2Token.remoteChainId(), 1);\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n        assertEq(L2Token.REMOTE_CHAIN_ID(), 1);\n        assertEq(L2Token.version(), \"1.1.0\");\n    }\n\n    /**\n     * @notice Ensure that the contract supports the expected interfaces.\n     */\n    function test_supportsInterfaces_succeeds() external {\n        // Checks if the contract supports the IOptimismMintableERC721 interface.\n        assertTrue(L2Token.supportsInterface(type(IOptimismMintableERC721).interfaceId));\n        // Checks if the contract supports the IERC721Enumerable interface.\n        assertTrue(L2Token.supportsInterface(type(IERC721Enumerable).interfaceId));\n        // Checks if the contract supports the IERC721 interface.\n        assertTrue(L2Token.supportsInterface(type(IERC721).interfaceId));\n        // Checks if the contract supports the IERC165 interface.\n        assertTrue(L2Token.supportsInterface(type(IERC165).interfaceId));\n    }\n\n    function test_safeMint_succeeds() external {\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), alice, 1);\n\n        // Expect a mint event.\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 1);\n\n        // Mint the token.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token should be owned by alice.\n        assertEq(L2Token.ownerOf(1), alice);\n    }\n\n    function test_safeMint_notBridge_reverts() external {\n        // Try to mint the token.\n        vm.expectRevert(\"OptimismMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.safeMint(alice, 1);\n    }\n\n    function test_burn_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(alice, address(0), 1);\n\n        // Expect a burn event.\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 1);\n\n        // Burn the token.\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 1);\n\n        // Token should be owned by address(0).\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        L2Token.ownerOf(1);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Try to burn the token.\n        vm.expectRevert(\"OptimismMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 1);\n    }\n\n    function test_tokenURI_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token URI should be correct.\n        assertEq(\n            L2Token.tokenURI(1),\n            string(\n                abi.encodePacked(\n                    \"ethereum:\",\n                    Strings.toHexString(uint160(address(L1Token)), 20),\n                    \"@\",\n                    Strings.toString(1),\n                    \"/tokenURI?uint256=\",\n                    Strings.toString(1)\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC721Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\nimport { OptimismMintableERC721 } from \"../universal/OptimismMintableERC721.sol\";\nimport { OptimismMintableERC721Factory } from \"../universal/OptimismMintableERC721Factory.sol\";\n\ncontract OptimismMintableERC721Factory_Test is ERC721Bridge_Initializer {\n    OptimismMintableERC721Factory internal factory;\n\n    event OptimismMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        factory = new OptimismMintableERC721Factory(address(L2Bridge), 1);\n\n        // Label the addresses for nice traces.\n        vm.label(address(factory), \"OptimismMintableERC721Factory\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(factory.BRIDGE(), address(L2Bridge));\n        assertEq(factory.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createOptimismMintableERC721_succeeds() external {\n        // Predict the address based on the factory address and nonce.\n        address predicted = LibRLP.computeAddress(address(factory), 1);\n\n        // Expect a token creation event.\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableERC721Created(predicted, address(1234), alice);\n\n        // Create the token.\n        vm.prank(alice);\n        OptimismMintableERC721 created = OptimismMintableERC721(\n            factory.createOptimismMintableERC721(address(1234), \"L2Token\", \"L2T\")\n        );\n\n        // Token address should be correct.\n        assertEq(address(created), predicted);\n\n        // Should be marked as created by the factory.\n        assertEq(factory.isOptimismMintableERC721(address(created)), true);\n\n        // Token should've been constructed correctly.\n        assertEq(created.name(), \"L2Token\");\n        assertEq(created.symbol(), \"L2T\");\n        assertEq(created.REMOTE_TOKEN(), address(1234));\n        assertEq(created.BRIDGE(), address(L2Bridge));\n        assertEq(created.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createOptimismMintableERC721_zeroRemoteToken_reverts() external {\n        // Try to create a token with a zero remote token address.\n        vm.expectRevert(\"OptimismMintableERC721Factory: L1 token address cannot be address(0)\");\n        factory.createOptimismMintableERC721(address(0), \"L2Token\", \"L2T\");\n    }\n}\n"
    },
    "contracts/test/OptimismPortal.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\nimport { Portal_Initializer, CommonTest, NextImpl } from \"./CommonTest.t.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\ncontract OptimismPortal_Test is Portal_Initializer {\n    event Paused(address);\n    event Unpaused(address);\n\n    function test_constructor_succeeds() external {\n        assertEq(address(op.L2_ORACLE()), address(oracle));\n        assertEq(op.l2Sender(), 0x000000000000000000000000000000000000dEaD);\n        assertEq(op.paused(), false);\n    }\n\n    /**\n     * @notice The OptimismPortal can be paused by the GUARDIAN\n     */\n    function test_pause_succeeds() external {\n        address guardian = op.GUARDIAN();\n\n        assertEq(op.paused(), false);\n\n        vm.expectEmit(true, true, true, true, address(op));\n        emit Paused(guardian);\n\n        vm.prank(guardian);\n        op.pause();\n\n        assertEq(op.paused(), true);\n    }\n\n    /**\n     * @notice The OptimismPortal reverts when an account that is not the\n     *         GUARDIAN calls `pause()`\n     */\n    function test_pause_onlyGuardian_reverts() external {\n        assertEq(op.paused(), false);\n\n        assertTrue(op.GUARDIAN() != alice);\n        vm.expectRevert(\"OptimismPortal: only guardian can pause\");\n        vm.prank(alice);\n        op.pause();\n\n        assertEq(op.paused(), false);\n    }\n\n    /**\n     * @notice The OptimismPortal can be unpaused by the GUARDIAN\n     */\n    function test_unpause_succeeds() external {\n        address guardian = op.GUARDIAN();\n\n        vm.prank(guardian);\n        op.pause();\n        assertEq(op.paused(), true);\n\n        vm.expectEmit(true, true, true, true, address(op));\n        emit Unpaused(guardian);\n        vm.prank(guardian);\n        op.unpause();\n\n        assertEq(op.paused(), false);\n    }\n\n    /**\n     * @notice The OptimismPortal reverts when an account that is not\n     *         the GUARDIAN calls `unpause()`\n     */\n    function test_unpause_onlyGuardian_reverts() external {\n        address guardian = op.GUARDIAN();\n\n        vm.prank(guardian);\n        op.pause();\n        assertEq(op.paused(), true);\n\n        assertTrue(op.GUARDIAN() != alice);\n        vm.expectRevert(\"OptimismPortal: only guardian can unpause\");\n        vm.prank(alice);\n        op.unpause();\n\n        assertEq(op.paused(), true);\n    }\n\n    function test_receive_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(alice, alice, 100, 100, 100_000, false, hex\"\");\n\n        // give alice money and send as an eoa\n        vm.deal(alice, 2**64);\n        vm.prank(alice, alice);\n        (bool s, ) = address(op).call{ value: 100 }(hex\"\");\n\n        assert(s);\n        assertEq(address(op).balance, 100);\n    }\n\n    // Test: depositTransaction fails when contract creation has a non-zero destination address\n    function test_depositTransaction_contractCreation_reverts() external {\n        // contract creation must have a target of address(0)\n        vm.expectRevert(\"OptimismPortal: must send to address(0) when creating a contract\");\n        op.depositTransaction(address(1), 1, 0, true, hex\"\");\n    }\n\n    /**\n     * @notice Prevent deposits from being too large to have a sane upper bound\n     *         on unsafe blocks sent over the p2p network.\n     */\n    function test_depositTransaction_largeData_reverts() external {\n        uint256 size = 120_001;\n        uint64 gasLimit = op.minimumGasLimit(uint64(size));\n        vm.expectRevert(\"OptimismPortal: data too large\");\n        op.depositTransaction({\n            _to: address(0),\n            _value: 0,\n            _gasLimit: gasLimit,\n            _isCreation: false,\n            _data: new bytes(size)\n        });\n    }\n\n    /**\n     * @notice Prevent gasless deposits from being force processed in L2 by\n     *         ensuring that they have a large enough gas limit set.\n     */\n    function test_depositTransaction_smallGasLimit_reverts() external {\n        vm.expectRevert(\"OptimismPortal: gas limit too small\");\n        op.depositTransaction({\n            _to: address(1),\n            _value: 0,\n            _gasLimit: 0,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n\n    /**\n     * @notice Fuzz for too small of gas limits\n     */\n    function testFuzz_depositTransaction_smallGasLimit_succeeds(\n        bytes memory _data,\n        bool _shouldFail\n    ) external {\n        vm.assume(_data.length <= type(uint64).max);\n\n        uint64 gasLimit = op.minimumGasLimit(uint64(_data.length));\n        if (_shouldFail) {\n            gasLimit = uint64(bound(gasLimit, 0, gasLimit - 1));\n            vm.expectRevert(\"OptimismPortal: gas limit too small\");\n        }\n\n        op.depositTransaction({\n            _to: address(0x40),\n            _value: 0,\n            _gasLimit: gasLimit,\n            _isCreation: false,\n            _data: _data\n        });\n    }\n\n    /**\n     * @notice Ensure that the 0 calldata case is covered and there is a linearly\n     *         increasing gas limit for larger calldata sizes.\n     */\n    function test_minimumGasLimit_succeeds() external {\n        assertEq(op.minimumGasLimit(0), 21_000);\n        assertTrue(op.minimumGasLimit(2) > op.minimumGasLimit(1));\n        assertTrue(op.minimumGasLimit(3) > op.minimumGasLimit(2));\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a tx with 0 value\n    function test_depositTransaction_noValueEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a tx with 0 value\n    function test_depositTransaction_noValueContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndEOAContractCreation_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndContractContractCreation_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    function test_simple_isOutputFinalized_succeeds() external {\n        uint256 ts = block.timestamp;\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.OutputProposal(bytes32(uint256(1)), uint128(ts), uint128(startingBlockNumber))\n            )\n        );\n\n        // warp to the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS());\n        assertEq(op.isOutputFinalized(0), false);\n\n        // warp past the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        assertEq(op.isOutputFinalized(0), true);\n    }\n\n    function test_isOutputFinalized_succeeds() external {\n        uint256 checkpoint = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        vm.roll(checkpoint);\n        vm.warp(oracle.computeL2Timestamp(checkpoint) + 1);\n        vm.prank(oracle.PROPOSER());\n        oracle.proposeL2Output(keccak256(abi.encode(2)), checkpoint, 0, 0);\n\n        // warp to the final second of the finalization period\n        uint256 finalizationHorizon = block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS();\n        vm.warp(finalizationHorizon);\n        // The checkpointed block should not be finalized until 1 second from now.\n        assertEq(op.isOutputFinalized(nextOutputIndex), false);\n        // Nor should a block after it\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(op.isOutputFinalized(nextOutputIndex + 1), false);\n\n        // warp past the finalization period\n        vm.warp(finalizationHorizon + 1);\n        // It should now be finalized.\n        assertEq(op.isOutputFinalized(nextOutputIndex), true);\n        // But not the block after it.\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(op.isOutputFinalized(nextOutputIndex + 1), false);\n    }\n}\n\ncontract OptimismPortal_FinalizeWithdrawal_Test is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _proposedOutputIndex;\n    uint256 _proposedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _proposedBlockNumber = oracle.nextBlockNumber();\n        _proposedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_proposedBlockNumber) + 1);\n        vm.prank(oracle.PROPOSER());\n        oracle.proposeL2Output(_outputRoot, _proposedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've proposed.\n        vm.warp(\n            oracle.getL2Output(_proposedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(op), 0xFFFFFFFF);\n    }\n\n    // Utility function used in the subsequent test. This is necessary to assert that the\n    // reentrant call will revert.\n    function callPortalAndExpectRevert() external payable {\n        vm.expectRevert(\"OptimismPortal: can only trigger one withdrawal per transaction\");\n        // Arguments here don't matter, as the require check is the first thing that happens.\n        // We assume that this has already been proven.\n        op.finalizeWithdrawalTransaction(_defaultTx);\n        // Assert that the withdrawal was not finalized.\n        assertFalse(op.finalizedWithdrawals(Hashing.hashWithdrawal(_defaultTx)));\n    }\n\n    /**\n     * @notice Proving withdrawal transactions should revert when paused\n     */\n    function test_proveWithdrawalTransaction_paused_reverts() external {\n        vm.prank(op.GUARDIAN());\n        op.pause();\n\n        vm.expectRevert(\"OptimismPortal: paused\");\n        op.proveWithdrawalTransaction({\n            _tx: _defaultTx,\n            _l2OutputIndex: _proposedOutputIndex,\n            _outputRootProof: _outputRootProof,\n            _withdrawalProof: _withdrawalProof\n        });\n    }\n\n    // Test: proveWithdrawalTransaction cannot prove a withdrawal with itself (the OptimismPortal) as the target.\n    function test_proveWithdrawalTransaction_onSelfCall_reverts() external {\n        _defaultTx.target = address(op);\n        vm.expectRevert(\"OptimismPortal: you cannot send messages to the portal contract\");\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the outputRootProof does not match the output root\n    function test_proveWithdrawalTransaction_onInvalidOutputRootProof_reverts() external {\n        // Modify the version to invalidate the withdrawal proof.\n        _outputRootProof.version = bytes32(uint256(1));\n        vm.expectRevert(\"OptimismPortal: invalid output root proof\");\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the proof is invalid due to non-existence of\n    // the withdrawal.\n    function test_proveWithdrawalTransaction_onInvalidWithdrawalProof_reverts() external {\n        // modify the default test values to invalidate the proof.\n        _defaultTx.data = hex\"abcd\";\n        vm.expectRevert(\"MerkleTrie: path remainder must share all nibbles with key\");\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the passed transaction's withdrawalHash has\n    // already been proven.\n    function test_proveWithdrawalTransaction_replayProve_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"OptimismPortal: withdrawal hash has already been proven\");\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root has changed AND the l2BlockNumber stays the same.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRoot_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in the OptimismPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a different output root within the `provenWithdrawals` mapping without\n        // touching the l2BlockNumber or timestamp.\n        vm.store(address(op), slot, bytes32(0));\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = op.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root + output index + l2BlockNumber changes.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRootAndOutputIndex_succeeds()\n        external\n    {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in OptimismPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a dummy output root within the `provenWithdrawals` mapping without touching the\n        // l2BlockNumber or timestamp.\n        vm.store(address(op), slot, bytes32(0));\n\n        // Fetch the output proposal at `_proposedOutputIndex` from the L2OutputOracle\n        Types.OutputProposal memory proposal = op.L2_ORACLE().getL2Output(_proposedOutputIndex);\n\n        // Propose the same output root again, creating the same output at a different index + l2BlockNumber.\n        vm.startPrank(op.L2_ORACLE().PROPOSER());\n        op.L2_ORACLE().proposeL2Output(\n            proposal.outputRoot,\n            op.L2_ORACLE().nextBlockNumber(),\n            blockhash(block.number),\n            block.number\n        );\n        vm.stopPrank();\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot + a different output index\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex + 1,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = op.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds and emits the WithdrawalProven event.\n    function test_proveWithdrawalTransaction_validWithdrawalProof_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction succeeds and emits the WithdrawalFinalized event.\n    function test_finalizeWithdrawalTransaction_provenWithdrawalHash_succeeds() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, false, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore + 100);\n    }\n\n    /**\n     * @notice Finalizing withdrawal transactions should revert when paused\n     */\n    function test_finalizeWithdrawalTransaction_paused_reverts() external {\n        vm.prank(op.GUARDIAN());\n        op.pause();\n\n        vm.expectRevert(\"OptimismPortal: paused\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has not been proven.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalNotProven_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectRevert(\"OptimismPortal: withdrawal has not been proven yet\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if withdrawal not proven long enough ago.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalProofNotOldEnough_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Mock a call where the resulting output root is anything but the original output root. In\n        // this case we just use bytes32(uint256(1)).\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(bytes32(uint256(1)), _proposedBlockNumber)\n        );\n\n        vm.expectRevert(\"OptimismPortal: proven withdrawal finalization period has not elapsed\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the provenWithdrawal's timestamp is less\n    // than the L2 output oracle's starting timestamp\n    function test_finalizeWithdrawalTransaction_timestampLessThanL2OracleStart_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a startingTimestamp change on the L2 Oracle\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSignature(\"startingTimestamp()\"),\n            abi.encode(block.timestamp + 1)\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the output root proven is not the same as the\n    // output root at the time of finalization.\n    function test_finalizeWithdrawalTransaction_ifOutputRootChanges_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock an outputRoot change on the output proposal before attempting\n        // to finalize the withdrawal.\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.OutputProposal(\n                    bytes32(uint256(0)),\n                    uint128(block.timestamp),\n                    uint128(_proposedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the output proposal's timestamp has\n    // not passed the finalization period.\n    function test_finalizeWithdrawalTransaction_ifOutputTimestampIsNotFinalized_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a timestamp change on the output proposal that has not passed the\n        // finalization period.\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.OutputProposal(\n                    _outputRoot,\n                    uint128(block.timestamp + 1),\n                    uint128(_proposedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"OptimismPortal: output proposal finalization period has not elapsed\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction fails because the target reverts,\n    // and emits the WithdrawalFinalized event with success=false.\n    function test_finalizeWithdrawalTransaction_targetFails_fails() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        vm.etch(bob, hex\"fe\"); // Contract with just the invalid opcode.\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, false);\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the finalization period has not yet passed.\n    function test_finalizeWithdrawalTransaction_onRecentWithdrawal_reverts() external {\n        // Setup the Oracle to return an output with a recent timestamp\n        uint256 recentTimestamp = block.timestamp - 1000;\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.OutputProposal(\n                    _outputRoot,\n                    uint128(recentTimestamp),\n                    uint128(_proposedBlockNumber)\n                )\n            )\n        );\n\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"OptimismPortal: proven withdrawal finalization period has not elapsed\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has already been finalized.\n    function test_finalizeWithdrawalTransaction_onReplay_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        vm.expectRevert(\"OptimismPortal: withdrawal has already been finalized\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if insufficient gas is supplied.\n    function test_finalizeWithdrawalTransaction_onInsufficientGas_reverts() external {\n        // This number was identified through trial and error.\n        uint256 gasLimit = 150_000;\n        Types.WithdrawalTransaction memory insufficientGasTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: gasLimit,\n            data: hex\"\"\n        });\n\n        // Get updated proof inputs.\n        (bytes32 stateRoot, bytes32 storageRoot, , , bytes[] memory withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(insufficientGasTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(0),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            latestBlockhash: bytes32(0)\n        });\n\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.OutputProposal(\n                    Hashing.hashOutputRootProof(outputRootProof),\n                    uint128(block.timestamp),\n                    uint128(_proposedBlockNumber)\n                )\n            )\n        );\n\n        op.proveWithdrawalTransaction(\n            insufficientGasTx,\n            _proposedOutputIndex,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectRevert(\"SafeCall: Not enough gas\");\n        op.finalizeWithdrawalTransaction{ gas: gasLimit }(insufficientGasTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if a sub-call attempts to finalize another\n    // withdrawal.\n    function test_finalizeWithdrawalTransaction_onReentrancy_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Copy and modify the default test values to attempt a reentrant call by first calling to\n        // this contract's callPortalAndExpectRevert() function above.\n        Types.WithdrawalTransaction memory _testTx = _defaultTx;\n        _testTx.target = address(this);\n        _testTx.data = abi.encodeWithSelector(this.callPortalAndExpectRevert.selector);\n\n        // Get modified proof inputs.\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_testTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(0),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            latestBlockhash: bytes32(0)\n        });\n\n        // Setup the Oracle to return the outputRoot we want as well as a finalized timestamp.\n        uint256 finalizedTimestamp = block.timestamp - oracle.FINALIZATION_PERIOD_SECONDS() - 1;\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.OutputProposal(\n                    outputRoot,\n                    uint128(finalizedTimestamp),\n                    uint128(_proposedBlockNumber)\n                )\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(withdrawalHash, alice, address(this));\n        op.proveWithdrawalTransaction(\n            _testTx,\n            _proposedBlockNumber,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectCall(address(this), _testTx.data);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(withdrawalHash, true);\n        op.finalizeWithdrawalTransaction(_testTx);\n\n        // Ensure that bob's balance was not changed by the reentrant call.\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    function testDiff_finalizeWithdrawalTransaction_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        vm.assume(\n            _target != address(op) && // Cannot call the optimism portal or a contract\n                _target.code.length == 0 && // No accounts with code\n                _target != CONSOLE && // The console has no code but behaves like a contract\n                uint160(_target) > 9 // No precompiles (or zero address)\n        );\n\n        // Total ETH supply is currently about 120M ETH.\n        uint256 value = bound(_value, 0, 200_000_000 ether);\n        vm.deal(address(op), value);\n\n        uint256 gasLimit = bound(_gasLimit, 0, 50_000_000);\n        uint256 nonce = messagePasser.messageNonce();\n\n        // Get a withdrawal transaction and mock proof from the differential testing script.\n        Types.WithdrawalTransaction memory _tx = Types.WithdrawalTransaction({\n            nonce: nonce,\n            sender: _sender,\n            target: _target,\n            value: value,\n            gasLimit: gasLimit,\n            data: _data\n        });\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_tx);\n\n        // Create the output root proof\n        Types.OutputRootProof memory proof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n\n        // Ensure the values returned from ffi are correct\n        assertEq(outputRoot, Hashing.hashOutputRootProof(proof));\n        assertEq(withdrawalHash, Hashing.hashWithdrawal(_tx));\n\n        // Setup the Oracle to return the outputRoot\n        vm.mockCall(\n            address(oracle),\n            abi.encodeWithSelector(oracle.getL2Output.selector),\n            abi.encode(outputRoot, block.timestamp, 100)\n        );\n\n        // Prove the withdrawal transaction\n        op.proveWithdrawalTransaction(\n            _tx,\n            100, // l2BlockNumber\n            proof,\n            withdrawalProof\n        );\n        (bytes32 _root, , ) = op.provenWithdrawals(withdrawalHash);\n        assertTrue(_root != bytes32(0));\n\n        // Warp past the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction\n        vm.expectCallMinGas(_tx.target, _tx.value, uint64(_tx.gasLimit), _tx.data);\n        op.finalizeWithdrawalTransaction(_tx);\n        assertTrue(op.finalizedWithdrawals(withdrawalHash));\n    }\n}\n\ncontract OptimismPortalUpgradeable_Test is Portal_Initializer {\n    Proxy internal proxy;\n    uint64 initialBlockNum;\n\n    function setUp() public override {\n        super.setUp();\n        initialBlockNum = uint64(block.number);\n        proxy = Proxy(payable(address(op)));\n    }\n\n    function test_params_initValuesOnProxy_succeeds() external {\n        OptimismPortal p = OptimismPortal(payable(address(proxy)));\n\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = p.params();\n\n        ResourceMetering.ResourceConfig memory rcfg = systemConfig.resourceConfig();\n        assertEq(prevBaseFee, rcfg.minimumBaseFee);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_initialize_cannotInitProxy_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        OptimismPortal(payable(proxy)).initialize(false);\n    }\n\n    function test_initialize_cannotInitImpl_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        OptimismPortal(opImpl).initialize(false);\n    }\n\n    function test_upgradeToAndCall_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(op), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(op), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(op)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n\n/**\n * @title OptimismPortalResourceFuzz_Test\n * @dev Test various values of the resource metering config to ensure that deposits cannot be\n *         broken by changing the config.\n */\ncontract OptimismPortalResourceFuzz_Test is Portal_Initializer {\n    /**\n     * @dev The max gas limit observed throughout this test. Setting this too high can cause\n     *      the test to take too long to run.\n     */\n    uint256 constant MAX_GAS_LIMIT = 30_000_000;\n\n    /**\n     * @dev Test that various values of the resource metering config will not break deposits.\n     */\n    function testFuzz_systemConfigDeposit_succeeds(\n        uint32 _maxResourceLimit,\n        uint8 _elasticityMultiplier,\n        uint8 _baseFeeMaxChangeDenominator,\n        uint32 _minimumBaseFee,\n        uint32 _systemTxMaxGas,\n        uint128 _maximumBaseFee,\n        uint64 _gasLimit,\n        uint64 _prevBoughtGas,\n        uint128 _prevBaseFee,\n        uint8 _blockDiff\n    ) external {\n        // Get the set system gas limit\n        uint64 gasLimit = systemConfig.gasLimit();\n        // Bound resource config\n        _maxResourceLimit = uint32(bound(_maxResourceLimit, 21000, MAX_GAS_LIMIT / 8));\n        _gasLimit = uint64(bound(_gasLimit, 21000, _maxResourceLimit));\n        _prevBaseFee = uint128(bound(_prevBaseFee, 0, 3 gwei));\n        // Prevent values that would cause reverts\n        vm.assume(gasLimit >= _gasLimit);\n        vm.assume(_minimumBaseFee < _maximumBaseFee);\n        vm.assume(_baseFeeMaxChangeDenominator > 1);\n        vm.assume(uint256(_maxResourceLimit) + uint256(_systemTxMaxGas) <= gasLimit);\n        vm.assume(_elasticityMultiplier > 0);\n        vm.assume(\n            ((_maxResourceLimit / _elasticityMultiplier) * _elasticityMultiplier) ==\n                _maxResourceLimit\n        );\n        _prevBoughtGas = uint64(bound(_prevBoughtGas, 0, _maxResourceLimit - _gasLimit));\n        _blockDiff = uint8(bound(_blockDiff, 0, 3));\n\n        // Create a resource config to mock the call to the system config with\n        ResourceMetering.ResourceConfig memory rcfg = ResourceMetering.ResourceConfig({\n            maxResourceLimit: _maxResourceLimit,\n            elasticityMultiplier: _elasticityMultiplier,\n            baseFeeMaxChangeDenominator: _baseFeeMaxChangeDenominator,\n            minimumBaseFee: _minimumBaseFee,\n            systemTxMaxGas: _systemTxMaxGas,\n            maximumBaseFee: _maximumBaseFee\n        });\n        vm.mockCall(\n            address(systemConfig),\n            abi.encodeWithSelector(systemConfig.resourceConfig.selector),\n            abi.encode(rcfg)\n        );\n\n        // Set the resource params\n        uint256 _prevBlockNum = block.number - _blockDiff;\n        vm.store(\n            address(op),\n            bytes32(uint256(1)),\n            bytes32((_prevBlockNum << 192) | (uint256(_prevBoughtGas) << 128) | _prevBaseFee)\n        );\n        // Ensure that the storage setting is correct\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = op.params();\n        assertEq(prevBaseFee, _prevBaseFee);\n        assertEq(prevBoughtGas, _prevBoughtGas);\n        assertEq(prevBlockNum, _prevBlockNum);\n\n        // Do a deposit, should not revert\n        op.depositTransaction{ gas: MAX_GAS_LIMIT }({\n            _to: address(0x20),\n            _value: 0x40,\n            _gasLimit: _gasLimit,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n}\n"
    },
    "contracts/test/Proxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract SimpleStorage {\n    mapping(uint256 => uint256) internal store;\n\n    function get(uint256 key) external payable returns (uint256) {\n        return store[key];\n    }\n\n    function set(uint256 key, uint256 value) external payable {\n        store[key] = value;\n    }\n}\n\ncontract Clasher {\n    function upgradeTo(address) external pure {\n        revert(\"upgradeTo\");\n    }\n}\n\ncontract Proxy_Test is Test {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    address alice = address(64);\n\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n\n    bytes32 internal constant OWNER_KEY = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    Proxy proxy;\n    SimpleStorage simpleStorage;\n\n    function setUp() external {\n        // Deploy a proxy and simple storage contract as\n        // the implementation\n        proxy = new Proxy(alice);\n        simpleStorage = new SimpleStorage();\n\n        vm.prank(alice);\n        proxy.upgradeTo(address(simpleStorage));\n    }\n\n    function test_implementationKey_succeeds() external {\n        // The hardcoded implementation key should be correct\n        vm.prank(alice);\n        proxy.upgradeTo(address(6));\n\n        bytes32 key = vm.load(address(proxy), IMPLEMENTATION_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(6));\n    }\n\n    function test_ownerKey_succeeds() external {\n        // The hardcoded owner key should be correct\n        vm.prank(alice);\n        proxy.changeAdmin(address(6));\n\n        bytes32 key = vm.load(address(proxy), OWNER_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(address(6));\n        address owner = proxy.admin();\n        assertEq(owner, address(6));\n    }\n\n    function test_proxyCallToImp_notAdmin_succeeds() external {\n        // The implementation does not have a `upgradeTo`\n        // method, calling `upgradeTo` not as the owner\n        // should revert.\n        vm.expectRevert();\n        proxy.upgradeTo(address(64));\n\n        // Call `upgradeTo` as the owner, it should succeed\n        // and emit the `Upgraded` event.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(64));\n        vm.prank(alice);\n        proxy.upgradeTo(address(64));\n\n        // Get the implementation as the owner\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(64));\n    }\n\n    function test_ownerProxyCall_notAdmin_succeeds() external {\n        // Calling `changeAdmin` not as the owner should revert\n        // as the implementation does not have a `changeAdmin` method.\n        vm.expectRevert();\n        proxy.changeAdmin(address(1));\n\n        // Call `changeAdmin` as the owner, it should succeed\n        // and emit the `AdminChanged` event.\n        vm.expectEmit(true, true, true, true);\n        emit AdminChanged(alice, address(1));\n        vm.prank(alice);\n        proxy.changeAdmin(address(1));\n\n        // Calling `admin` not as the owner should\n        // revert as the implementation does not have\n        // a `admin` method.\n        vm.expectRevert();\n        proxy.admin();\n\n        // Calling `admin` as the owner should work.\n        vm.prank(address(1));\n        address owner = proxy.admin();\n        assertEq(owner, address(1));\n    }\n\n    function test_delegatesToImpl_succeeds() external {\n        // Call the storage setter on the proxy\n        SimpleStorage(address(proxy)).set(1, 1);\n\n        // The key should not be set in the implementation\n        uint256 result = simpleStorage.get(1);\n        assertEq(result, 0);\n        {\n            // The key should be set in the proxy\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n\n        {\n            // The owner should be able to call through the proxy\n            // when there is not a function selector crash\n            vm.prank(alice);\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n    }\n\n    function test_upgradeToAndCall_succeeds() external {\n        {\n            // There should be nothing in the current proxy storage\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 0);\n        }\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(simpleStorage));\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The call should have impacted the state\n        uint256 result = SimpleStorage(address(proxy)).get(1);\n        assertEq(result, 1);\n    }\n\n    function test_upgradeToAndCall_functionDoesNotExist_reverts() external {\n        // Get the current implementation address\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call. This reverts because the calldata doesn't\n        // match a function on the implementation.\n        vm.expectRevert(\"Proxy: delegatecall to new implementation contract failed\");\n        vm.prank(alice);\n        proxy.upgradeToAndCall(address(simpleStorage), hex\"\");\n\n        // The implementation address should have not\n        // updated because the call to `upgradeToAndCall`\n        // reverted.\n        vm.prank(alice);\n        address postImpl = proxy.implementation();\n        assertEq(impl, postImpl);\n\n        // The attempt to `upgradeToAndCall`\n        // should revert when it is not called by the owner.\n        vm.expectRevert();\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n    }\n\n    function test_upgradeToAndCall_isPayable_succeeds() external {\n        // Give alice some funds\n        vm.deal(alice, 1 ether);\n        // Set the implementation and call and send\n        // value.\n        vm.prank(alice);\n        proxy.upgradeToAndCall{ value: 1 ether }(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The implementation address should be correct\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // The proxy should have a balance\n        assertEq(address(proxy).balance, 1 ether);\n    }\n\n    function test_upgradeTo_clashingFunctionSignatures_succeeds() external {\n        // Clasher has a clashing function with the proxy.\n        Clasher clasher = new Clasher();\n\n        // Set the clasher as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(clasher));\n\n        {\n            // Assert that the implementation was set properly.\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(clasher));\n        }\n\n        // Call the clashing function on the proxy\n        // not as the owner so that the call passes through.\n        // The implementation will revert so we can be\n        // sure that the call passed through.\n        vm.expectRevert(bytes(\"upgradeTo\"));\n        proxy.upgradeTo(address(0));\n\n        {\n            // Now call the clashing function as the owner\n            // and be sure that it doesn't pass through to\n            // the implementation.\n            vm.prank(alice);\n            proxy.upgradeTo(address(0));\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(0));\n        }\n    }\n\n    // Allow for `eth_call` to call proxy methods\n    // by setting \"from\" to `address(0)`.\n    function test_implementation_zeroAddressCaller_succeeds() external {\n        vm.prank(address(0));\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n    }\n\n    function test_implementation_isZeroAddress_reverts() external {\n        // Set `address(0)` as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(0));\n\n        (bool success, bytes memory returndata) = address(proxy).call(hex\"\");\n        assertEq(success, false);\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Error(string)\",\n            \"Proxy: implementation not initialized\"\n        );\n\n        assertEq(returndata, err);\n    }\n}\n"
    },
    "contracts/test/ProxyAdmin.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { SimpleStorage } from \"./Proxy.t.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { ResolvedDelegateProxy } from \"../legacy/ResolvedDelegateProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\n\ncontract ProxyAdmin_Test is Test {\n    address alice = address(64);\n\n    Proxy proxy;\n    L1ChugSplashProxy chugsplash;\n    ResolvedDelegateProxy resolved;\n\n    AddressManager addressManager;\n\n    ProxyAdmin admin;\n\n    SimpleStorage implementation;\n\n    function setUp() external {\n        // Deploy the proxy admin\n        admin = new ProxyAdmin(alice);\n        // Deploy the standard proxy\n        proxy = new Proxy(address(admin));\n\n        // Deploy the legacy L1ChugSplashProxy with the admin as the owner\n        chugsplash = new L1ChugSplashProxy(address(admin));\n\n        // Deploy the legacy AddressManager\n        addressManager = new AddressManager();\n        // The proxy admin must be the new owner of the address manager\n        addressManager.transferOwnership(address(admin));\n        // Deploy a legacy ResolvedDelegateProxy with the name `a`.\n        // Whatever `a` is set to in AddressManager will be the address\n        // that is used for the implementation.\n        resolved = new ResolvedDelegateProxy(addressManager, \"a\");\n\n        // Impersonate alice for setting up the admin.\n        vm.startPrank(alice);\n        // Set the address of the address manager in the admin so that it\n        // can resolve the implementation address of legacy\n        // ResolvedDelegateProxy based proxies.\n        admin.setAddressManager(addressManager);\n        // Set the reverse lookup of the ResolvedDelegateProxy\n        // proxy\n        admin.setImplementationName(address(resolved), \"a\");\n\n        // Set the proxy types\n        admin.setProxyType(address(proxy), ProxyAdmin.ProxyType.ERC1967);\n        admin.setProxyType(address(chugsplash), ProxyAdmin.ProxyType.CHUGSPLASH);\n        admin.setProxyType(address(resolved), ProxyAdmin.ProxyType.RESOLVED);\n        vm.stopPrank();\n\n        implementation = new SimpleStorage();\n    }\n\n    function test_setImplementationName_succeeds() external {\n        vm.prank(alice);\n        admin.setImplementationName(address(1), \"foo\");\n        assertEq(admin.implementationName(address(1)), \"foo\");\n    }\n\n    function test_setAddressManager_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.setAddressManager(AddressManager((address(0))));\n    }\n\n    function test_setImplementationName_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.setImplementationName(address(0), \"foo\");\n    }\n\n    function test_setProxyType_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.setProxyType(address(0), ProxyAdmin.ProxyType.CHUGSPLASH);\n    }\n\n    function test_owner_succeeds() external {\n        assertEq(admin.owner(), alice);\n    }\n\n    function test_proxyType_succeeds() external {\n        assertEq(uint256(admin.proxyType(address(proxy))), uint256(ProxyAdmin.ProxyType.ERC1967));\n        assertEq(\n            uint256(admin.proxyType(address(chugsplash))),\n            uint256(ProxyAdmin.ProxyType.CHUGSPLASH)\n        );\n        assertEq(\n            uint256(admin.proxyType(address(resolved))),\n            uint256(ProxyAdmin.ProxyType.RESOLVED)\n        );\n    }\n\n    function test_erc1967GetProxyImplementation_succeeds() external {\n        getProxyImplementation(payable(proxy));\n    }\n\n    function test_chugsplashGetProxyImplementation_succeeds() external {\n        getProxyImplementation(payable(chugsplash));\n    }\n\n    function test_delegateResolvedGetProxyImplementation_succeeds() external {\n        getProxyImplementation(payable(resolved));\n    }\n\n    function getProxyImplementation(address payable _proxy) internal {\n        {\n            address impl = admin.getProxyImplementation(_proxy);\n            assertEq(impl, address(0));\n        }\n\n        vm.prank(alice);\n        admin.upgrade(_proxy, address(implementation));\n\n        {\n            address impl = admin.getProxyImplementation(_proxy);\n            assertEq(impl, address(implementation));\n        }\n    }\n\n    function test_erc1967GetProxyAdmin_succeeds() external {\n        getProxyAdmin(payable(proxy));\n    }\n\n    function test_chugsplashGetProxyAdmin_succeeds() external {\n        getProxyAdmin(payable(chugsplash));\n    }\n\n    function test_delegateResolvedGetProxyAdmin_succeeds() external {\n        getProxyAdmin(payable(resolved));\n    }\n\n    function getProxyAdmin(address payable _proxy) internal {\n        address owner = admin.getProxyAdmin(_proxy);\n        assertEq(owner, address(admin));\n    }\n\n    function test_erc1967ChangeProxyAdmin_succeeds() external {\n        changeProxyAdmin(payable(proxy));\n    }\n\n    function test_chugsplashChangeProxyAdmin_succeeds() external {\n        changeProxyAdmin(payable(chugsplash));\n    }\n\n    function test_delegateResolvedChangeProxyAdmin_succeeds() external {\n        changeProxyAdmin(payable(resolved));\n    }\n\n    function changeProxyAdmin(address payable _proxy) internal {\n        ProxyAdmin.ProxyType proxyType = admin.proxyType(address(_proxy));\n\n        vm.prank(alice);\n        admin.changeProxyAdmin(_proxy, address(128));\n\n        // The proxy is no longer the admin and can\n        // no longer call the proxy interface except for\n        // the ResolvedDelegate type on which anybody can\n        // call the admin interface.\n        if (proxyType == ProxyAdmin.ProxyType.ERC1967) {\n            vm.expectRevert(\"Proxy: implementation not initialized\");\n            admin.getProxyAdmin(_proxy);\n        } else if (proxyType == ProxyAdmin.ProxyType.CHUGSPLASH) {\n            vm.expectRevert(\"L1ChugSplashProxy: implementation is not set yet\");\n            admin.getProxyAdmin(_proxy);\n        } else if (proxyType == ProxyAdmin.ProxyType.RESOLVED) {\n            // Just an empty block to show that all cases are covered\n        } else {\n            vm.expectRevert(\"ProxyAdmin: unknown proxy type\");\n        }\n\n        // Call the proxy contract directly to get the admin.\n        // Different proxy types have different interfaces.\n        vm.prank(address(128));\n        if (proxyType == ProxyAdmin.ProxyType.ERC1967) {\n            assertEq(Proxy(payable(_proxy)).admin(), address(128));\n        } else if (proxyType == ProxyAdmin.ProxyType.CHUGSPLASH) {\n            assertEq(L1ChugSplashProxy(payable(_proxy)).getOwner(), address(128));\n        } else if (proxyType == ProxyAdmin.ProxyType.RESOLVED) {\n            assertEq(addressManager.owner(), address(128));\n        } else {\n            assert(false);\n        }\n    }\n\n    function test_erc1967Upgrade_succeeds() external {\n        upgrade(payable(proxy));\n    }\n\n    function test_chugsplashUpgrade_succeeds() external {\n        upgrade(payable(chugsplash));\n    }\n\n    function test_delegateResolvedUpgrade_succeeds() external {\n        upgrade(payable(resolved));\n    }\n\n    function upgrade(address payable _proxy) internal {\n        vm.prank(alice);\n        admin.upgrade(_proxy, address(implementation));\n\n        address impl = admin.getProxyImplementation(_proxy);\n        assertEq(impl, address(implementation));\n    }\n\n    function test_erc1967UpgradeAndCall_succeeds() external {\n        upgradeAndCall(payable(proxy));\n    }\n\n    function test_chugsplashUpgradeAndCall_succeeds() external {\n        upgradeAndCall(payable(chugsplash));\n    }\n\n    function test_delegateResolvedUpgradeAndCall_succeeds() external {\n        upgradeAndCall(payable(resolved));\n    }\n\n    function upgradeAndCall(address payable _proxy) internal {\n        vm.prank(alice);\n        admin.upgradeAndCall(\n            _proxy,\n            address(implementation),\n            abi.encodeWithSelector(SimpleStorage.set.selector, 1, 1)\n        );\n\n        address impl = admin.getProxyImplementation(_proxy);\n        assertEq(impl, address(implementation));\n\n        uint256 got = SimpleStorage(address(_proxy)).get(1);\n        assertEq(got, 1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.changeProxyAdmin(payable(proxy), address(0));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgrade(payable(proxy), address(implementation));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgradeAndCall(payable(proxy), address(implementation), hex\"\");\n    }\n\n    function test_isUpgrading_succeeds() external {\n        assertEq(false, admin.isUpgrading());\n\n        vm.prank(alice);\n        admin.setUpgrading(true);\n        assertEq(true, admin.isUpgrading());\n    }\n}\n"
    },
    "contracts/test/RLP.t.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\n/**\n * @title LibRLP\n * @notice Via https://github.com/Rari-Capital/solmate/issues/207.\n */\nlibrary LibRLP {\n    using Bytes32AddressLib for bytes32;\n\n    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80)))\n                    .fromLast20Bytes();\n        if (nonce <= 0x7f)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce)))\n                    .fromLast20Bytes();\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= type(uint8).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd7),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x81),\n                        uint8(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint16).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd8),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x82),\n                        uint16(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint24).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd9),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x83),\n                        uint24(nonce)\n                    )\n                ).fromLast20Bytes();\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return\n            keccak256(\n                abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/test/RLPReader.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { RLPReader } from \"../libraries/rlp/RLPReader.sol\";\n\ncontract RLPReader_readBytes_Test is CommonTest {\n    function test_readBytes_bytestring00_succeeds() external {\n        assertEq(RLPReader.readBytes(hex\"00\"), hex\"00\");\n    }\n\n    function test_readBytes_bytestring01_succeeds() external {\n        assertEq(RLPReader.readBytes(hex\"01\"), hex\"01\");\n    }\n\n    function test_readBytes_bytestring7f_succeeds() external {\n        assertEq(RLPReader.readBytes(hex\"7f\"), hex\"7f\");\n    }\n\n    function test_readBytes_revertListItem_reverts() external {\n        vm.expectRevert(\"RLPReader: decoded item type for bytes is not a data item\");\n        RLPReader.readBytes(hex\"c7c0c1c0c3c0c1c0\");\n    }\n\n    function test_readBytes_invalidStringLength_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be > than length of string length (long string)\"\n        );\n        RLPReader.readBytes(hex\"b9\");\n    }\n\n    function test_readBytes_invalidListLength_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be > than length of list length (long list)\"\n        );\n        RLPReader.readBytes(hex\"ff\");\n    }\n\n    function test_readBytes_invalidRemainder_reverts() external {\n        vm.expectRevert(\"RLPReader: bytes value contains an invalid remainder\");\n        RLPReader.readBytes(hex\"800a\");\n    }\n\n    function test_readBytes_invalidPrefix_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\"\n        );\n        RLPReader.readBytes(hex\"810a\");\n    }\n}\n\ncontract RLPReader_readList_Test is CommonTest {\n    function test_readList_empty_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c0\");\n        assertEq(list.length, 0);\n    }\n\n    function test_readList_multiList_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c6827a77c10401\");\n        assertEq(list.length, 3);\n\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"827a77\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"c104\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"01\");\n    }\n\n    function test_readList_shortListMax1_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(\n            hex\"f784617364668471776572847a78637684617364668471776572847a78637684617364668471776572847a78637684617364668471776572\"\n        );\n\n        assertEq(list.length, 11);\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"8471776572\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"847a786376\");\n        assertEq(RLPReader.readRawBytes(list[3]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[4]), hex\"8471776572\");\n        assertEq(RLPReader.readRawBytes(list[5]), hex\"847a786376\");\n        assertEq(RLPReader.readRawBytes(list[6]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[7]), hex\"8471776572\");\n        assertEq(RLPReader.readRawBytes(list[8]), hex\"847a786376\");\n        assertEq(RLPReader.readRawBytes(list[9]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[10]), hex\"8471776572\");\n    }\n\n    function test_readList_longList1_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(\n            hex\"f840cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\"\n        );\n\n        assertEq(list.length, 4);\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"cf84617364668471776572847a786376\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"cf84617364668471776572847a786376\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"cf84617364668471776572847a786376\");\n        assertEq(RLPReader.readRawBytes(list[3]), hex\"cf84617364668471776572847a786376\");\n    }\n\n    function test_readList_longList2_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(\n            hex\"f90200cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\"\n        );\n        assertEq(list.length, 32);\n\n        for (uint256 i = 0; i < 32; i++) {\n            assertEq(RLPReader.readRawBytes(list[i]), hex\"cf84617364668471776572847a786376\");\n        }\n    }\n\n    function test_readList_listLongerThan32Elements_reverts() external {\n        vm.expectRevert(stdError.indexOOBError);\n        RLPReader.readList(\n            hex\"e1454545454545454545454545454545454545454545454545454545454545454545\"\n        );\n    }\n\n    function test_readList_listOfLists_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c4c2c0c0c0\");\n        assertEq(list.length, 2);\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"c2c0c0\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"c0\");\n    }\n\n    function test_readList_listOfLists2_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c7c0c1c0c3c0c1c0\");\n        assertEq(list.length, 3);\n\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"c0\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"c1c0\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"c3c0c1c0\");\n    }\n\n    function test_readList_dictTest1_succeeds() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(\n            hex\"ecca846b6579318476616c31ca846b6579328476616c32ca846b6579338476616c33ca846b6579348476616c34\"\n        );\n        assertEq(list.length, 4);\n\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"ca846b6579318476616c31\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"ca846b6579328476616c32\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"ca846b6579338476616c33\");\n        assertEq(RLPReader.readRawBytes(list[3]), hex\"ca846b6579348476616c34\");\n    }\n\n    function test_readList_invalidShortList_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than list length (short list)\"\n        );\n        RLPReader.readList(hex\"efdebd\");\n    }\n\n    function test_readList_longStringLength_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than list length (short list)\"\n        );\n        RLPReader.readList(hex\"efb83600\");\n    }\n\n    function test_readList_notLongEnough_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than list length (short list)\"\n        );\n        RLPReader.readList(\n            hex\"efdebdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n        );\n    }\n\n    function test_readList_int32Overflow_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than total length (long string)\"\n        );\n        RLPReader.readList(hex\"bf0f000000000000021111\");\n    }\n\n    function test_readList_int32Overflow2_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than total length (long list)\"\n        );\n        RLPReader.readList(hex\"ff0f000000000000021111\");\n    }\n\n    function test_readList_incorrectLengthInArray_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must not have any leading zeros (long string)\"\n        );\n        RLPReader.readList(\n            hex\"b9002100dc2b275d0f74e8a53e6f4ec61b27f24278820be3f82ea2110e582081b0565df0\"\n        );\n    }\n\n    function test_readList_leadingZerosInLongLengthArray1_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must not have any leading zeros (long string)\"\n        );\n        RLPReader.readList(\n            hex\"b90040000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n        );\n    }\n\n    function test_readList_leadingZerosInLongLengthArray2_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must not have any leading zeros (long string)\"\n        );\n        RLPReader.readList(hex\"b800\");\n    }\n\n    function test_readList_leadingZerosInLongLengthList1_reverts() external {\n        vm.expectRevert(\"RLPReader: length of content must not have any leading zeros (long list)\");\n        RLPReader.readList(\n            hex\"fb00000040000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n        );\n    }\n\n    function test_readList_nonOptimalLongLengthArray1_reverts() external {\n        vm.expectRevert(\"RLPReader: length of content must be greater than 55 bytes (long string)\");\n        RLPReader.readList(hex\"b81000112233445566778899aabbccddeeff\");\n    }\n\n    function test_readList_nonOptimalLongLengthArray2_reverts() external {\n        vm.expectRevert(\"RLPReader: length of content must be greater than 55 bytes (long string)\");\n        RLPReader.readList(hex\"b801ff\");\n    }\n\n    function test_readList_invalidValue_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than string length (short string)\"\n        );\n        RLPReader.readList(hex\"91\");\n    }\n\n    function test_readList_invalidRemainder_reverts() external {\n        vm.expectRevert(\"RLPReader: list item has an invalid data remainder\");\n        RLPReader.readList(hex\"c000\");\n    }\n\n    function test_readList_notEnoughContentForString1_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than total length (long string)\"\n        );\n        RLPReader.readList(hex\"ba010000aabbccddeeff\");\n    }\n\n    function test_readList_notEnoughContentForString2_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than total length (long string)\"\n        );\n        RLPReader.readList(hex\"b840ffeeddccbbaa99887766554433221100\");\n    }\n\n    function test_readList_notEnoughContentForList1_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than total length (long list)\"\n        );\n        RLPReader.readList(hex\"f90180\");\n    }\n\n    function test_readList_notEnoughContentForList2_reverts() external {\n        vm.expectRevert(\n            \"RLPReader: length of content must be greater than total length (long list)\"\n        );\n        RLPReader.readList(hex\"ffffffffffffffffff0001020304050607\");\n    }\n\n    function test_readList_longStringLessThan56Bytes_reverts() external {\n        vm.expectRevert(\"RLPReader: length of content must be greater than 55 bytes (long string)\");\n        RLPReader.readList(hex\"b80100\");\n    }\n\n    function test_readList_longListLessThan56Bytes_reverts() external {\n        vm.expectRevert(\"RLPReader: length of content must be greater than 55 bytes (long list)\");\n        RLPReader.readList(hex\"f80100\");\n    }\n}\n"
    },
    "contracts/test/RLPWriter.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { RLPWriter } from \"../libraries/rlp/RLPWriter.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract RLPWriter_writeString_Test is CommonTest {\n    function test_writeString_empty_succeeds() external {\n        assertEq(RLPWriter.writeString(\"\"), hex\"80\");\n    }\n\n    function test_writeString_bytestring00_succeeds() external {\n        assertEq(RLPWriter.writeString(\"\\u0000\"), hex\"00\");\n    }\n\n    function test_writeString_bytestring01_succeeds() external {\n        assertEq(RLPWriter.writeString(\"\\u0001\"), hex\"01\");\n    }\n\n    function test_writeString_bytestring7f_succeeds() external {\n        assertEq(RLPWriter.writeString(\"\\u007F\"), hex\"7f\");\n    }\n\n    function test_writeString_shortstring_succeeds() external {\n        assertEq(RLPWriter.writeString(\"dog\"), hex\"83646f67\");\n    }\n\n    function test_writeString_shortstring2_succeeds() external {\n        assertEq(\n            RLPWriter.writeString(\"Lorem ipsum dolor sit amet, consectetur adipisicing eli\"),\n            hex\"b74c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c69\"\n        );\n    }\n\n    function test_writeString_longstring_succeeds() external {\n        assertEq(\n            RLPWriter.writeString(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"),\n            hex\"b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974\"\n        );\n    }\n\n    function test_writeString_longstring2_succeeds() external {\n        assertEq(\n            RLPWriter.writeString(\n                \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur mauris magna, suscipit sed vehicula non, iaculis faucibus tortor. Proin suscipit ultricies malesuada. Duis tortor elit, dictum quis tristique eu, ultrices at risus. Morbi a est imperdiet mi ullamcorper aliquet suscipit nec lorem. Aenean quis leo mollis, vulputate elit varius, consequat enim. Nulla ultrices turpis justo, et posuere urna consectetur nec. Proin non convallis metus. Donec tempor ipsum in mauris congue sollicitudin. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Suspendisse convallis sem vel massa faucibus, eget lacinia lacus tempor. Nulla quis ultricies purus. Proin auctor rhoncus nibh condimentum mollis. Aliquam consequat enim at metus luctus, a eleifend purus egestas. Curabitur at nibh metus. Nam bibendum, neque at auctor tristique, lorem libero aliquet arcu, non interdum tellus lectus sit amet eros. Cras rhoncus, metus ac ornare cursus, dolor justo ultrices metus, at ullamcorper volutpat\"\n            ),\n            hex\"b904004c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e73656374657475722061646970697363696e6720656c69742e20437572616269747572206d6175726973206d61676e612c20737573636970697420736564207665686963756c61206e6f6e2c20696163756c697320666175636962757320746f72746f722e2050726f696e20737573636970697420756c74726963696573206d616c6573756164612e204475697320746f72746f7220656c69742c2064696374756d2071756973207472697374697175652065752c20756c7472696365732061742072697375732e204d6f72626920612065737420696d70657264696574206d6920756c6c616d636f7270657220616c6971756574207375736369706974206e6563206c6f72656d2e2041656e65616e2071756973206c656f206d6f6c6c69732c2076756c70757461746520656c6974207661726975732c20636f6e73657175617420656e696d2e204e756c6c6120756c74726963657320747572706973206a7573746f2c20657420706f73756572652075726e6120636f6e7365637465747572206e65632e2050726f696e206e6f6e20636f6e76616c6c6973206d657475732e20446f6e65632074656d706f7220697073756d20696e206d617572697320636f6e67756520736f6c6c696369747564696e2e20566573746962756c756d20616e746520697073756d207072696d697320696e206661756369627573206f726369206c756374757320657420756c74726963657320706f737565726520637562696c69612043757261653b2053757370656e646973736520636f6e76616c6c69732073656d2076656c206d617373612066617563696275732c2065676574206c6163696e6961206c616375732074656d706f722e204e756c6c61207175697320756c747269636965732070757275732e2050726f696e20617563746f722072686f6e637573206e69626820636f6e64696d656e74756d206d6f6c6c69732e20416c697175616d20636f6e73657175617420656e696d206174206d65747573206c75637475732c206120656c656966656e6420707572757320656765737461732e20437572616269747572206174206e696268206d657475732e204e616d20626962656e64756d2c206e6571756520617420617563746f72207472697374697175652c206c6f72656d206c696265726f20616c697175657420617263752c206e6f6e20696e74657264756d2074656c6c7573206c65637475732073697420616d65742065726f732e20437261732072686f6e6375732c206d65747573206163206f726e617265206375727375732c20646f6c6f72206a7573746f20756c747269636573206d657475732c20617420756c6c616d636f7270657220766f6c7574706174\"\n        );\n    }\n}\n\ncontract RLPWriter_writeUint_Test is CommonTest {\n    function test_writeUint_zero_succeeds() external {\n        assertEq(RLPWriter.writeUint(0x0), hex\"80\");\n    }\n\n    function test_writeUint_smallint_succeeds() external {\n        assertEq(RLPWriter.writeUint(1), hex\"01\");\n    }\n\n    function test_writeUint_smallint2_succeeds() external {\n        assertEq(RLPWriter.writeUint(16), hex\"10\");\n    }\n\n    function test_writeUint_smallint3_succeeds() external {\n        assertEq(RLPWriter.writeUint(79), hex\"4f\");\n    }\n\n    function test_writeUint_smallint4_succeeds() external {\n        assertEq(RLPWriter.writeUint(127), hex\"7f\");\n    }\n\n    function test_writeUint_mediumint_succeeds() external {\n        assertEq(RLPWriter.writeUint(128), hex\"8180\");\n    }\n\n    function test_writeUint_mediumint2_succeeds() external {\n        assertEq(RLPWriter.writeUint(1000), hex\"8203e8\");\n    }\n\n    function test_writeUint_mediumint3_succeeds() external {\n        assertEq(RLPWriter.writeUint(100000), hex\"830186a0\");\n    }\n}\n\ncontract RLPWriter_writeList_Test is CommonTest {\n    function test_writeList_empty_succeeds() external {\n        assertEq(RLPWriter.writeList(new bytes[](0)), hex\"c0\");\n    }\n\n    function test_writeList_stringList_succeeds() external {\n        bytes[] memory list = new bytes[](3);\n        list[0] = RLPWriter.writeString(\"dog\");\n        list[1] = RLPWriter.writeString(\"god\");\n        list[2] = RLPWriter.writeString(\"cat\");\n\n        assertEq(RLPWriter.writeList(list), hex\"cc83646f6783676f6483636174\");\n    }\n\n    function test_writeList_multiList_succeeds() external {\n        bytes[] memory list = new bytes[](3);\n        bytes[] memory list2 = new bytes[](1);\n        list2[0] = RLPWriter.writeUint(4);\n\n        list[0] = RLPWriter.writeString(\"zw\");\n        list[1] = RLPWriter.writeList(list2);\n        list[2] = RLPWriter.writeUint(1);\n\n        assertEq(RLPWriter.writeList(list), hex\"c6827a77c10401\");\n    }\n\n    function test_writeList_shortListMax1_succeeds() external {\n        bytes[] memory list = new bytes[](11);\n        list[0] = RLPWriter.writeString(\"asdf\");\n        list[1] = RLPWriter.writeString(\"qwer\");\n        list[2] = RLPWriter.writeString(\"zxcv\");\n        list[3] = RLPWriter.writeString(\"asdf\");\n        list[4] = RLPWriter.writeString(\"qwer\");\n        list[5] = RLPWriter.writeString(\"zxcv\");\n        list[6] = RLPWriter.writeString(\"asdf\");\n        list[7] = RLPWriter.writeString(\"qwer\");\n        list[8] = RLPWriter.writeString(\"zxcv\");\n        list[9] = RLPWriter.writeString(\"asdf\");\n        list[10] = RLPWriter.writeString(\"qwer\");\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"f784617364668471776572847a78637684617364668471776572847a78637684617364668471776572847a78637684617364668471776572\"\n        );\n    }\n\n    function test_writeList_longlist1_succeeds() external {\n        bytes[] memory list = new bytes[](4);\n        bytes[] memory list2 = new bytes[](3);\n\n        list2[0] = RLPWriter.writeString(\"asdf\");\n        list2[1] = RLPWriter.writeString(\"qwer\");\n        list2[2] = RLPWriter.writeString(\"zxcv\");\n\n        list[0] = RLPWriter.writeList(list2);\n        list[1] = RLPWriter.writeList(list2);\n        list[2] = RLPWriter.writeList(list2);\n        list[3] = RLPWriter.writeList(list2);\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"f840cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\"\n        );\n    }\n\n    function test_writeList_longlist2_succeeds() external {\n        bytes[] memory list = new bytes[](32);\n        bytes[] memory list2 = new bytes[](3);\n\n        list2[0] = RLPWriter.writeString(\"asdf\");\n        list2[1] = RLPWriter.writeString(\"qwer\");\n        list2[2] = RLPWriter.writeString(\"zxcv\");\n\n        for (uint256 i = 0; i < 32; i++) {\n            list[i] = RLPWriter.writeList(list2);\n        }\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"f90200cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\"\n        );\n    }\n\n    function test_writeList_listoflists_succeeds() external {\n        // [ [ [], [] ], [] ]\n        bytes[] memory list = new bytes[](2);\n        bytes[] memory list2 = new bytes[](2);\n\n        list2[0] = RLPWriter.writeList(new bytes[](0));\n        list2[1] = RLPWriter.writeList(new bytes[](0));\n\n        list[0] = RLPWriter.writeList(list2);\n        list[1] = RLPWriter.writeList(new bytes[](0));\n\n        assertEq(RLPWriter.writeList(list), hex\"c4c2c0c0c0\");\n    }\n\n    function test_writeList_listoflists2_succeeds() external {\n        // [ [], [[]], [ [], [[]] ] ]\n        bytes[] memory list = new bytes[](3);\n        list[0] = RLPWriter.writeList(new bytes[](0));\n\n        bytes[] memory list2 = new bytes[](1);\n        list2[0] = RLPWriter.writeList(new bytes[](0));\n\n        list[1] = RLPWriter.writeList(list2);\n\n        bytes[] memory list3 = new bytes[](2);\n        list3[0] = RLPWriter.writeList(new bytes[](0));\n        list3[1] = RLPWriter.writeList(list2);\n\n        list[2] = RLPWriter.writeList(list3);\n\n        assertEq(RLPWriter.writeList(list), hex\"c7c0c1c0c3c0c1c0\");\n    }\n\n    function test_writeList_dictTest1_succeeds() external {\n        bytes[] memory list = new bytes[](4);\n\n        bytes[] memory list1 = new bytes[](2);\n        list1[0] = RLPWriter.writeString(\"key1\");\n        list1[1] = RLPWriter.writeString(\"val1\");\n\n        bytes[] memory list2 = new bytes[](2);\n        list2[0] = RLPWriter.writeString(\"key2\");\n        list2[1] = RLPWriter.writeString(\"val2\");\n\n        bytes[] memory list3 = new bytes[](2);\n        list3[0] = RLPWriter.writeString(\"key3\");\n        list3[1] = RLPWriter.writeString(\"val3\");\n\n        bytes[] memory list4 = new bytes[](2);\n        list4[0] = RLPWriter.writeString(\"key4\");\n        list4[1] = RLPWriter.writeString(\"val4\");\n\n        list[0] = RLPWriter.writeList(list1);\n        list[1] = RLPWriter.writeList(list2);\n        list[2] = RLPWriter.writeList(list3);\n        list[3] = RLPWriter.writeList(list4);\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"ecca846b6579318476616c31ca846b6579328476616c32ca846b6579338476616c33ca846b6579348476616c34\"\n        );\n    }\n}\n"
    },
    "contracts/test/ResolvedDelegateProxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { ResolvedDelegateProxy } from \"../legacy/ResolvedDelegateProxy.sol\";\n\ncontract ResolvedDelegateProxy_Test is Test {\n    AddressManager internal addressManager;\n    SimpleImplementation internal impl;\n    SimpleImplementation internal proxy;\n\n    function setUp() public {\n        // Set up the address manager.\n        addressManager = new AddressManager();\n        impl = new SimpleImplementation();\n        addressManager.setAddress(\"SimpleImplementation\", address(impl));\n\n        // Set up the proxy.\n        proxy = SimpleImplementation(\n            address(new ResolvedDelegateProxy(addressManager, \"SimpleImplementation\"))\n        );\n    }\n\n    // Tests that the proxy properly bubbles up returndata when the delegatecall succeeds.\n    function testFuzz_fallback_delegateCallFoo_succeeds(uint256 x) public {\n        vm.expectCall(address(impl), abi.encodeWithSelector(impl.foo.selector, x));\n        assertEq(proxy.foo(x), x);\n    }\n\n    // Tests that the proxy properly bubbles up returndata when the delegatecall reverts.\n    function test_fallback_delegateCallBar_reverts() public {\n        vm.expectRevert(\"SimpleImplementation: revert\");\n        vm.expectCall(address(impl), abi.encodeWithSelector(impl.bar.selector));\n        proxy.bar();\n    }\n\n    // Tests that the proxy fallback reverts as expected if the implementation within the\n    // address manager is not set.\n    function test_fallback_addressManagerNotSet_reverts() public {\n        AddressManager am = new AddressManager();\n        SimpleImplementation p = SimpleImplementation(\n            address(new ResolvedDelegateProxy(am, \"SimpleImplementation\"))\n        );\n\n        vm.expectRevert(\"ResolvedDelegateProxy: target address must be initialized\");\n        p.foo(0);\n    }\n}\n\ncontract SimpleImplementation {\n    function foo(uint256 _x) public pure returns (uint256) {\n        return _x;\n    }\n\n    function bar() public pure {\n        revert(\"SimpleImplementation: revert\");\n    }\n}\n"
    },
    "contracts/test/ResourceMetering.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract MeterUser is ResourceMetering {\n    ResourceMetering.ResourceConfig public innerConfig;\n\n    constructor() {\n        initialize();\n        innerConfig = Constants.DEFAULT_RESOURCE_CONFIG();\n    }\n\n    function initialize() public initializer {\n        __ResourceMetering_init();\n    }\n\n    function resourceConfig() public view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig();\n    }\n\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return innerConfig;\n    }\n\n    function use(uint64 _amount) public metered(_amount) {}\n\n    function set(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) public {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function setParams(ResourceMetering.ResourceConfig memory newConfig) public {\n        innerConfig = newConfig;\n    }\n}\n\n/**\n * @title ResourceConfig\n * @notice The tests are based on the default config values. It is expected that\n *         the config values used in these tests are ran in production.\n */\ncontract ResourceMetering_Test is Test {\n    MeterUser internal meter;\n    uint64 initialBlockNum;\n\n    function setUp() public {\n        meter = new MeterUser();\n        initialBlockNum = uint64(block.number);\n    }\n\n    function test_meter_initialResourceParams_succeeds() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n\n        assertEq(prevBaseFee, rcfg.minimumBaseFee);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_updateParamsNoChange_succeeds() external {\n        meter.use(0); // equivalent to just updating the base fee and block number\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n\n        assertEq(postBaseFee, prevBaseFee);\n        assertEq(postBoughtGas, prevBoughtGas);\n        assertEq(postBlockNum, prevBlockNum);\n    }\n\n    function test_meter_updateOneEmptyBlock_succeeds() external {\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 1);\n    }\n\n    function test_meter_updateTwoEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 2);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 2);\n    }\n\n    function test_meter_updateTenEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 10);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 10);\n    }\n\n    function test_meter_updateNoGasDelta_succeeds() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint256 target = uint256(rcfg.maxResourceLimit) / uint256(rcfg.elasticityMultiplier);\n        meter.use(uint64(target));\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1000000000);\n        assertEq(prevBoughtGas, target);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_useMax_succeeds() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        meter.use(target * elasticityMultiplier);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticityMultiplier);\n\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 postBaseFee, , ) = meter.params();\n        assertEq(postBaseFee, 2125000000);\n    }\n\n    /**\n     * @notice This tests that the metered modifier reverts if\n     *         the ResourceConfig baseFeeMaxChangeDenominator\n     *         is set to 1.\n     *         Since the metered modifier internally calls\n     *         solmate's powWad function, it will revert\n     *         with the error string \"UNDEFINED\" since the\n     *         first parameter will be computed as 0.\n     */\n    function test_meter_denominatorEq1_reverts() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n        rcfg.baseFeeMaxChangeDenominator = 1;\n        meter.setParams(rcfg);\n        meter.use(target * elasticityMultiplier);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticityMultiplier);\n\n        vm.roll(initialBlockNum + 2);\n\n        vm.expectRevert(\"UNDEFINED\");\n        meter.use(0);\n    }\n\n    function test_meter_useMoreThanMax_reverts() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        vm.expectRevert(\"ResourceMetering: cannot buy more gas than available gas limit\");\n        meter.use(target * elasticityMultiplier + 1);\n    }\n\n    // Demonstrates that the resource metering arithmetic can tolerate very large gaps between\n    // deposits.\n    function testFuzz_meter_largeBlockDiff_succeeds(uint64 _amount, uint256 _blockDiff) external {\n        // This test fails if the following line is commented out.\n        // At 12 seconds per block, this number is effectively unreachable.\n        vm.assume(_blockDiff < 433576281058164217753225238677900874458691);\n\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        vm.assume(_amount < target * elasticityMultiplier);\n        vm.roll(initialBlockNum + _blockDiff);\n        meter.use(_amount);\n    }\n}\n\n/**\n * @title CustomMeterUser\n * @notice A simple wrapper around `ResourceMetering` that allows the initial\n *         params to be set in the constructor.\n */\ncontract CustomMeterUser is ResourceMetering {\n    uint256 public startGas;\n    uint256 public endGas;\n\n    constructor(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function _resourceConfig()\n        internal\n        pure\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return Constants.DEFAULT_RESOURCE_CONFIG();\n    }\n\n    function use(uint64 _amount) public returns (uint256) {\n        uint256 initialGas = gasleft();\n        _metered(_amount, initialGas);\n        return initialGas - gasleft();\n    }\n}\n\n/**\n * @title ArtifactResourceMetering_Test\n * @notice A table test that sets the state of the ResourceParams and then requests\n *         various amounts of gas. This test ensures that a wide range of values\n *         can safely be used with the `ResourceMetering` contract.\n *         It also writes a CSV file to disk that includes useful information\n *         about how much gas is used and how expensive it is in USD terms to\n *         purchase the deposit gas.\n */\ncontract ArtifactResourceMetering_Test is Test {\n    uint128 internal minimumBaseFee;\n    uint128 internal maximumBaseFee;\n    uint64 internal maxResourceLimit;\n    uint64 internal targetResourceLimit;\n\n    string internal outfile;\n\n    // keccak256(abi.encodeWithSignature(\"Error(string)\", \"ResourceMetering: cannot buy more gas than available gas limit\"))\n    bytes32 internal cannotBuyMoreGas =\n        0x84edc668cfd5e050b8999f43ff87a1faaa93e5f935b20bc1dd4d3ff157ccf429;\n    // keccak256(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n    bytes32 internal overflowErr =\n        0x1ca389f2c8264faa4377de9ce8e14d6263ef29c68044a9272d405761bab2db27;\n    // keccak256(hex\"\")\n    bytes32 internal emptyReturnData =\n        0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    /**\n     * @notice Sets up the tests by getting constants from the ResourceMetering\n     *         contract.\n     */\n    function setUp() public {\n        vm.roll(1_000_000);\n\n        MeterUser base = new MeterUser();\n        ResourceMetering.ResourceConfig memory rcfg = base.resourceConfig();\n        minimumBaseFee = uint128(rcfg.minimumBaseFee);\n        maximumBaseFee = rcfg.maximumBaseFee;\n        maxResourceLimit = uint64(rcfg.maxResourceLimit);\n        targetResourceLimit = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n\n        outfile = string.concat(vm.projectRoot(), \"/.resource-metering.csv\");\n        try vm.removeFile(outfile) {} catch {}\n    }\n\n    /**\n     * @notice Generate a CSV file. The call to `meter` should be called with at\n     *         most the L1 block gas limit. Without specifying the amount of\n     *         gas, it can take very long to execute.\n     */\n    function test_meter_generateArtifact_succeeds() external {\n        vm.writeLine(\n            outfile,\n            \"prevBaseFee,prevBoughtGas,prevBlockNumDiff,l1BaseFee,requestedGas,gasConsumed,ethPrice,usdCost,success\"\n        );\n\n        // prevBaseFee value in ResourceParams\n        uint128[] memory prevBaseFees = new uint128[](5);\n        prevBaseFees[0] = minimumBaseFee;\n        prevBaseFees[1] = maximumBaseFee;\n        prevBaseFees[2] = uint128(50 gwei);\n        prevBaseFees[3] = uint128(100 gwei);\n        prevBaseFees[4] = uint128(200 gwei);\n\n        // prevBoughtGas value in ResourceParams\n        uint64[] memory prevBoughtGases = new uint64[](1);\n        prevBoughtGases[0] = uint64(0);\n\n        // prevBlockNum diff, simulates blocks with no deposits when non zero\n        uint64[] memory prevBlockNumDiffs = new uint64[](2);\n        prevBlockNumDiffs[0] = 0;\n        prevBlockNumDiffs[1] = 1;\n\n        // The amount of L2 gas that a user requests\n        uint64[] memory requestedGases = new uint64[](3);\n        requestedGases[0] = maxResourceLimit;\n        requestedGases[1] = targetResourceLimit;\n        requestedGases[2] = uint64(100_000);\n\n        // The L1 base fee\n        uint256[] memory l1BaseFees = new uint256[](4);\n        l1BaseFees[0] = 1 gwei;\n        l1BaseFees[1] = 50 gwei;\n        l1BaseFees[2] = 75 gwei;\n        l1BaseFees[3] = 100 gwei;\n\n        // USD price of 1 ether\n        uint256[] memory ethPrices = new uint256[](2);\n        ethPrices[0] = 1600;\n        ethPrices[1] = 3200;\n\n        // Iterate over all of the test values and run a test\n        for (uint256 i; i < prevBaseFees.length; i++) {\n            for (uint256 j; j < prevBoughtGases.length; j++) {\n                for (uint256 k; k < prevBlockNumDiffs.length; k++) {\n                    for (uint256 l; l < requestedGases.length; l++) {\n                        for (uint256 m; m < l1BaseFees.length; m++) {\n                            for (uint256 n; n < ethPrices.length; n++) {\n                                uint256 snapshotId = vm.snapshot();\n\n                                uint128 prevBaseFee = prevBaseFees[i];\n                                uint64 prevBoughtGas = prevBoughtGases[j];\n                                uint64 prevBlockNumDiff = prevBlockNumDiffs[k];\n                                uint64 requestedGas = requestedGases[l];\n                                uint256 l1BaseFee = l1BaseFees[m];\n                                uint256 ethPrice = ethPrices[n];\n                                string memory result = \"success\";\n\n                                vm.fee(l1BaseFee);\n\n                                CustomMeterUser meter = new CustomMeterUser({\n                                    _prevBaseFee: prevBaseFee,\n                                    _prevBoughtGas: prevBoughtGas,\n                                    _prevBlockNum: uint64(block.number)\n                                });\n\n                                vm.roll(block.number + prevBlockNumDiff);\n\n                                // Call the metering code and catch the various\n                                // types of errors.\n                                uint256 gasConsumed = 0;\n                                try meter.use{ gas: 30_000_000 }(requestedGas) returns (\n                                    uint256 _gasConsumed\n                                ) {\n                                    gasConsumed = _gasConsumed;\n                                } catch (bytes memory err) {\n                                    bytes32 hash = keccak256(err);\n                                    if (hash == cannotBuyMoreGas) {\n                                        result = \"ResourceMetering: cannot buy more gas than available gas limit\";\n                                    } else if (hash == overflowErr) {\n                                        result = \"arithmetic overflow/underflow\";\n                                    } else if (hash == emptyReturnData) {\n                                        result = \"out of gas\";\n                                    } else {\n                                        result = \"UNKNOWN ERROR\";\n                                    }\n                                }\n\n                                // Compute the USD cost of the gas used\n                                uint256 usdCost = (gasConsumed * l1BaseFee * ethPrice) / 1 ether;\n\n                                vm.writeLine(\n                                    outfile,\n                                    string.concat(\n                                        vm.toString(prevBaseFee),\n                                        \",\",\n                                        vm.toString(prevBoughtGas),\n                                        \",\",\n                                        vm.toString(prevBlockNumDiff),\n                                        \",\",\n                                        vm.toString(l1BaseFee),\n                                        \",\",\n                                        vm.toString(requestedGas),\n                                        \",\",\n                                        vm.toString(gasConsumed),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(ethPrice),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(usdCost),\n                                        \",\",\n                                        result\n                                    )\n                                );\n\n                                assertTrue(vm.revertTo(snapshotId));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\ncontract SafeCall_Test is CommonTest {\n    function testFuzz_send_succeeds(\n        address from,\n        address to,\n        uint256 gas,\n        uint64 value\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the ffi interface\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCall(to, value, bytes(\"\"));\n        vm.prank(from);\n        bool success = SafeCall.send(to, gas, value);\n\n        assertTrue(success, \"send not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function testFuzz_call_succeeds(\n        address from,\n        address to,\n        uint256 gas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the ffi interface\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCall(to, value, data);\n        vm.prank(from);\n        bool success = SafeCall.call(to, gas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function testFuzz_callWithMinGas_hasEnough_succeeds(\n        address from,\n        address to,\n        uint64 minGas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the FFIInterface\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        // Bound minGas to [0, l1_block_gas_limit]\n        minGas = uint64(bound(minGas, 0, 30_000_000));\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCallMinGas(to, value, minGas, data);\n        vm.prank(from);\n        bool success = SafeCall.callWithMinGas(to, minGas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function test_callWithMinGas_noLeakageLow_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 40_000; i < 100_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 65_907 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 65_907) {\n                assertFalse(caller.makeSafeCall(i, 25_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    25_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 25_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n\n    function test_callWithMinGas_noLeakageHigh_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 15_200_000; i < 15_300_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 15_278_606 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 15_278_606) {\n                assertFalse(caller.makeSafeCall(i, 15_000_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    15_000_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 15_000_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n}\n\ncontract SimpleSafeCaller {\n    uint256 public a;\n\n    function makeSafeCall(uint64 gas, uint64 minGas) external returns (bool) {\n        return\n            SafeCall.call(\n                address(this),\n                gas,\n                0,\n                abi.encodeWithSelector(this.makeSafeCallMinGas.selector, minGas)\n            );\n    }\n\n    function makeSafeCallMinGas(uint64 minGas) external returns (bool) {\n        return\n            SafeCall.callWithMinGas(\n                address(this),\n                minGas,\n                0,\n                abi.encodeWithSelector(this.setA.selector, 1)\n            );\n    }\n\n    function setA(uint256 _a) external {\n        a = _a;\n    }\n}\n"
    },
    "contracts/test/Semver.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\n/**\n * @notice Test the Semver contract that is used for semantic versioning\n *         of various contracts.\n */\ncontract Semver_Test is CommonTest {\n    /**\n     * @notice Global semver contract deployed in setUp. This is used in\n     *         the test cases.\n     */\n    Semver semver;\n\n    /**\n     * @notice Deploy a Semver contract\n     */\n    function setUp() public virtual override {\n        semver = new Semver(7, 8, 0);\n    }\n\n    /**\n     * @notice Test the version getter\n     */\n    function test_version_succeeds() external {\n        assertEq(semver.version(), \"7.8.0\");\n    }\n\n    /**\n     * @notice Since the versions are all immutable, they should\n     *         be able to be accessed from behind a proxy without needing\n     *         to initialize the contract.\n     */\n    function test_behindProxy_succeeds() external {\n        Proxy proxy = new Proxy(alice);\n        vm.prank(alice);\n        proxy.upgradeTo(address(semver));\n\n        assertEq(Semver(address(proxy)).version(), \"7.8.0\");\n    }\n}\n"
    },
    "contracts/test/SequencerFeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\nimport { SequencerFeeVault } from \"../L2/SequencerFeeVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract SequencerFeeVault_Test is Bridge_Initializer {\n    SequencerFeeVault vault = SequencerFeeVault(payable(Predeploys.SEQUENCER_FEE_WALLET));\n    address constant recipient = address(256);\n\n    event Withdrawal(uint256 value, address to, address from);\n\n    function setUp() public override {\n        super.setUp();\n        vm.etch(Predeploys.SEQUENCER_FEE_WALLET, address(new SequencerFeeVault(recipient)).code);\n        vm.label(Predeploys.SEQUENCER_FEE_WALLET, \"SequencerFeeVault\");\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(vault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(vault.l1FeeWallet(), recipient);\n    }\n\n    function test_receive_succeeds() external {\n        uint256 balance = address(vault).balance;\n\n        vm.prank(alice);\n        (bool success, ) = address(vault).call{ value: 100 }(hex\"\");\n\n        assertEq(success, true);\n        assertEq(address(vault).balance, balance + 100);\n    }\n\n    function test_withdraw_notEnough_reverts() external {\n        assert(address(vault).balance < vault.MIN_WITHDRAWAL_AMOUNT());\n\n        vm.expectRevert(\n            \"FeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n        vault.withdraw();\n    }\n\n    function test_withdraw_succeeds() external {\n        uint256 amount = vault.MIN_WITHDRAWAL_AMOUNT() + 1;\n        vm.deal(address(vault), amount);\n\n        // No ether has been withdrawn yet\n        assertEq(vault.totalProcessed(), 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.SEQUENCER_FEE_WALLET));\n        emit Withdrawal(address(vault).balance, vault.RECIPIENT(), address(this));\n\n        // The entire vault's balance is withdrawn\n        vm.expectCall(\n            Predeploys.L2_STANDARD_BRIDGE,\n            address(vault).balance,\n            abi.encodeWithSelector(\n                StandardBridge.bridgeETHTo.selector,\n                vault.l1FeeWallet(),\n                35_000,\n                bytes(\"\")\n            )\n        );\n\n        vault.withdraw();\n\n        // The withdrawal was successful\n        assertEq(vault.totalProcessed(), amount);\n    }\n}\n"
    },
    "contracts/test/StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport {\n    OptimismMintableERC20,\n    ILegacyMintableERC20\n} from \"../universal/OptimismMintableERC20.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title StandardBridgeTester\n * @notice Simple wrapper around the StandardBridge contract that exposes\n *         internal functions so they can be more easily tested directly.\n */\ncontract StandardBridgeTester is StandardBridge {\n    constructor(address payable _messenger, address payable _otherBridge)\n        StandardBridge(_messenger, _otherBridge)\n    {}\n\n    function isOptimismMintableERC20(address _token) external view returns (bool) {\n        return _isOptimismMintableERC20(_token);\n    }\n\n    function isCorrectTokenPair(address _mintableToken, address _otherToken)\n        external\n        view\n        returns (bool)\n    {\n        return _isCorrectTokenPair(_mintableToken, _otherToken);\n    }\n\n    receive() external payable override {}\n}\n\n/**\n * @title LegacyMintable\n * @notice Simple implementation of the legacy OptimismMintableERC20.\n */\ncontract LegacyMintable is ERC20, ILegacyMintableERC20 {\n    constructor(string memory _name, string memory _ticker) ERC20(_name, _ticker) {}\n\n    function l1Token() external pure returns (address) {\n        return address(0);\n    }\n\n    function mint(address _to, uint256 _amount) external pure {}\n\n    function burn(address _from, uint256 _amount) external pure {}\n\n    /**\n     * @notice Implements ERC165. This implementation should not be changed as\n     *         it is how the actual legacy optimism mintable token does the\n     *         check. Allows for testing against code that is has been deployed,\n     *         assuming different compiler version is no problem.\n     */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        bytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 secondSupportedInterface = ILegacyMintableERC20.l1Token.selector ^\n            ILegacyMintableERC20.mint.selector ^\n            ILegacyMintableERC20.burn.selector;\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n}\n\n/**\n * @title StandardBridge_Stateless_Test\n * @notice Tests internal functions that require no existing state or contract\n *         interactions with the messenger.\n */\ncontract StandardBridge_Stateless_Test is CommonTest {\n    StandardBridgeTester internal bridge;\n    OptimismMintableERC20 internal mintable;\n    ERC20 internal erc20;\n    LegacyMintable internal legacy;\n\n    function setUp() public override {\n        super.setUp();\n\n        bridge = new StandardBridgeTester({\n            _messenger: payable(address(0)),\n            _otherBridge: payable(address(0))\n        });\n\n        mintable = new OptimismMintableERC20({\n            _bridge: address(0),\n            _remoteToken: address(0),\n            _name: \"Stonks\",\n            _symbol: \"STONK\"\n        });\n\n        erc20 = new ERC20(\"Altcoin\", \"ALT\");\n        legacy = new LegacyMintable(\"Legacy\", \"LEG\");\n    }\n\n    /**\n     * @notice Test coverage for identifying OptimismMintableERC20 tokens.\n     *         This function should return true for both modern and legacy\n     *         OptimismMintableERC20 tokens and false for any accounts that\n     *         do not implement the interface.\n     */\n    function test_isOptimismMintableERC20_succeeds() external {\n        // Both the modern and legacy mintable tokens should return true\n        assertTrue(bridge.isOptimismMintableERC20(address(mintable)));\n        assertTrue(bridge.isOptimismMintableERC20(address(legacy)));\n        // A regular ERC20 should return false\n        assertFalse(bridge.isOptimismMintableERC20(address(erc20)));\n        // Non existent contracts should return false and not revert\n        assertEq(address(0x20).code.length, 0);\n        assertFalse(bridge.isOptimismMintableERC20(address(0x20)));\n    }\n\n    /**\n     * @notice Test coverage of isCorrectTokenPair under different types of\n     *         tokens.\n     */\n    function test_isCorrectTokenPair_succeeds() external {\n        // Modern + known to be correct remote token\n        assertTrue(bridge.isCorrectTokenPair(address(mintable), mintable.remoteToken()));\n        // Modern + known to be correct l1Token (legacy interface)\n        assertTrue(bridge.isCorrectTokenPair(address(mintable), mintable.l1Token()));\n        // Modern + known to be incorrect remote token\n        assertTrue(mintable.remoteToken() != address(0x20));\n        assertFalse(bridge.isCorrectTokenPair(address(mintable), address(0x20)));\n        // Legacy + known to be correct l1Token\n        assertTrue(bridge.isCorrectTokenPair(address(legacy), legacy.l1Token()));\n        // Legacy + known to be incorrect l1Token\n        assertTrue(legacy.l1Token() != address(0x20));\n        assertFalse(bridge.isCorrectTokenPair(address(legacy), address(0x20)));\n        // A token that doesn't support either modern or legacy interface\n        // will revert\n        vm.expectRevert();\n        bridge.isCorrectTokenPair(address(erc20), address(1));\n    }\n}\n"
    },
    "contracts/test/SystemConfig.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract SystemConfig_Init is CommonTest {\n    SystemConfig sysConf;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n\n        sysConf = new SystemConfig({\n            _owner: alice,\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(1),\n            _config: config\n        });\n    }\n}\n\ncontract SystemConfig_Initialize_TestFail is SystemConfig_Init {\n    function test_initialize_lowGasLimit_reverts() external {\n        uint64 minimumGasLimit = sysConf.minimumGasLimit();\n\n        ResourceMetering.ResourceConfig memory cfg = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n        new SystemConfig({\n            _owner: alice,\n            _overhead: 0,\n            _scalar: 0,\n            _batcherHash: bytes32(hex\"\"),\n            _gasLimit: minimumGasLimit - 1,\n            _unsafeBlockSigner: address(1),\n            _config: cfg\n        });\n    }\n}\n\ncontract SystemConfig_Setters_TestFail is SystemConfig_Init {\n    function test_setBatcherHash_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setBatcherHash(bytes32(hex\"\"));\n    }\n\n    function test_setGasConfig_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasConfig(0, 0);\n    }\n\n    function test_setGasLimit_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasLimit(0);\n    }\n\n    function test_setUnsafeBlockSigner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setUnsafeBlockSigner(address(0x20));\n    }\n\n    function test_setResourceConfig_notOwner_reverts() external {\n        ResourceMetering.ResourceConfig memory config = Constants.DEFAULT_RESOURCE_CONFIG();\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_badMinMax_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 2 gwei,\n            maximumBaseFee: 1 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: min base fee must be less than max base\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_zeroDenominator_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 0,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: denominator must be larger than 1\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_lowGasLimit_reverts() external {\n        uint64 gasLimit = sysConf.gasLimit();\n\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: uint32(gasLimit),\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: uint32(gasLimit),\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_badPrecision_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 11,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: precision loss with target resource limit\");\n        sysConf.setResourceConfig(config);\n    }\n}\n\ncontract SystemConfig_Setters_Test is SystemConfig_Init {\n    event ConfigUpdate(\n        uint256 indexed version,\n        SystemConfig.UpdateType indexed updateType,\n        bytes data\n    );\n\n    function testFuzz_setBatcherHash_succeeds(bytes32 newBatcherHash) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.BATCHER, abi.encode(newBatcherHash));\n\n        vm.prank(sysConf.owner());\n        sysConf.setBatcherHash(newBatcherHash);\n        assertEq(sysConf.batcherHash(), newBatcherHash);\n    }\n\n    function testFuzz_setGasConfig_succeeds(uint256 newOverhead, uint256 newScalar) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.GAS_CONFIG,\n            abi.encode(newOverhead, newScalar)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasConfig(newOverhead, newScalar);\n        assertEq(sysConf.overhead(), newOverhead);\n        assertEq(sysConf.scalar(), newScalar);\n    }\n\n    function testFuzz_setGasLimit_succeeds(uint64 newGasLimit) external {\n        uint64 minimumGasLimit = sysConf.minimumGasLimit();\n        newGasLimit = uint64(\n            bound(uint256(newGasLimit), uint256(minimumGasLimit), uint256(type(uint64).max))\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.GAS_LIMIT, abi.encode(newGasLimit));\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasLimit(newGasLimit);\n        assertEq(sysConf.gasLimit(), newGasLimit);\n    }\n\n    function testFuzz_setUnsafeBlockSigner_succeeds(address newUnsafeSigner) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.UNSAFE_BLOCK_SIGNER,\n            abi.encode(newUnsafeSigner)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setUnsafeBlockSigner(newUnsafeSigner);\n        assertEq(sysConf.unsafeBlockSigner(), newUnsafeSigner);\n    }\n}\n"
    },
    "contracts/test/TransferOnion.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { TransferOnion } from \"../periphery/TransferOnion.sol\";\n\n/**\n * @title  TransferOnionTest\n * @notice Test coverage of TransferOnion\n */\ncontract TransferOnionTest is Test {\n    /**\n     * @notice TransferOnion\n     */\n    TransferOnion internal onion;\n\n    /**\n     * @notice token constructor arg\n     */\n    address internal _token;\n\n    /**\n     * @notice sender constructor arg\n     */\n    address internal _sender;\n\n    /**\n     * @notice Sets up addresses, deploys contracts and funds the owner.\n     */\n    function setUp() public {\n        ERC20 token = new ERC20(\"Token\", \"TKN\");\n        _token = address(token);\n        _sender = makeAddr(\"sender\");\n    }\n\n    /**\n     * @notice Deploy the TransferOnion with a dummy shell\n     */\n    function _deploy() public {\n        _deploy(bytes32(0));\n    }\n\n    /**\n     * @notice Deploy the TransferOnion with a specific shell\n     */\n    function _deploy(bytes32 _shell) public {\n        onion = new TransferOnion({ _token: ERC20(_token), _sender: _sender, _shell: _shell });\n    }\n\n    /**\n     * @notice Build the onion data\n     */\n    function _onionize(TransferOnion.Layer[] memory _layers)\n        public\n        pure\n        returns (bytes32, TransferOnion.Layer[] memory)\n    {\n        uint256 length = _layers.length;\n        bytes32 hash = bytes32(0);\n        for (uint256 i; i < length; i++) {\n            TransferOnion.Layer memory layer = _layers[i];\n            _layers[i].shell = hash;\n            hash = keccak256(abi.encode(layer.recipient, layer.amount, hash));\n        }\n        return (hash, _layers);\n    }\n\n    /**\n     * @notice The constructor sets the variables as expected\n     */\n    function test_constructor_succeeds() external {\n        _deploy();\n\n        assertEq(address(onion.TOKEN()), _token);\n        assertEq(onion.SENDER(), _sender);\n        assertEq(onion.shell(), bytes32(0));\n    }\n\n    /**\n     * @notice unwrap\n     */\n    function test_unwrap_succeeds() external {\n        // Commit to transferring tiny amounts of tokens\n        TransferOnion.Layer[] memory _layers = new TransferOnion.Layer[](2);\n        _layers[0] = TransferOnion.Layer(address(1), 1, bytes32(0));\n        _layers[1] = TransferOnion.Layer(address(2), 2, bytes32(0));\n\n        // Build the onion shell\n        (bytes32 shell, TransferOnion.Layer[] memory layers) = _onionize(_layers);\n        _deploy(shell);\n\n        assertEq(onion.shell(), shell);\n\n        address token = address(onion.TOKEN());\n        address sender = onion.SENDER();\n\n        // give 3 units of token to sender\n        deal(token, onion.SENDER(), 3);\n        vm.prank(sender);\n        ERC20(token).approve(address(onion), 3);\n\n        // To build the inputs, to `peel`, need to reverse the list\n        TransferOnion.Layer[] memory inputs = new TransferOnion.Layer[](2);\n        int256 length = int256(layers.length);\n        for (int256 i = length - 1; i >= 0; i--) {\n            uint256 ui = uint256(i);\n            uint256 revidx = uint256(length) - ui - 1;\n            TransferOnion.Layer memory layer = layers[ui];\n            inputs[revidx] = layer;\n        }\n\n        // The accounts have no balance\n        assertEq(ERC20(_token).balanceOf(address(1)), 0);\n        assertEq(ERC20(_token).balanceOf(address(2)), 0);\n\n        onion.peel(inputs);\n\n        // Now the accounts have the expected balance\n        assertEq(ERC20(_token).balanceOf(address(1)), 1);\n        assertEq(ERC20(_token).balanceOf(address(2)), 2);\n    }\n}\n"
    },
    "contracts/test/invariants/CrossDomainMessenger.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\nimport { OptimismPortal } from \"../../L1/OptimismPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../../L1/L1CrossDomainMessenger.sol\";\nimport { Messenger_Initializer } from \"../CommonTest.t.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\nimport { Predeploys } from \"../../libraries/Predeploys.sol\";\nimport { Constants } from \"../../libraries/Constants.sol\";\nimport { Encoding } from \"../../libraries/Encoding.sol\";\nimport { Hashing } from \"../../libraries/Hashing.sol\";\n\ncontract RelayActor is StdUtils {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    uint256 public numHashes;\n    bytes32[] public hashes;\n    bool public reverted = false;\n\n    OptimismPortal op;\n    L1CrossDomainMessenger xdm;\n    Vm vm;\n    bool doFail;\n\n    constructor(\n        OptimismPortal _op,\n        L1CrossDomainMessenger _xdm,\n        Vm _vm,\n        bool _doFail\n    ) {\n        op = _op;\n        xdm = _xdm;\n        vm = _vm;\n        doFail = _doFail;\n    }\n\n    /**\n     * Relays a message to the `L1CrossDomainMessenger` with a random `version`, and `_message`.\n     */\n    function relay(\n        uint8 _version,\n        uint8 _value,\n        bytes memory _message\n    ) external {\n        address target = address(0x04); // ID precompile\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the minimum gas limit to the cost of the identity precompile's execution for\n        // the given message.\n        // ID Precompile cost can be determined by calculating: 15 + 3 * data_word_length\n        uint32 minGasLimit = uint32(15 + 3 * ((_message.length + 31) / 32));\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Restrict version to the range of [0, 1]\n        _version = _version % 2;\n\n        // Restrict the value to the range of [0, 1]\n        // This is just so we get variance of calls with and without value. The ID precompile\n        // will not reject value being sent to it.\n        _value = _value % 2;\n\n        // If the message should succeed, supply it `baseGas`. If not, supply it an amount of\n        // gas that is too low to complete the call.\n        uint256 gas = doFail\n            ? bound(minGasLimit, 60_000, 80_000)\n            : xdm.baseGas(_message, minGasLimit);\n\n        // Compute the cross domain message hash and store it in `hashes`.\n        // The `relayMessage` function will always encode the message as a version 1\n        // message after checking that the V0 hash has not already been relayed.\n        bytes32 _hash = Hashing.hashCrossDomainMessageV1(\n            Encoding.encodeVersionedNonce(0, _version),\n            sender,\n            target,\n            _value,\n            minGasLimit,\n            _message\n        );\n        hashes.push(_hash);\n        numHashes += 1;\n\n        // Make sure we've got a fresh message.\n        vm.assume(xdm.successfulMessages(_hash) == false && xdm.failedMessages(_hash) == false);\n\n        // Act as the optimism portal and call `relayMessage` on the `L1CrossDomainMessenger` with\n        // the outer min gas limit.\n        vm.startPrank(address(op));\n        if (!doFail) {\n            vm.expectCallMinGas(address(0x04), _value, minGasLimit, _message);\n        }\n        try\n            xdm.relayMessage{ gas: gas, value: _value }(\n                Encoding.encodeVersionedNonce(0, _version),\n                sender,\n                target,\n                _value,\n                minGasLimit,\n                _message\n            )\n        {} catch {\n            // If any of these calls revert, set `reverted` to true to fail the invariant test.\n            // NOTE: This is to get around forge's invariant fuzzer ignoring reverted calls\n            // to this function.\n            reverted = true;\n        }\n        vm.stopPrank();\n    }\n}\n\ncontract XDM_MinGasLimits is Messenger_Initializer {\n    RelayActor actor;\n\n    function init(bool doFail) public virtual {\n        // Set up the `L1CrossDomainMessenger` and `OptimismPortal` contracts.\n        super.setUp();\n\n        // Deploy a relay actor\n        actor = new RelayActor(op, L1Messenger, vm, doFail);\n\n        // Give the portal some ether to send to `relayMessage`\n        vm.deal(address(op), type(uint128).max);\n\n        // Target the `RelayActor` contract\n        targetContract(address(actor));\n\n        // Don't allow the estimation address to be the sender\n        excludeSender(Constants.ESTIMATION_ADDRESS);\n\n        // Target the actor's `relay` function\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.relay.selector;\n        targetSelector(FuzzSelector({ addr: address(actor), selectors: selectors }));\n    }\n}\n\ncontract XDM_MinGasLimits_Succeeds is XDM_MinGasLimits {\n    function setUp() public override {\n        // Don't fail\n        super.init(false);\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should succeed if at least the minimum gas limit\n     *                   can be supplied to the target context, there is enough gas to complete\n     *                   execution of `relayMessage` after the target context's execution is\n     *                   finished, and the target context did not revert.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `OptimismPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    function invariant_minGasLimits() external {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // The message hash is set in the successfulMessages mapping\n            assertTrue(L1Messenger.successfulMessages(hash));\n            // The message hash is not set in the failedMessages mapping\n            assertFalse(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n}\n\ncontract XDM_MinGasLimits_Reverts is XDM_MinGasLimits {\n    function setUp() public override {\n        // Do fail\n        super.init(true);\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should assign the message hash to the\n     *                   `failedMessages` mapping if not enough gas is supplied to forward\n     *                   `minGasLimit` to the target context or if there is not enough gas to\n     *                   complete execution of `relayMessage` after the target context's execution\n     *                   is finished.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `OptimismPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    function invariant_minGasLimits() external {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // The message hash is not set in the successfulMessages mapping\n            assertFalse(L1Messenger.successfulMessages(hash));\n            // The message hash is set in the failedMessages mapping\n            assertTrue(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n}\n"
    },
    "contracts/test/invariants/L2OutputOracle.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { L2OutputOracle_Initializer } from \"../CommonTest.t.sol\";\nimport { L2OutputOracle } from \"../../L1/L2OutputOracle.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\ncontract L2OutputOracle_Proposer {\n    L2OutputOracle internal oracle;\n    Vm internal vm;\n\n    constructor(L2OutputOracle _oracle, Vm _vm) {\n        oracle = _oracle;\n        vm = _vm;\n    }\n\n    /**\n     * @dev Allows the actor to propose an L2 output to the `L2OutputOracle`\n     */\n    function proposeL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external {\n        // Act as the proposer and propose a new output.\n        vm.prank(oracle.PROPOSER());\n        oracle.proposeL2Output(_outputRoot, _l2BlockNumber, _l1BlockHash, _l1BlockNumber);\n    }\n}\n\ncontract L2OutputOracle_MonotonicBlockNumIncrease_Invariant is L2OutputOracle_Initializer {\n    L2OutputOracle_Proposer internal actor;\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create a proposer actor.\n        actor = new L2OutputOracle_Proposer(oracle, vm);\n\n        // Set the target contract to the proposer actor.\n        targetContract(address(actor));\n\n        // Set the target selector for `proposeL2Output`\n        // `proposeL2Output` is the only function we care about, as it is the only function\n        // that can modify the `l2Outputs` array in the oracle.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.proposeL2Output.selector;\n        FuzzSelector memory selector = FuzzSelector({ addr: address(actor), selectors: selectors });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The block number of the output root proposals should monotonically\n     * increase.\n     *\n     * When a new output is submitted, it should never be allowed to correspond to a block\n     * number that is less than the current output.\n     */\n    function invariant_monotonicBlockNumIncrease() external {\n        // Assert that the block number of proposals must monotonically increase.\n        assertTrue(oracle.nextBlockNumber() >= oracle.latestBlockNumber());\n    }\n}\n"
    },
    "contracts/test/invariants/OptimismPortal.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Portal_Initializer } from \"../CommonTest.t.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\n\ncontract OptimismPortal_Invariant_Harness is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _proposedOutputIndex;\n    uint256 _proposedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _proposedBlockNumber = oracle.nextBlockNumber();\n        _proposedOutputIndex = oracle.nextOutputIndex();\n\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_proposedBlockNumber) + 1);\n        vm.prank(oracle.PROPOSER());\n        oracle.proposeL2Output(_outputRoot, _proposedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've proposed.\n        vm.warp(\n            oracle.getL2Output(_proposedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(op), 0xFFFFFFFF);\n    }\n}\n\ncontract OptimismPortal_CannotTimeTravel is OptimismPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Set the target contract to the portal proxy\n        targetContract(address(op));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the finalization\n     * period has not elapsed.\n     *\n     * A withdrawal that has been proven should not be able to be finalized until after\n     * the finalization period has elapsed.\n     */\n    function invariant_cannotFinalizeBeforePeriodHasPassed() external {\n        vm.expectRevert(\"OptimismPortal: proven withdrawal finalization period has not elapsed\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract OptimismPortal_CannotFinalizeTwice is OptimismPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction.\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(op));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the withdrawal\n     * has already been finalized.\n     *\n     * Ensures that there is no chain of calls that can be made that allows a withdrawal\n     * to be finalized twice.\n     */\n    function invariant_cannotFinalizeTwice() external {\n        vm.expectRevert(\"OptimismPortal: withdrawal has already been finalized\");\n        op.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract OptimismPortal_CanAlwaysFinalizeAfterWindow is OptimismPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        op.proveWithdrawalTransaction(\n            _defaultTx,\n            _proposedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(op));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant A withdrawal should **always** be able to be finalized\n     * `FINALIZATION_PERIOD_SECONDS` after it was successfully proven.\n     *\n     * This invariant asserts that there is no chain of calls that can be made that\n     * will prevent a withdrawal from being finalized exactly `FINALIZATION_PERIOD_SECONDS`\n     * after it was successfully proven.\n     */\n    function invariant_canAlwaysFinalize() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        op.finalizeWithdrawalTransaction(_defaultTx);\n\n        assertEq(address(bob).balance, bobBalanceBefore + _defaultTx.value);\n    }\n}\n"
    },
    "contracts/test/invariants/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\nimport { SafeCall } from \"../../libraries/SafeCall.sol\";\n\ncontract SafeCall_Succeeds_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, false);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n\n        // Give the actor some ETH to work with\n        vm.deal(address(actor), type(uint128).max);\n    }\n\n    /**\n     * @custom:invariant If `callWithMinGas` performs a call, then it must always\n     * provide at least the specified minimum gas limit to the subcontext.\n     *\n     * If the check for remaining gas in `SafeCall.callWithMinGas` passes, the\n     * subcontext of the call below it must be provided at least `minGas` gas.\n     */\n    function invariant_callWithMinGas_alwaysForwardsMinGas_succeeds() public {\n        assertEq(actor.numCalls(), 0, \"no failed calls allowed\");\n    }\n\n    function performSafeCallMinGas(address to, uint64 minGas) external payable {\n        SafeCall.callWithMinGas(to, minGas, msg.value, hex\"\");\n    }\n}\n\ncontract SafeCall_Fails_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, true);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n\n        // Give the actor some ETH to work with\n        vm.deal(address(actor), type(uint128).max);\n    }\n\n    /**\n     * @custom:invariant `callWithMinGas` reverts if there is not enough gas to pass\n     * to the subcontext.\n     *\n     * If there is not enough gas in the callframe to ensure that `callWithMinGas`\n     * can provide the specified minimum gas limit to the subcontext of the call,\n     * then `callWithMinGas` must revert.\n     */\n    function invariant_callWithMinGas_neverForwardsMinGas_reverts() public {\n        assertEq(actor.numCalls(), 0, \"no successful calls allowed\");\n    }\n\n    function performSafeCallMinGas(address to, uint64 minGas) external payable {\n        SafeCall.callWithMinGas(to, minGas, msg.value, hex\"\");\n    }\n}\n\ncontract SafeCaller_Actor is StdUtils {\n    bool internal immutable FAILS;\n\n    Vm internal vm;\n    uint256 public numCalls;\n\n    constructor(Vm _vm, bool _fails) {\n        vm = _vm;\n        FAILS = _fails;\n    }\n\n    function performSafeCallMinGas(\n        uint64 gas,\n        uint64 minGas,\n        address to,\n        uint8 value\n    ) external {\n        // Only send to EOAs - we exclude the console as it has no code but reverts when called\n        // with a selector that doesn't exist due to the foundry hook.\n        vm.assume(to.code.length == 0 && to != 0x000000000000000000636F6e736F6c652e6c6f67);\n\n        // Bound the minimum gas amount to [2500, type(uint48).max]\n        minGas = uint64(bound(minGas, 2500, type(uint48).max));\n        if (FAILS) {\n            // Bound the gas passed to [minGas, ((minGas * 64) / 63)]\n            gas = uint64(bound(gas, minGas, (minGas * 64) / 63));\n        } else {\n            // Bound the gas passed to\n            // [((minGas * 64) / 63) + 40_000 + 1000, type(uint64).max]\n            // The extra 1000 gas is to account for the gas used by the `SafeCall.call` call\n            // itself.\n            gas = uint64(bound(gas, ((minGas * 64) / 63) + 40_000 + 1000, type(uint64).max));\n        }\n\n        vm.expectCallMinGas(to, value, minGas, hex\"\");\n        bool success = SafeCall.call(\n            msg.sender,\n            gas,\n            value,\n            abi.encodeWithSelector(\n                SafeCall_Succeeds_Invariants.performSafeCallMinGas.selector,\n                to,\n                minGas\n            )\n        );\n\n        if (success && FAILS) numCalls++;\n        if (!FAILS && !success) numCalls++;\n    }\n}\n"
    },
    "contracts/test/invariants/SystemConfig.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { SystemConfig } from \"../../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../../L1/ResourceMetering.sol\";\nimport { Constants } from \"../../libraries/Constants.sol\";\n\ncontract SystemConfig_GasLimitLowerBound_Invariant is Test {\n    SystemConfig public config;\n\n    function setUp() public {\n        ResourceMetering.ResourceConfig memory cfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        config = new SystemConfig({\n            _owner: address(0xbeef),\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(1),\n            _config: cfg\n        });\n\n        // Set the target contract to the `config`\n        targetContract(address(config));\n        // Set the target sender to the `config`'s owner (0xbeef)\n        targetSender(address(0xbeef));\n        // Set the target selector for `setGasLimit`\n        // `setGasLimit` is the only function we care about, as it is the only function\n        // that can modify the gas limit within the SystemConfig.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = config.setGasLimit.selector;\n        FuzzSelector memory selector = FuzzSelector({\n            addr: address(config),\n            selectors: selectors\n        });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The gas limit of the `SystemConfig` contract can never be lower\n     * than the hard-coded lower bound.\n     */\n    function invariant_gasLimitLowerBound() external {\n        assertTrue(config.gasLimit() >= config.minimumGasLimit());\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer0\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\n *         tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer0 {\n    /**\n     * @custom:legacy\n     * @custom:spacer libAddressManager\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_0_0_20;\n}\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer1\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\n *         the third contract in the inheritance tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer1 {\n    /**\n     * @custom:legacy\n     * @custom:spacer ContextUpgradable's __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable.\n     *\n     */\n    uint256[50] private spacer_1_0_1600;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer OwnableUpgradeable's _owner\n     * @notice Spacer for backwards compatibility.\n     *         Come from OpenZeppelin OwnableUpgradeable.\n     */\n    address private spacer_51_0_20;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer OwnableUpgradeable's __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         OwnableUpgradeable.\n     */\n    uint256[49] private spacer_52_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer PausableUpgradable's _paused\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    bool private spacer_101_0_1;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer PausableUpgradable's __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    uint256[49] private spacer_102_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 private spacer_151_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's __gap\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256[49] private spacer_152_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer blockedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_201_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer relayedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_202_0_32;\n}\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is\n    CrossDomainMessengerLegacySpacer0,\n    Initializable,\n    CrossDomainMessengerLegacySpacer1\n{\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Gas reserved for performing the external call in `relayMessage`.\n     */\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\n\n    /**\n     * @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\n     */\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\n\n    /**\n     * @notice Gas reserved for the execution between the `hasMinGas` check and the external\n     *         call in `relayMessage`.\n     */\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 41 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[42] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\n     *         SentMessage event without breaking the ABI of this contract, this is good enough.\n     *\n     * @param sender Address of the sender of the message.\n     * @param value  ETH value sent along with the message to the recipient.\n     */\n    event SentMessageExtension1(address indexed sender, uint256 value);\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 2,\n            \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n        );\n\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\n        // to check that the legacy version of the message has not already been relayed.\n        if (version == 0) {\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\n            require(\n                successfulMessages[oldHash] == false,\n                \"CrossDomainMessenger: legacy withdrawal already relayed\"\n            );\n        }\n\n        // We use the v1 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _value);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        // If there is not enough gas left to perform the external call and finish the execution,\n        // return early and assign the message to the failedMessages mapping.\n        // We are asserting that we have enough gas to:\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\n        //\n        // If `xDomainMsgSender` is not the default L2 sender, this function\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\n        if (\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n        ) {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n\n            return;\n        }\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n        }\n    }\n\n    /**\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\n     *         executing message on the other chain. Will throw an error if there is no message\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\n     *\n     * @return Address of the sender of the currently executing message on the other chain.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,\n            \"CrossDomainMessenger: xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * @notice Computes the amount of gas required to guarantee that a given message will be\n     *         received on the other chain without running out of gas. Guaranteeing that a message\n     *         will not run out of gas is important because this ensures that a message can always\n     *         be replayed on the other chain if it fails to execute completely.\n     *\n     * @param _message     Message to compute the amount of required gas for.\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\n     *\n     * @return Amount of gas required to guarantee message receipt.\n     */\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\n        return\n            // Constant overhead\n            RELAY_CONSTANT_OVERHEAD +\n            // Calldata overhead\n            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\n            // Dynamic overhead (EIP-150)\n            ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\n            // Gas reserved for the worst-case cost of 3/5 of the `CALL` opcode's dynamic gas\n            // factors. (Conservative)\n            RELAY_CALL_OVERHEAD +\n            // Relay reserved gas (to ensure execution of `relayMessage` completes after the\n            // subcontext finishes executing) (Conservative)\n            RELAY_RESERVED_GAS +\n            // Gas reserved for the execution between the `hasMinGas` check and the `CALL`\n            // opcode. (Conservative)\n            RELAY_GAS_CHECK_BUFFER;\n    }\n\n    /**\n     * @notice Intializer.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __CrossDomainMessenger_init() internal onlyInitializing {\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n    }\n\n    /**\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @param _to       Recipient of the message on the other chain.\n     * @param _gasLimit Minimum gas limit the message can be executed with.\n     * @param _value    Amount of ETH to send with the message.\n     * @param _data     Message data.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @return Whether the message is coming from the other messenger.\n     */\n    function _isOtherMessenger() internal view virtual returns (bool);\n\n    /**\n     * @notice Checks whether a given call target is a system address that could cause the\n     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\n     *         addresses. This is ONLY used to prevent the execution of messages to specific\n     *         system addresses that could cause security issues, e.g., having the\n     *         CrossDomainMessenger send messages to itself.\n     *\n     * @param _target Address of the contract to check.\n     *\n     * @return Whether or not the address is an unsafe system address.\n     */\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\n}\n"
    },
    "contracts/universal/ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title ERC721Bridge\n * @notice ERC721Bridge is a base contract for the L1 and L2 ERC721 bridges.\n */\nabstract contract ERC721Bridge {\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Address of the bridge on the other network.\n     */\n    address public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ERC721 bridge to the other network is initiated.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC721 bridge from the other network is finalized.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) && MESSENGER.xDomainMessageSender() == OTHER_BRIDGE,\n            \"ERC721Bridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge) {\n        require(_messenger != address(0), \"ERC721Bridge: messenger cannot be address(0)\");\n        require(_otherBridge != address(0), \"ERC721Bridge: other bridge cannot be address(0)\");\n\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = _otherBridge;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for messenger contract.\n     *\n     * @return Messenger contract on this domain.\n     */\n    function messenger() external view returns (CrossDomainMessenger) {\n        return MESSENGER;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for other bridge address.\n     *\n     * @return Address of the bridge on the other network.\n     */\n    function otherBridge() external view returns (address) {\n        return OTHER_BRIDGE;\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to the caller's account on the other chain. Note that\n     *         this function can only be called by EOAs. Smart contract wallets should use the\n     *         `bridgeERC721To` function after ensuring that the recipient address on the remote\n     *         chain exists. Also note that the current owner of the token on this chain must\n     *         approve this contract to operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Optimism-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        // Modifier requiring sender to be EOA. This prevents against a user error that would occur\n        // if the sender is a smart contract wallet that has a different address on the remote chain\n        // (or doesn't have an address on the remote chain at all). The user would fail to receive\n        // the NFT if they use this function because it sends the NFT to the same address as the\n        // caller. This check could be bypassed by a malicious contract via initcode, but it takes\n        // care of the user error we want to avoid.\n        require(!Address.isContract(msg.sender), \"ERC721Bridge: account is not externally owned\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to some recipient's account on the other chain. Note\n     *         that the current owner of the token on this chain must approve this contract to\n     *         operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Optimism. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Optimism-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        require(_to != address(0), \"ERC721Bridge: nft recipient cannot be address(0)\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Internal function for initiating a token bridge to the other domain.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _from        Address of the sender on this domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other domain. Data supplied here will\n     *                     not be used to execute any code on the other domain and is only emitted\n     *                     as extra data for the convenience of off-chain tooling.\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "contracts/universal/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\n/**\n * @title FeeVault\n * @notice The FeeVault contract contains the basic logic for the various different vault contracts\n *         used to hold fee revenue generated by the L2 system.\n */\nabstract contract FeeVault {\n    /**\n     * @notice Emits each time that a withdrawal occurs.\n     *\n     * @param value Amount that was withdrawn (in wei).\n     * @param to    Address that the funds were sent to.\n     * @param from  Address that triggered the withdrawal.\n     */\n    event Withdrawal(uint256 value, address to, address from);\n\n    /**\n     * @notice Minimum balance before a withdrawal can be triggered.\n     */\n    uint256 public immutable MIN_WITHDRAWAL_AMOUNT;\n\n    /**\n     * @notice Wallet that will receive the fees on L1.\n     */\n    address public immutable RECIPIENT;\n\n    /**\n     * @notice The minimum gas limit for the FeeVault withdrawal transaction.\n     */\n    uint32 internal constant WITHDRAWAL_MIN_GAS = 35_000;\n\n    /**\n     * @notice Total amount of wei processed by the contract.\n     */\n    uint256 public totalProcessed;\n\n    /**\n     * @param _recipient           Wallet that will receive the fees on L1.\n     * @param _minWithdrawalAmount Minimum balance before a withdrawal can be triggered.\n     */\n    constructor(address _recipient, uint256 _minWithdrawalAmount) {\n        MIN_WITHDRAWAL_AMOUNT = _minWithdrawalAmount;\n        RECIPIENT = _recipient;\n    }\n\n    /**\n     * @notice Allow the contract to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Triggers a withdrawal of funds to the L1 fee wallet.\n     */\n    function withdraw() external {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            \"FeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        uint256 value = address(this).balance;\n        totalProcessed += value;\n\n        emit Withdrawal(value, RECIPIENT, msg.sender);\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).bridgeETHTo{ value: value }(\n            RECIPIENT,\n            WITHDRAWAL_MIN_GAS,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/universal/IOptimismMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title IOptimismMintableERC20\n * @notice This interface is available on the OptimismMintableERC20 contract. We declare it as a\n *         separate interface so that it can be used in custom implementations of\n *         OptimismMintableERC20.\n */\ninterface IOptimismMintableERC20 is IERC165 {\n    function remoteToken() external view returns (address);\n\n    function bridge() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n\n/**\n * @custom:legacy\n * @title ILegacyMintableERC20\n * @notice This interface was available on the legacy L2StandardERC20 contract. It remains available\n *         on the OptimismMintableERC20 contract for backwards compatibility.\n */\ninterface ILegacyMintableERC20 is IERC165 {\n    function l1Token() external view returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "contracts/universal/IOptimismMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    IERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n/**\n * @title IOptimismMintableERC721\n * @notice Interface for contracts that are compatible with the OptimismMintableERC721 standard.\n *         Tokens that follow this standard can be easily transferred across the ERC721 bridge.\n */\ninterface IOptimismMintableERC721 is IERC721Enumerable {\n    /**\n     * @notice Emitted when a token is minted.\n     *\n     * @param account Address of the account the token was minted to.\n     * @param tokenId Token ID of the minted token.\n     */\n    event Mint(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Emitted when a token is burned.\n     *\n     * @param account Address of the account the token was burned from.\n     * @param tokenId Token ID of the burned token.\n     */\n    event Burn(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Mints some token ID for a user, checking first that contract recipients\n     *         are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * @param _to      Address of the user to mint the token for.\n     * @param _tokenId Token ID to mint.\n     */\n    function safeMint(address _to, uint256 _tokenId) external;\n\n    /**\n     * @notice Burns a token ID from a user.\n     *\n     * @param _from    Address of the user to burn the token from.\n     * @param _tokenId Token ID to burn.\n     */\n    function burn(address _from, uint256 _tokenId) external;\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function REMOTE_CHAIN_ID() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function REMOTE_TOKEN() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function BRIDGE() external view returns (address);\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function remoteChainId() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function remoteToken() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function bridge() external view returns (address);\n}\n"
    },
    "contracts/universal/OptimismMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { ILegacyMintableERC20, IOptimismMintableERC20 } from \"./IOptimismMintableERC20.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title OptimismMintableERC20\n * @notice OptimismMintableERC20 is a standard extension of the base ERC20 token contract designed\n *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\n *         use an OptimismMintablERC20 as the L2 representation of an L1 token, or vice-versa.\n *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\n *         meant for use on L2.\n */\ncontract OptimismMintableERC20 is IOptimismMintableERC20, ILegacyMintableERC20, ERC20, Semver {\n    /**\n     * @notice Address of the corresponding version of this token on the remote chain.\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @notice Address of the StandardBridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever tokens are minted for an account.\n     *\n     * @param account Address of the account tokens are being minted for.\n     * @param amount  Amount of tokens minted.\n     */\n    event Mint(address indexed account, uint256 amount);\n\n    /**\n     * @notice Emitted whenever tokens are burned from an account.\n     *\n     * @param account Address of the account tokens are being burned from.\n     * @param amount  Amount of tokens burned.\n     */\n    event Burn(address indexed account, uint256 amount);\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"OptimismMintableERC20: only bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.0.0\n     *\n     * @param _bridge      Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) Semver(1, 0, 0) {\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to mint tokens.\n     *\n     * @param _to     Address to mint tokens to.\n     * @param _amount Amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        virtual\n        override(IOptimismMintableERC20, ILegacyMintableERC20)\n        onlyBridge\n    {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to burn tokens.\n     *\n     * @param _from   Address to burn tokens from.\n     * @param _amount Amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        virtual\n        override(IOptimismMintableERC20, ILegacyMintableERC20)\n        onlyBridge\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n\n    /**\n     * @notice ERC165 interface check function.\n     *\n     * @param _interfaceId Interface ID to check.\n     *\n     * @return Whether or not the interface is supported by this contract.\n     */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        // Interface corresponding to the legacy L2StandardERC20.\n        bytes4 iface2 = type(ILegacyMintableERC20).interfaceId;\n        // Interface corresponding to the updated OptimismMintableERC20 (this contract).\n        bytes4 iface3 = type(IOptimismMintableERC20).interfaceId;\n        return _interfaceId == iface1 || _interfaceId == iface2 || _interfaceId == iface3;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote token. Use REMOTE_TOKEN going forward.\n     */\n    function l1Token() public view returns (address) {\n        return REMOTE_TOKEN;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the bridge. Use BRIDGE going forward.\n     */\n    function l2Bridge() public view returns (address) {\n        return BRIDGE;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for REMOTE_TOKEN.\n     */\n    function remoteToken() public view returns (address) {\n        return REMOTE_TOKEN;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for BRIDGE.\n     */\n    function bridge() public view returns (address) {\n        return BRIDGE;\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { Semver } from \"./Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeployed 0x4200000000000000000000000000000000000012\n * @title OptimismMintableERC20Factory\n * @notice OptimismMintableERC20Factory is a factory contract that generates OptimismMintableERC20\n *         contracts on the network it's deployed to. Simplifies the deployment process for users\n *         who may be less familiar with deploying smart contracts. Designed to be backwards\n *         compatible with the older StandardL2ERC20Factory contract.\n */\ncontract OptimismMintableERC20Factory is Semver {\n    /**\n     * @notice Address of the StandardBridge on this chain.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a new OptimismMintableERC20 is created. Legacy version of the newer\n     *         OptimismMintableERC20Created event. We recommend relying on that event instead.\n     *\n     * @param remoteToken Address of the token on the remote chain.\n     * @param localToken  Address of the created token on the local chain.\n     */\n    event StandardL2TokenCreated(address indexed remoteToken, address indexed localToken);\n\n    /**\n     * @notice Emitted whenever a new OptimismMintableERC20 is created.\n     *\n     * @param localToken  Address of the created token on the local chain.\n     * @param remoteToken Address of the corresponding token on the remote chain.\n     * @param deployer    Address of the account that deployed the token.\n     */\n    event OptimismMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the OptimismMintableERC20 token contract since this contract\n     *         is responsible for deploying OptimismMintableERC20 contracts.\n     *\n     * @param _bridge Address of the StandardBridge on this chain.\n     */\n    constructor(address _bridge) Semver(1, 1, 0) {\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Creates an instance of the OptimismMintableERC20 contract. Legacy version of the\n     *         newer createOptimismMintableERC20 function, which has a more intuitive name.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createStandardL2Token(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        return createOptimismMintableERC20(_remoteToken, _name, _symbol);\n    }\n\n    /**\n     * @notice Creates an instance of the OptimismMintableERC20 contract.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createOptimismMintableERC20(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) public returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"OptimismMintableERC20Factory: must provide remote token address\"\n        );\n\n        address localToken = address(\n            new OptimismMintableERC20(BRIDGE, _remoteToken, _name, _symbol)\n        );\n\n        // Emit the old event too for legacy support.\n        emit StandardL2TokenCreated(_remoteToken, localToken);\n\n        // Emit the updated event. The arguments here differ from the legacy event, but\n        // are consistent with the ordering used in StandardBridge events.\n        emit OptimismMintableERC20Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    ERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { IOptimismMintableERC721 } from \"./IOptimismMintableERC721.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title OptimismMintableERC721\n * @notice This contract is the remote representation for some token that lives on another network,\n *         typically an Optimism representation of an Ethereum-based token. Standard reference\n *         implementation that can be extended or modified according to your needs.\n */\ncontract OptimismMintableERC721 is ERC721Enumerable, IOptimismMintableERC721, Semver {\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Base token URI for this token.\n     */\n    string public baseTokenURI;\n\n    /**\n     * @notice Modifier that prevents callers other than the bridge from calling the function.\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"OptimismMintableERC721: only bridge can call this function\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _bridge        Address of the bridge on this network.\n     * @param _remoteChainId Chain ID where the remote token is deployed.\n     * @param _remoteToken   Address of the corresponding token on the other network.\n     * @param _name          ERC721 name.\n     * @param _symbol        ERC721 symbol.\n     */\n    constructor(\n        address _bridge,\n        uint256 _remoteChainId,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) Semver(1, 1, 0) {\n        require(_bridge != address(0), \"OptimismMintableERC721: bridge cannot be address(0)\");\n        require(_remoteChainId != 0, \"OptimismMintableERC721: remote chain id cannot be zero\");\n        require(\n            _remoteToken != address(0),\n            \"OptimismMintableERC721: remote token cannot be address(0)\"\n        );\n\n        REMOTE_CHAIN_ID = _remoteChainId;\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n\n        // Creates a base URI in the format specified by EIP-681:\n        // https://eips.ethereum.org/EIPS/eip-681\n        baseTokenURI = string(\n            abi.encodePacked(\n                \"ethereum:\",\n                Strings.toHexString(uint160(_remoteToken), 20),\n                \"@\",\n                Strings.toString(_remoteChainId),\n                \"/tokenURI?uint256=\"\n            )\n        );\n    }\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    function remoteChainId() external view returns (uint256) {\n        return REMOTE_CHAIN_ID;\n    }\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    function remoteToken() external view returns (address) {\n        return REMOTE_TOKEN;\n    }\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    function bridge() external view returns (address) {\n        return BRIDGE;\n    }\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    function safeMint(address _to, uint256 _tokenId) external virtual onlyBridge {\n        _safeMint(_to, _tokenId);\n\n        emit Mint(_to, _tokenId);\n    }\n\n    /**\n     * @inheritdoc IOptimismMintableERC721\n     */\n    function burn(address _from, uint256 _tokenId) external virtual onlyBridge {\n        _burn(_tokenId);\n\n        emit Burn(_from, _tokenId);\n    }\n\n    /**\n     * @notice Checks if a given interface ID is supported by this contract.\n     *\n     * @param _interfaceId The interface ID to check.\n     *\n     * @return True if the interface ID is supported, false otherwise.\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721Enumerable, IERC165)\n        returns (bool)\n    {\n        bytes4 iface = type(IOptimismMintableERC721).interfaceId;\n        return _interfaceId == iface || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Returns the base token URI.\n     *\n     * @return Base token URI.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableERC721Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { OptimismMintableERC721 } from \"./OptimismMintableERC721.sol\";\nimport { Semver } from \"./Semver.sol\";\n\n/**\n * @title OptimismMintableERC721Factory\n * @notice Factory contract for creating OptimismMintableERC721 contracts.\n */\ncontract OptimismMintableERC721Factory is Semver {\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Chain ID for the remote network.\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @notice Tracks addresses created by this factory.\n     */\n    mapping(address => bool) public isOptimismMintableERC721;\n\n    /**\n     * @notice Emitted whenever a new OptimismMintableERC721 contract is created.\n     *\n     * @param localToken  Address of the token on the this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param deployer    Address of the initiator of the deployment\n     */\n    event OptimismMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @custom:semver 1.2.0\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the OptimismMintableERC721 token contract since this contract\n     *         is responsible for deploying OptimismMintableERC721 contracts.\n     *\n     * @param _bridge Address of the ERC721 bridge on this network.\n     * @param _remoteChainId Chain ID for the remote network.\n     */\n    constructor(address _bridge, uint256 _remoteChainId) Semver(1, 2, 0) {\n        BRIDGE = _bridge;\n        REMOTE_CHAIN_ID = _remoteChainId;\n    }\n\n    /**\n     * @notice Creates an instance of the standard ERC721.\n     *\n     * @param _remoteToken Address of the corresponding token on the other domain.\n     * @param _name        ERC721 name.\n     * @param _symbol      ERC721 symbol.\n     */\n    function createOptimismMintableERC721(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"OptimismMintableERC721Factory: L1 token address cannot be address(0)\"\n        );\n\n        address localToken = address(\n            new OptimismMintableERC721(BRIDGE, REMOTE_CHAIN_ID, _remoteToken, _name, _symbol)\n        );\n\n        isOptimismMintableERC721[localToken] = true;\n        emit OptimismMintableERC721Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract Proxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        public\n        payable\n        virtual\n        proxyCallIfNotAdmin\n        returns (bytes memory)\n    {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n}\n"
    },
    "contracts/universal/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Proxy } from \"./Proxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\n\n/**\n * @title IStaticERC1967Proxy\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\n */\ninterface IStaticERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\n/**\n * @title IStaticL1ChugSplashProxy\n * @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\n */\ninterface IStaticL1ChugSplashProxy {\n    function getImplementation() external view returns (address);\n\n    function getOwner() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\n *         with the various types of proxies that have been deployed by Optimism in the past.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @notice The proxy types that the ProxyAdmin can manage.\n     *\n     * @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\n     * @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\n     * @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\n     */\n    enum ProxyType {\n        ERC1967,\n        CHUGSPLASH,\n        RESOLVED\n    }\n\n    /**\n     * @notice A mapping of proxy types, used for backwards compatibility.\n     */\n    mapping(address => ProxyType) public proxyType;\n\n    /**\n     * @notice A reverse mapping of addresses to names held in the AddressManager. This must be\n     *         manually kept up to date with changes in the AddressManager for this contract\n     *         to be able to work as an admin for the ResolvedDelegateProxy type.\n     */\n    mapping(address => string) public implementationName;\n\n    /**\n     * @notice The address of the address manager, this is required to manage the\n     *         ResolvedDelegateProxy type.\n     */\n    AddressManager public addressManager;\n\n    /**\n     * @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\n     */\n    bool internal upgrading;\n\n    /**\n     * @param _owner Address of the initial owner of this contract.\n     */\n    constructor(address _owner) Ownable() {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\n     *         proxy types.\n     *\n     * @param _address Address of the proxy.\n     * @param _type    Type of the proxy.\n     */\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\n        proxyType[_address] = _type;\n    }\n\n    /**\n     * @notice Sets the implementation name for a given address. Only required for\n     *         ResolvedDelegateProxy type proxies that have an implementation name.\n     *\n     * @param _address Address of the ResolvedDelegateProxy.\n     * @param _name    Name of the implementation for the proxy.\n     */\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\n        implementationName[_address] = _name;\n    }\n\n    /**\n     * @notice Set the address of the AddressManager. This is required to manage legacy\n     *         ResolvedDelegateProxy type proxy contracts.\n     *\n     * @param _address Address of the AddressManager.\n     */\n    function setAddressManager(AddressManager _address) external onlyOwner {\n        addressManager = _address;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set an address in the address manager. Since only the owner of the AddressManager\n     *         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\n     *         gives the owner of the ProxyAdmin the ability to modify addresses directly.\n     *\n     * @param _name    Name to set within the AddressManager.\n     * @param _address Address to attach to the given name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        addressManager.setAddress(_name, _address);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set the upgrading status for the Chugsplash proxy type.\n     *\n     * @param _upgrading Whether or not the system is upgrading.\n     */\n    function setUpgrading(bool _upgrading) external onlyOwner {\n        upgrading = _upgrading;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\n     *\n     * @return Whether or not there is an upgrade going on. May not actually tell you whether an\n     *         upgrade is going on, since we don't currently plan to use this variable for anything\n     *         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\n     */\n    function isUpgrading() external view returns (bool) {\n        return upgrading;\n    }\n\n    /**\n     * @notice Returns the implementation of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the implementation of.\n     *\n     * @return Address of the implementation of the proxy.\n     */\n    function getProxyImplementation(address _proxy) external view returns (address) {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            return IStaticERC1967Proxy(_proxy).implementation();\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\n        } else if (ptype == ProxyType.RESOLVED) {\n            return addressManager.getAddress(implementationName[_proxy]);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Returns the admin of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the admin of.\n     *\n     * @return Address of the admin of the proxy.\n     */\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            return IStaticERC1967Proxy(_proxy).admin();\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\n        } else if (ptype == ProxyType.RESOLVED) {\n            return addressManager.owner();\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Updates the admin of the given proxy address.\n     *\n     * @param _proxy    Address of the proxy to update.\n     * @param _newAdmin Address of the new proxy admin.\n     */\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).changeAdmin(_newAdmin);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\n        } else if (ptype == ProxyType.RESOLVED) {\n            addressManager.transferOwnership(_newAdmin);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     */\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeTo(_implementation);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setStorage(\n                // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                bytes32(uint256(uint160(_implementation)))\n            );\n        } else if (ptype == ProxyType.RESOLVED) {\n            string memory name = implementationName[_proxy];\n            addressManager.setAddress(name, _implementation);\n        } else {\n            // It should not be possible to retrieve a ProxyType value which is not matched by\n            // one of the previous conditions.\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     * @param _data           Data to trigger the new implementation with.\n     */\n    function upgradeAndCall(\n        address payable _proxy,\n        address _implementation,\n        bytes memory _data\n    ) external payable onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\n        } else {\n            // reverts if proxy type is unknown\n            upgrade(_proxy, _implementation);\n            (bool success, ) = _proxy.call{ value: msg.value }(_data);\n            require(success, \"ProxyAdmin: call to proxy after upgrade failed\");\n        }\n    }\n}\n"
    },
    "contracts/universal/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Semver\n * @notice Semver is a simple contract for managing contract versions.\n */\ncontract Semver {\n    /**\n     * @notice Contract version number (major).\n     */\n    uint256 private immutable MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    uint256 private immutable MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    uint256 private immutable PATCH_VERSION;\n\n    /**\n     * @param _major Version number (major).\n     * @param _minor Version number (minor).\n     * @param _patch Version number (patch).\n     */\n    constructor(\n        uint256 _major,\n        uint256 _minor,\n        uint256 _patch\n    ) {\n        MAJOR_VERSION = _major;\n        MINOR_VERSION = _minor;\n        PATCH_VERSION = _patch;\n    }\n\n    /**\n     * @notice Returns the full semver contract version.\n     *\n     * @return Semver contract version as a string.\n     */\n    function version() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Strings.toString(MAJOR_VERSION),\n                    \".\",\n                    Strings.toString(MINOR_VERSION),\n                    \".\",\n                    Strings.toString(PATCH_VERSION)\n                )\n            );\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { IOptimismMintableERC20, ILegacyMintableERC20 } from \"./IOptimismMintableERC20.sol\";\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { OptimismMintableERC20 } from \"./OptimismMintableERC20.sol\";\n\n/**\n * @custom:upgradeable\n * @title StandardBridge\n * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\n *         the core bridging logic, including escrowing tokens that are native to the local chain\n *         and minting/burning tokens that are native to the remote chain.\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\n     */\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\n\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Corresponding bridge on the other domain.\n     */\n    StandardBridge public immutable OTHER_BRIDGE;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer messenger\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_0_0_20;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer l2TokenBridge\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_1_0_20;\n\n    /**\n     * @notice Mapping that stores deposits for a given pair of local and remote tokens.\n     */\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     *         A gap size of 47 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[47] private __gap;\n\n    /**\n     * @notice Emitted when an ETH bridge is initiated to the other chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ETH bridge is finalized on this chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is finalized on this chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\n     *         calling code within their constructors, but also doesn't really matter since we're\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\n     */\n    modifier onlyEOA() {\n        require(\n            !Address.isContract(msg.sender),\n            \"StandardBridge: function can only be called from an EOA\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) &&\n                MESSENGER.xDomainMessageSender() == address(OTHER_BRIDGE),\n            \"StandardBridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the other StandardBridge contract.\n     */\n    constructor(address payable _messenger, address payable _otherBridge) {\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     *         Must be implemented by contracts that inherit.\n     */\n    receive() external payable virtual;\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for messenger contract.\n     *\n     * @return Messenger contract on this domain.\n     */\n    function messenger() external view returns (CrossDomainMessenger) {\n        return MESSENGER;\n    }\n\n    /**\n     * @notice Sends ETH to the sender's address on the other chain.\n     *\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\n     *         permanently locked in the StandardBridge on the other chain. ETH will also\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\n     *         in that case.\n     *\n     * @param _to          Address of the receiver.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public virtual onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public virtual {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH being bridged.\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\n     *                   not be triggered with this data, but it will be emitted and can be used\n     *                   to identify the transaction.\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"StandardBridge: amount sent does not match amount required\");\n        require(_to != address(this), \"StandardBridge: cannot send to self\");\n        require(_to != address(MESSENGER), \"StandardBridge: cannot send to messenger\");\n\n        // Emit the correct events. By default this will be _amount, but child\n        // contracts may override this function in order to emit legacy events as well.\n        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n        require(success, \"StandardBridge: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of the ERC20 being bridged.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public onlyOtherBridge {\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\n        // contracts may override this function in order to emit legacy events as well.\n        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\n     *\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        require(\n            msg.value == _amount,\n            \"StandardBridge: bridging ETH must include sufficient ETH value\"\n        );\n\n        // Emit the correct events. By default this will be _amount, but child\n        // contracts may override this function in order to emit legacy events as well.\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage{ value: _amount }(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\n        // contracts may override this function in order to emit legacy events as well.\n        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\n     *         Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     *\n     * @return True if the token is an OptimismMintableERC20.\n     */\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\n        return\n            ERC165Checker.supportsInterface(_token, type(ILegacyMintableERC20).interfaceId) ||\n            ERC165Checker.supportsInterface(_token, type(IOptimismMintableERC20).interfaceId);\n    }\n\n    /**\n     * @notice Checks if the \"other token\" is the correct pair token for the OptimismMintableERC20.\n     *         Calls can be saved in the future by combining this logic with\n     *         `_isOptimismMintableERC20`.\n     *\n     * @param _mintableToken OptimismMintableERC20 to check against.\n     * @param _otherToken    Pair token to check.\n     *\n     * @return True if the other token is the correct pair token for the OptimismMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            ERC165Checker.supportsInterface(_mintableToken, type(ILegacyMintableERC20).interfaceId)\n        ) {\n            return _otherToken == ILegacyMintableERC20(_mintableToken).l1Token();\n        } else {\n            return _otherToken == IOptimismMintableERC20(_mintableToken).remoteToken();\n        }\n    }\n\n    /** @notice Emits the ETHBridgeInitiated event and if necessary the appropriate legacy event\n     *          when an ETH bridge is finalized on this chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH sent.\n     * @param _extraData Extra data sent with the transaction.\n     */\n    function _emitETHBridgeInitiated(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal virtual {\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the ETHBridgeFinalized and if necessary the appropriate legacy event when an\n     *         ETH bridge is finalized on this chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH sent.\n     * @param _extraData Extra data sent with the transaction.\n     */\n    function _emitETHBridgeFinalized(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal virtual {\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the ERC20BridgeInitiated event and if necessary the appropriate legacy\n     *         event when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the ERC20 on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of the ERC20 sent.\n     * @param _extraData   Extra data sent with the transaction.\n     */\n    function _emitERC20BridgeInitiated(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal virtual {\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Emits the ERC20BridgeFinalized event and if necessary the appropriate legacy\n     *         event when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the ERC20 on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of the ERC20 sent.\n     * @param _extraData   Extra data sent with the transaction.\n     */\n    function _emitERC20BridgeFinalized(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _extraData\n    ) internal virtual {\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n}\n"
    },
    "contracts/vendor/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "node_modules/clones-with-immutable-args/src/ClonesWithImmutableArgs.sol": {
      "content": "// SPDX-License-Identifier: BSD\n\npragma solidity ^0.8.4;\n\n/// @title ClonesWithImmutableArgs\n/// @author wighawag, zefram.eth, Saw-mon & Natalie\n/// @notice Enables creating clone contracts with immutable args\nlibrary ClonesWithImmutableArgs {\n    uint256 private constant FREE_MEMORY_POINTER_SLOT = 0x40;\n    uint256 private constant BOOTSTRAP_LENGTH = 0x3f;\n    uint256 private constant ONE_WORD = 0x20;\n    uint256 private constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    bytes32 private constant CREATE_FAIL_ERROR = 0xebfef18800000000000000000000000000000000000000000000000000000000;\n\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\n    /// @param implementation The implementation contract to clone\n    /// @param data Encoded immutable args\n    /// @return instance The address of the created clone\n    function clone(address implementation, bytes memory data)\n        internal\n        returns (address payable instance)\n    {\n        // unrealistic for memory ptr or data length to exceed 256 bits\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let extraLength := add(mload(data), 2) // +2 bytes for telling how much data there is appended to the call\n            let creationSize := add(extraLength, BOOTSTRAP_LENGTH)\n            let runSize := sub(creationSize, 0x0a)\n\n            // free memory pointer\n            let ptr := mload(FREE_MEMORY_POINTER_SLOT)\n            \n            // -------------------------------------------------------------------------------------------------------------\n            // CREATION (10 bytes)\n            // -------------------------------------------------------------------------------------------------------------\n\n            // 61 runtime  | PUSH2 runtime (r)     | r                       | –\n            // 3d          | RETURNDATASIZE        | 0 r                     | –\n            // 81          | DUP2                  | r 0 r                   | –\n            // 60 offset   | PUSH1 offset (o)      | o r 0 r                 | –\n            // 3d          | RETURNDATASIZE        | 0 o r 0 r               | –\n            // 39          | CODECOPY              | 0 r                     | [0 - runSize): runtime code\n            // f3          | RETURN                |                         | [0 - runSize): runtime code\n\n            // -------------------------------------------------------------------------------------------------------------\n            // RUNTIME (53 bytes + extraLength)\n            // -------------------------------------------------------------------------------------------------------------\n\n            // --- copy calldata to memmory ---\n            // 36          | CALLDATASIZE          | cds                     | –\n            // 3d          | RETURNDATASIZE        | 0 cds                   | –\n            // 3d          | RETURNDATASIZE        | 0 0 cds                 | –\n            // 37          | CALLDATACOPY          |                         | [0 - cds): calldata\n\n            // --- keep some values in stack ---\n            // 3d          | RETURNDATASIZE        | 0                       | [0 - cds): calldata\n            // 3d          | RETURNDATASIZE        | 0 0                     | [0 - cds): calldata\n            // 3d          | RETURNDATASIZE        | 0 0 0                   | [0 - cds): calldata\n            // 3d          | RETURNDATASIZE        | 0 0 0 0                 | [0 - cds): calldata\n            // 61 extra    | PUSH2 extra (e)       | e 0 0 0 0               | [0 - cds): calldata\n\n            // --- copy extra data to memory ---\n            // 80          | DUP1                  | e e 0 0 0 0             | [0 - cds): calldata\n            // 60 0x35     | PUSH1 0x35            | 0x35 e e 0 0 0 0        | [0 - cds): calldata\n            // 36          | CALLDATASIZE          | cds 0x35 e e 0 0 0 0    | [0 - cds): calldata\n            // 39          | CODECOPY              | e 0 0 0 0               | [0 - cds): calldata, [cds - cds + e): extraData\n\n            // --- delegate call to the implementation contract ---\n            // 36          | CALLDATASIZE          | cds e 0 0 0 0           | [0 - cds): calldata, [cds - cds + e): extraData\n            // 01          | ADD                   | cds+e 0 0 0 0           | [0 - cds): calldata, [cds - cds + e): extraData\n            // 3d          | RETURNDATASIZE        | 0 cds+e 0 0 0 0         | [0 - cds): calldata, [cds - cds + e): extraData\n            // 73 addr     | PUSH20 addr           | addr 0 cds+e 0 0 0 0    | [0 - cds): calldata, [cds - cds + e): extraData\n            // 5a          | GAS                   | gas addr 0 cds+e 0 0 0 0| [0 - cds): calldata, [cds - cds + e): extraData\n            // f4          | DELEGATECALL          | success 0 0             | [0 - cds): calldata, [cds - cds + e): extraData\n\n            // --- copy return data to memory ---\n            // 3d          | RETURNDATASIZE        | rds success 0 0         | [0 - cds): calldata, [cds - cds + e): extraData\n            // 3d          | RETURNDATASIZE        | rds rds success 0 0     | [0 - cds): calldata, [cds - cds + e): extraData\n            // 93          | SWAP4                 | 0 rds success 0 rds     | [0 - cds): calldata, [cds - cds + e): extraData\n            // 80          | DUP1                  | 0 0 rds success 0 rds   | [0 - cds): calldata, [cds - cds + e): extraData\n            // 3e          | RETURNDATACOPY        | success 0 rds           | [0 - rds): returndata, ... the rest might be dirty\n            \n            // 60 0x33     | PUSH1 0x33            | 0x33 success 0 rds      | [0 - rds): returndata, ... the rest might be dirty\n            // 57          | JUMPI                 | 0 rds                   | [0 - rds): returndata, ... the rest might be dirty\n\n            // --- revert ---\n            // fd          | REVERT                |                         | [0 - rds): returndata, ... the rest might be dirty\n\n            // --- return ---\n            // 5b          | JUMPDEST              | 0 rds                   | [0 - rds): returndata, ... the rest might be dirty\n            // f3          | RETURN                |                         | [0 - rds): returndata, ... the rest might be dirty\n\n            mstore(\n                ptr,\n                or(\n                    hex\"610000_3d_81_600a_3d_39_f3_36_3d_3d_37_3d_3d_3d_3d_610000_80_6035_36_39_36_01_3d_73\",\n                    or(\n                        shl(0xe8, runSize),\n                        shl(0x58, extraLength)\n                    )\n                )\n            )\n            \n            mstore(\n                add(ptr, 0x1e),\n                shl(0x60, implementation)\n            )\n\n            mstore(\n                add(ptr, 0x32),\n                hex\"5a_f4_3d_3d_93_80_3e_6033_57_fd_5b_f3\"\n            )\n\n\n            // -------------------------------------------------------------------------------------------------------------\n            // APPENDED DATA (Accessible from extcodecopy)\n            // (but also send as appended data to the delegatecall)\n            // -------------------------------------------------------------------------------------------------------------\n\n            let counter := mload(data)\n            let copyPtr := add(ptr, BOOTSTRAP_LENGTH)\n            let dataPtr := add(data, ONE_WORD)\n\n            for {} true {} {\n                if lt(counter, ONE_WORD) {\n                    break\n                }\n\n                mstore(copyPtr, mload(dataPtr))\n\n                copyPtr := add(copyPtr, ONE_WORD)\n                dataPtr := add(dataPtr, ONE_WORD)\n\n                counter := sub(counter, ONE_WORD)\n            }\n                \n            let mask := shl(\n                shl(3, sub(ONE_WORD, counter)), \n                MAX_UINT256\n            )\n\n            mstore(copyPtr, and(mload(dataPtr), mask))\n            copyPtr := add(copyPtr, counter)\n            mstore(copyPtr, shl(0xf0, extraLength))\n\n            instance := create(0, ptr, creationSize)\n\n            if iszero(instance) {\n                // revert CreateFail()\n                mstore(0, CREATE_FAIL_ERROR)\n                revert(0, ONE_WORD)\n            }\n\n            // Update free memory pointer\n            mstore(FREE_MEMORY_POINTER_SLOT, add(ptr, creationSize))\n        }\n    }\n}\n"
    },
    "node_modules/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "node_modules/forge-std/src/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initialize` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve `mainnet`'s RPC URL:\n *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that\n *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.\n *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if\n *     a URL is given or if an environment variable is given and that environment variable exists).\n *     Otherwise, the default data is returned.\n *   - If you specified data with `setChain` it will return that.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private initialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initialize();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initialize();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initialize();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initialize() private {\n        if (initialized) return;\n\n        initialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "node_modules/forge-std/src/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\n// TODO Remove import.\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "node_modules/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Standard Library's default Test\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n// ⭐️ TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "node_modules/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "node_modules/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@cwia/=node_modules/clones-with-immutable-args/src/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
      "@rari-capital/=node_modules/@rari-capital/",
      "@rari-capital/solmate/=node_modules/@rari-capital/solmate/",
      "clones-with-immutable-args/=node_modules/clones-with-immutable-args/",
      "ds-test/=node_modules/ds-test/src/",
      "forge-std/=node_modules/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}